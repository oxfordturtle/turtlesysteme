/*
Text for the user input help tab.
*/
import { element } from '../tools.js'
import { highlight } from '../compiler/index.js'

// help text for Turtle BASIC
export const BASIC = [
  element('h3', { content: 'User Input' }),
  element('p', { content: 'The facilities for user input – via keyboard or mouse – are designed to be as straightforward and comprehensible as possible, while operating strictly through simple processes that are consistent with the workings of the <em>Turtle Machine</em>.' }),
  element('h4', { content: 'Mouse Position Detection' }),
  element('p', { content: `The x- and y-coordinates of the mouse&rsquo;s current position can be found at any time by using the special global variables <code>${highlight('?MOUSEX', 'BASIC')}</code> and <code>${highlight('?MOUSEY', 'BASIC')}</code> – these do not require the mouse to be clicked.` }),
  element('h4', { content: 'Mouse Click Detection' }),
  element('p', { content: `When a mouse click is performed, the x- and y-coordinates of the click position are remembered by the variables <code>${highlight('?CLICKX', 'BASIC')}</code> and <code>${highlight('?CLICKY', 'BASIC')}</code>. However to identify the type of click, use the variable <code>${highlight('?CLICK', 'BASIC')}</code>, which is initially set to a value of -1, but after any click has taken place is set to a numerical value of 128 plus additions as follows:` }),
  element('table', { classes: ['tsx-help-table'],
    content: [
      element('tr', { content: '<td>1</td><td>if the click was with the left mouse button</td>' }),
      element('tr', { content: '<td>2</td><td>if the click was with the right mouse button</td>' }),
      element('tr', { content: '<td>4</td><td>if the click was with the middle mouse button</td>' }),
      element('tr', { content: '<td>8</td><td>if the <kbd>shift</kbd> key was held down while clicking</td>' }),
      element('tr', { content: '<td>16</td><td>if the <kbd>alt</kbd> key was held down while clicking</td>' }),
      element('tr', { content: '<td>32</td><td>if the <kbd>ctrl</kbd> key was held down while clicking</td>' }),
      element('tr', { content: '<td>64</td><td>if it was a double-click</td>' })
    ]
  }),
  element('p', { content: `So if <code>${highlight('n% = ?CLICK', 'BASIC')}</code> makes <code>${highlight('n%', 'BASIC')}</code> equal to 137 (128+8+1), this indicates that a left-click is currently under way, with the <kbd>shift</kbd> key held down. When the click event is finished, the <code>${highlight('?CLICK', 'BASIC')}</code> value will become negative. Thus if <code>${highlight('?CLICK', 'BASIC')}</code> returns a value of -137, this indicates that the last click event – now finished – was <kbd>shift</kbd>+left; the coordinate position of that click can still be identified – until the next click takes place – as (<code>${highlight('?CLICKX', 'BASIC')}</code>, <code>${highlight('?CLICKY', 'BASIC')}</code>). On a left-click, the variable <code>${highlight('?LMOUSE', 'BASIC')}</code> records the relevant value (as calculated above); likewise <code>${highlight('?RMOUSE', 'BASIC')}</code> and <code>${highlight('?MMOUSE', 'BASIC')}</code> record any right-click or middle-click. Again, these are all made negative when the click is released, so an empty loop like:` }),
  element('pre', { content: `<code>${highlight('REPEAT\nUNTIL ?LMOUSE > 0', 'BASIC')}</code>` }),
  element('p', { content: `waits for a left-click with the mouse. Afterwards, <code>${highlight('?CLICKX', 'BASIC')}</code> and <code>${highlight('?CLICKY', 'BASIC')}</code> indicate where that click event occurred, and <code>${highlight('?CLICK', 'BASIC')}</code> can be queried using the bitwise <code>${highlight('AND', 'BASIC')}</code> operator to discover which special keys were pressed (e.g. <code>${highlight('IF (ABS(?CLICK) AND 8) > 0', 'BASIC')}</code> will test whether <kbd>shift</kbd> was being held down).` }),
  element('h4', { content: 'Key Press Detection' }),
  element('p', { content: `Detecting key presses (rather than typing in of characters) uses the variables <code>${highlight('?KEY', 'BASIC')}</code> and <code>${highlight('?KSHIFT', 'BASIC')}</code>, and the function <code>${highlight('KEYSTATUS', 'BASIC')}</code>. <code>${highlight('?KEY', 'BASIC')}</code> gives the code of the last key to be pressed – these codes can be tested using the special keycode constants <code>${highlight('\\ALT', 'BASIC')}</code>, <code>${highlight('\\BACKSPACE', 'BASIC')}</code>, <code>${highlight('\\CAPSLOCK', 'BASIC')}</code>, <code>${highlight('\\CTRL', 'BASIC')}</code>, <code>${highlight('\\DELETE', 'BASIC')}</code>, <code>${highlight('\\DOWN', 'BASIC')}</code>, <code>${highlight('\\END', 'BASIC')}</code>, <code>${highlight('\\ESCAPE', 'BASIC')}</code>, <code>${highlight('\\HOME', 'BASIC')}</code>, <code>${highlight('\\INSERT', 'BASIC')}</code>, <code>${highlight('\\LEFT', 'BASIC')}</code>, <code>${highlight('\\LWIN', 'BASIC')}</code>, <code>${highlight('\\PGDN', 'BASIC')}</code>, <code>${highlight('\\PGUP', 'BASIC')}</code>, <code>${highlight('\\RETURN', 'BASIC')}</code>, <code>${highlight('\\RIGHT', 'BASIC')}</code>, <code>${highlight('\\RWIN', 'BASIC')}</code>, <code>${highlight('\\SHIFT', 'BASIC')}</code>, <code>${highlight('\\SPACE', 'BASIC')}</code>, <code>${highlight('\\TAB', 'BASIC')}</code>, and <code>${highlight('\\UP', 'BASIC')}</code>, as well as <code>${highlight('\\A', 'BASIC')}</code> to <code>${highlight('\\Z', 'BASIC')}</code>, <code>${highlight('\\0', 'BASIC')}</code> to <code>${highlight('\\9', 'BASIC')}</code>, <code>${highlight('\\HASH', 'BASIC')}</code>, <code>${highlight('\\EQUALS', 'BASIC')}</code> etc. Keys on the numeric keypad have codes <code>${highlight('\\#0', 'BASIC')}</code>, <code>${highlight('\\#1', 'BASIC')}</code> etc., and function keys <code>${highlight('\\F1', 'BASIC')}</code>, <code>${highlight('\\F2', 'BASIC')}</code> etc. All these stand for numeric values (e.g. <code>${highlight('\\RETURN', 'BASIC')}</code> is 13, <code>${highlight('\\ESCAPE', 'BASIC')}</code> is 27), but <code>${highlight('IF ?KEY = \\RETURN', 'BASIC')}</code> is easier to understand than <code>${highlight('IF ?KEY = 13', 'BASIC')}</code>.` }),
  element('p', { content: `Like the mouse-click variables, <code>${highlight('?KEY', 'BASIC')}</code> becomes negative after the key is released, so <code>${highlight('REPEAT : UNTIL ?KEY = -\\A', 'BASIC')}</code> will wait until the &lsquo;A&rsquo; key has been released. If you want to identify the last key whether it is still pressed or not, use <code>${highlight('ABS', 'BASIC')}</code> (e.g. <code>${highlight('IF ABS(?KEY) = \\A THEN', 'BASIC')}</code>).` }),
  element('p', { content: `Whenever a key is pressed, the variable <code>${highlight('?KSHIFT', 'BASIC')}</code> gives its &lsquo;shift-status&rsquo;, calculated in the same way as <code>${highlight('?CLICK', 'BASIC')}</code> (i.e. 128 plus 8 if <kbd>shift</kbd> was down, 16 for <kbd>alt</kbd>, 32 for <kbd>ctrl</kbd>, and turning negative after the key is released). So to test if <kbd>ctrl</kbd> was down on the last keypress, use <code>${highlight('IF (ABS(?KSHIFT) AND 32) > 0', 'BASIC')}</code>, with <code>${highlight('AND', 'BASIC')}</code> here acting as a bitwise boolean operator.` }),
  element('p', { content: `To recover the shift-status for the last press of the <kbd>X</kbd> key (say), use <code>${highlight('KEYSTATUS(\\X)', 'BASIC')}</code>, which can tell you (a) whether <kbd>shift</kbd> / <kbd>alt</kbd> / <kbd>ctrl</kbd> were down; (b) whether the <kbd>X</kbd> is still pressed (since <code>${highlight('KEYSTATUS', 'BASIC')}</code> goes negative on release); (c) whether <kbd>X</kbd> has been pressed at all (since all of these input codes are set to -1 initially, and can be reset to -1 using <code>${highlight('RESET(\\X)', 'BASIC')}</code> etc.).` }),
  element('h4', { content: 'Keyboard Input' }),
  element('p', { content: `The system provides a <em>keyboard buffer</em> to store typed characters. Initially this is set to store up to 32 characters, but can be extended using e.g. <code>${highlight('KEYBUFFER(50)', 'BASIC')}</code>. To read from the buffer into a string, use e.g. <code>${highlight('s$ = GET$(10)', 'BASIC')}</code>, which reads up to 10 characters (depending on how many are in the buffer). <code>${highlight('KEYSTATUS(\\KEYBUFFER)', 'BASIC')}</code> returns the number of characters it contains, and <code>${highlight('RESET(\\KEYBUFFER)', 'BASIC')}</code> flushes it.` }),
  element('p', { content: `<code>${highlight('s$ = GETLINE$', 'BASIC')}</code> reads a line of text, waiting until the <kbd>return</kbd> key is pressed and then making <code>${highlight('s$', 'BASIC')}</code> equal to what has been typed into the buffer (discarding the <kbd>return</kbd> character).` }),
  element('p', { content: `The function <code>${highlight('DETECT', 'BASIC')}</code> waits a given time for some input to be received (e.g. a specific key pressed), and returns <code>${highlight('TRUE', 'BASIC')}</code> when that input is received, or <code>${highlight('FALSE', 'BASIC')}</code> if it is not received in time. Thus <code>${highlight('IF DETECT(\\ESCAPE, 5000) THEN - ELSE -', 'BASIC')}</code> gives 5 seconds to press the <kbd>escape</kbd> key (meanwhile continuing to collect any typed characters in the keyboard buffer). By default, text that goes into the keyboard buffer is also &lsquo;echoed&rsquo; to the console (below the Canvas), along with text that is output (using <code>${highlight('WRITE', 'BASIC')}</code> or <code>${highlight('WRITELN', 'BASIC')}</code>). This behaviour can be turned on and off with <code>${highlight('KEYECHO(TRUE)', 'BASIC')}</code> and <code>${highlight('KEYECHO(FALSE)', 'BASIC')}</code>.` })
]

// help text for Turtle Pascal
export const Pascal = [
  element('h3', { content: 'User Input' }),
  element('p', { content: 'The facilities for user input – via keyboard or mouse – are designed to be as straightforward and comprehensible as possible, while operating strictly through simple processes that are consistent with the workings of the <em>Turtle Machine</em>.' }),
  element('h4', { content: 'Mouse Position Detection' }),
  element('p', { content: `The x- and y-coordinates of the mouse&rsquo;s current position can be found at any time by using the special global variables <code>${highlight('?mousex', 'Pascal')}</code> and <code>${highlight('?mousey', 'Pascal')}</code> – these do not require the mouse to be clicked.` }),
  element('h4', { content: 'Mouse Click Detection' }),
  element('p', { content: `When a mouse click is performed, the x- and y-coordinates of the click position are remembered by the variables <code>${highlight('?clickx', 'Pascal')}</code> and <code>${highlight('?clicky', 'Pascal')}</code>. However to identify the type of click, use the variable <code>${highlight('?click', 'Pascal')}</code>, which is initially set to a value of -1, but after any click has taken place is set to a numerical value of 128 plus additions as follows:` }),
  element('table', { classes: ['tsx-help-table'],
    content: [
      element('tr', { content: '<td>1</td><td>if the click was with the left mouse button</td>' }),
      element('tr', { content: '<td>2</td><td>if the click was with the right mouse button</td>' }),
      element('tr', { content: '<td>4</td><td>if the click was with the middle mouse button</td>' }),
      element('tr', { content: '<td>8</td><td>if the shift key was held down while clicking</td>' }),
      element('tr', { content: '<td>16</td><td>if the alt key was held down while clicking</td>' }),
      element('tr', { content: '<td>32</td><td>if the ctrl key was held down while clicking</td>' }),
      element('tr', { content: '<td>64</td><td>if it was a double-click</td>' })
    ]
  }),
  element('p', { content: `So if <code>${highlight('n := ?click', 'Pascal')}</code> makes <code>${highlight('n', 'Pascal')}</code> equal to 137 (128 + 8 + 1), this indicates that a left-click is currently under way, with the <kbd>shift</kbd> key held down. When the click event is finished, the <code>${highlight('?click', 'Pascal')}</code> value will become negative. Thus if <code>${highlight('?click', 'Pascal')}</code> returns a value of -137, this indicates that the last click event – now finished – was shift+left; the coordinate position of that click can still be identified – until the next click takes place – as (<code>${highlight('?clickx', 'Pascal')}</code>, <code>${highlight('?clicky', 'Pascal')}</code>). On a left-click, the variable <code>${highlight('?lmouse', 'Pascal')}</code> records the relevant value (as calculated above); likewise <code>${highlight('?rmouse', 'Pascal')}</code> and <code>${highlight('?mmouse', 'Pascal')}</code> record any right-click or middle-click. Again, these are all made negative when the click is released, so an empty loop like:` }),
  element('pre', { content: `<code>${highlight('repeat\nuntil ?lmouse > 0;', 'Pascal')}</code>` }),
  element('p', { content: `waits for a left-click with the mouse. Afterwards, <code>${highlight('?clickx', 'Pascal')}</code> and <code>${highlight('?clicky', 'Pascal')}</code> indicate where that click event occurred, and <code>${highlight('?click', 'Pascal')}</code> can be queried using the bitwise <code>${highlight('and', 'Pascal')}</code> operator to discover which special keys were pressed (e.g. <code>${highlight('if (abs(?click) and 8) > 0', 'Pascal')}</code> will test whether <kbd>shift</kbd> was being held down).` }),
  element('h4', { content: 'Key Press Detection' }),
  element('p', { content: `Detecting key presses (rather than typing in of characters) uses the variables <code>${highlight('?key', 'Pascal')}</code> and <code>${highlight('?kshift', 'Pascal')}</code>, and the function <code>${highlight('keystatus', 'Pascal')}</code>. <code>${highlight('?key', 'Pascal')}</code> gives the code of the last key to be pressed – these codes can be tested using the special keycode constants <code>${highlight('\\alt', 'Pascal')}</code>, <code>${highlight('\\backspace', 'Pascal')}</code>, <code>${highlight('\\capslock', 'Pascal')}</code>, <code>${highlight('\\ctrl', 'Pascal')}</code>, <code>${highlight('\\delete', 'Pascal')}</code>, <code>${highlight('\\down', 'Pascal')}</code>, <code>${highlight('\\end', 'Pascal')}</code>, <code>${highlight('\\escape', 'Pascal')}</code>, <code>${highlight('\\home', 'Pascal')}</code>, <code>${highlight('\\insert', 'Pascal')}</code>, <code>${highlight('\\left', 'Pascal')}</code>, <code>${highlight('\\lwin', 'Pascal')}</code>, <code>${highlight('\\pgdn', 'Pascal')}</code>, <code>${highlight('\\pgup', 'Pascal')}</code>, <code>${highlight('\\return', 'Pascal')}</code>, <code>${highlight('\\right', 'Pascal')}</code>, <code>${highlight('\\rwin', 'Pascal')}</code>, <code>${highlight('\\shift', 'Pascal')}</code>, <code>${highlight('\\space', 'Pascal')}</code>, <code>${highlight('\\tab', 'Pascal')}</code>, and <code>${highlight('\\up', 'Pascal')}</code>, as well as <code>${highlight('\\a', 'Pascal')}</code> to <code>${highlight('\\z', 'Pascal')}</code>, <code>${highlight('\\0', 'Pascal')}</code> to <code>${highlight('\\9', 'Pascal')}</code>, <code>${highlight('\\hash', 'Pascal')}</code>, <code>${highlight('\\equals', 'Pascal')}</code> etc. Keys on the numeric keypad have codes <code>${highlight('\\#0', 'Pascal')}</code>, <code>${highlight('\\#1', 'Pascal')}</code> etc., and function keys <code>${highlight('\\f1', 'Pascal')}</code>, <code>${highlight('\\f2', 'Pascal')}</code> etc. All these stand for numeric values (e.g. <code>${highlight('\\return', 'Pascal')}</code> is 13, <code>${highlight('\\escape', 'Pascal')}</code> is 27), but <code>${highlight('if ?key = \return', 'Pascal')}</code> is easier to understand than <code>${highlight('if ?key = 13', 'Pascal')}</code>.` }),
  element('p', { content: `Like the mouse-click functions, <code>${highlight('?key', 'Pascal')}</code> becomes negative after the key is released, so <code>${highlight('repeat until ?key = -\\a', 'Pascal')}</code> will wait until the <kbd>A</kbd> key has been released. If you want to identify the last key whether it is still pressed or not, use <code>${highlight('abs', 'Pascal')}</code> (e.g. <code>${highlight('if abs(?key) = \\a then {commands}', 'Pascal')}</code>).` }),
  element('p', { content: `Whenever a key is pressed, the variable <code>${highlight('?kshift', 'Pascal')}</code> gives its &lsquo;shift-status&rsquo;, calculated in the same way as <code>${highlight('?click', 'Pascal')}</code> (i.e. 128 plus 8 if <kbd>shift</kbd> was down, 16 for <kbd>alt</kbd>, 32 for <kbd>ctrl</kbd>, and turning negative after the key is released). So to test if <kbd>ctrl</kbd> was down on the last keypress, use <code>${highlight('if (abs(?kshift) and 32) > 0', 'Pascal')}</code>, with <code>${highlight('and', 'Pascal')}</code> here acting as a bitwise boolean operator.` }),
  element('p', { content: `To recover the shift-status for the last press of the <kbd>X</kbd> key (say), use <code>${highlight('keystatus(\\x)', 'Pascal')}</code>, which can tell you (a) whether <kbd>shift</kbd> / <kbd>alt</kbd> / <kbd>ctrl</kbd> were down; (b) whether the <kbd>X</kbd> is still pressed (since <code>${highlight('keystatus', 'Pascal')}</code> goes negative on release); (c) whether <kbd>X</kbd> has been pressed at all (since all of these input codes are set to -1 initially, and can be reset to -1 using <code>${highlight('reset(\\x)', 'Pascal')}</code> etc.).` }),
  element('h4', { content: 'Keyboard Input' }),
  element('p', { content: `The system provides a <em>keyboard buffer</em> to store typed characters. Initially this is set to store up to 32 characters, but can be extended using e.g. <code>${highlight('keybuffer(50)', 'Pascal')}</code>. To read from the buffer into a string, use e.g. <code>${highlight('s := read(10)', 'Pascal')}</code>, which reads up to 10 characters (depending on how many are in the buffer). <code>${highlight('keystatus(\\keybuffer)', 'Pascal')}</code> returns the number of characters it contains, and <code>${highlight('reset(\\keybuffer)', 'Pascal')}</code> flushes it.` }),
  element('p', { content: `<code>${highlight('s := readln', 'Pascal')}</code> reads a line of text, waiting until the <kbd>return</kbd> key is pressed and then making <code>${highlight('s', 'Pascal')}</code> equal to what has been typed into the buffer (discarding the <kbd>return</kbd> character).` }),
  element('p', { content: `The function <code>${highlight('detect', 'Pascal')}</code> waits a given time for some input to be received (e.g. a specific key pressed), and returns <code>${highlight('true', 'Pascal')}</code> when that input is received, or <code>${highlight('false', 'Pascal')}</code> if it is not received in time. Thus <code>${highlight('if detect(\\escape, 5000) then {command1} else {command2}', 'Pascal')}</code> gives 5 seconds to press the <kbd>escape</kbd> key (meanwhile continuing to collect any typed characters in the keyboard buffer). By default, text that goes into the keyboard buffer is also &lsquo;echoed&rsquo; to the console (below the Canvas), along with text that is output (using <code>${highlight('write', 'Pascal')}</code> or <code>${highlight('writeln', 'Pascal')}</code>). This behaviour can be turned on and off with <code>${highlight('keyecho(true)', 'Pascal')}</code> and <code>${highlight('keyecho(false)', 'Pascal')}</code>.` })
]

// help text for Turtle Python
export const Python = [
  element('h3', { content: 'User Input' }),
  element('p', { content: 'The facilities for user input – via keyboard or mouse – are designed to be as straightforward and comprehensible as possible, while operating strictly through simple processes that are consistent with the workings of the <em>Turtle Machine</em>.' }),
  element('h4', { content: 'Mouse Position Detection' }),
  element('p', { content: `The x- and y-coordinates of the mouse&rsquo;s current position can be found at any time by using the special global variables <code>${highlight('?mousex', 'Python')}</code> and <code>${highlight('?mousey', 'Python')}</code> – these do not require the mouse to be clicked.` }),
  element('h4', { content: 'Mouse Click Detection' }),
  element('p', { content: `When a mouse click is performed, the x- and y-coordinates of the click position are remembered by the variables <code>${highlight('?clickx', 'Python')}</code> and <code>${highlight('?clicky', 'Python')}</code>. However to identify the type of click, use the variable <code>${highlight('?click', 'Python')}</code>, which is initially set to a value of -1, but after any click has taken place is set to a numerical value of 128 plus additions as follows:` }),
  element('table', { classes: ['tsx-help-table'],
    content: [
      element('tr', { content: '<td>1</td><td>if the click was with the left mouse button</td>' }),
      element('tr', { content: '<td>2</td><td>if the click was with the right mouse button</td>' }),
      element('tr', { content: '<td>4</td><td>if the click was with the middle mouse button</td>' }),
      element('tr', { content: '<td>8</td><td>if the shift key was held down while clicking</td>' }),
      element('tr', { content: '<td>16</td><td>if the alt key was held down while clicking</td>' }),
      element('tr', { content: '<td>32</td><td>if the ctrl key was held down while clicking</td>' }),
      element('tr', { content: '<td>64</td><td>if it was a double-click</td>' })
    ]
  }),
  element('p', { content: `So if <code>${highlight('n = ?click', 'Python')}</code> makes <code>${highlight('n', 'Python')}</code> equal to 137 (128 + 8 + 1), this indicates that a left-click is currently under way, with the <kbd>shift</kbd> key held down. When the click event is finished, the <code>${highlight('?click', 'Python')}</code> variable will become negative. Thus if <code>${highlight('?click', 'Python')}</code> returns a value of -137, this indicates that the last click event – now finished – was shift+left; the coordinate position of that click can still be identified – until the next click takes place – as (<code>${highlight('?clickx', 'Python')}</code>, <code>${highlight('?clicky', 'Python')}</code>). On a left-click, the variable <code>${highlight('?lmouse', 'Python')}</code> records the relevant value (as calculated above); likewise <code>${highlight('?rmouse', 'Python')}</code> and <code>${highlight('?mmouse', 'Python')}</code> record any right-click or middle-click. Again, these are all made negative when the click is released, so an empty loop like:` }),
  element('pre', { content: `<code>${highlight('while not(?lmouse > 0):\n  pass  # this statement does nothing!', 'Python')}</code>` }),
  element('p', { content: `waits for a left-click with the mouse. Afterwards, <code>${highlight('?clickx', 'Python')}</code> and <code>${highlight('?clicky', 'Python')}</code> indicate where that click event occurred, and <code>${highlight('?click', 'Python')}</code> can be queried using the bitwise <code>${highlight('and', 'Python')}</code> operator to discover which special keys were pressed (e.g. <code>${highlight('if (abs(?click) and 8) > 0', 'Python')}</code> will test whether <kbd>shift</kbd> was being held down).` }),
  element('h4', { content: 'Key Press Detection' }),
  element('p', { content: `Detecting key presses (rather than typing in of characters) uses the variables <code>${highlight('?key', 'Python')}</code> and <code>${highlight('?kshift', 'Python')}</code>, and the function <code>${highlight('keystatus', 'Python')}</code>. <code>${highlight('?key', 'Python')}</code> gives the code of the last key to be pressed – these codes can be tested using the special keycode constants <code>${highlight('\\alt', 'Python')}</code>, <code>${highlight('\\backspace', 'Python')}</code>, <code>${highlight('\\capslock', 'Python')}</code>, <code>${highlight('\\ctrl', 'Python')}</code>, <code>${highlight('\\delete', 'Python')}</code>, <code>${highlight('\\down', 'Python')}</code>, <code>${highlight('\\end', 'Python')}</code>, <code>${highlight('\\escape', 'Python')}</code>, <code>${highlight('\\home', 'Python')}</code>, <code>${highlight('\\insert', 'Python')}</code>, <code>${highlight('\\left', 'Python')}</code>, <code>${highlight('\\lwin', 'Python')}</code>, <code>${highlight('\\pgdn', 'Python')}</code>, <code>${highlight('\\pgup', 'Python')}</code>, <code>${highlight('\return', 'Python')}</code>, <code>${highlight('\right', 'Python')}</code>, <code>${highlight('\\rwin', 'Python')}</code>, <code>${highlight('\\shift', 'Python')}</code>, <code>${highlight('\\space', 'Python')}</code>, <code>${highlight('\\tab', 'Python')}</code>, and <code>${highlight('\\up', 'Python')}</code>, as well as <code>${highlight('\\a', 'Python')}</code> to <code>${highlight('\\z', 'Python')}</code>, <code>${highlight('\\0', 'Python')}</code> to <code>${highlight('\\9', 'Python')}</code>, <code>${highlight('\\hash', 'Python')}</code>, <code>${highlight('\\equals', 'Python')}</code> etc. Keys on the numeric keypad have codes <code>${highlight('\\#0', 'Python')}</code>, <code>${highlight('\\#1', 'Python')}</code> etc., and function keys <code>${highlight('\\f1', 'Python')}</code>, <code>${highlight('\\f2', 'Python')}</code> etc. All these stand for numeric values (e.g. <code>${highlight('\\return', 'Python')}</code> is 13, <code>${highlight('\\escape', 'Python')}</code> is 27), but <code>${highlight('if ?key = \return', 'Python')}</code> is easier to understand than <code>${highlight('if ?key = 13', 'Python')}</code>.` }),
  element('p', { content: `Like the mouse-click variables, <code>${highlight('?key', 'Python')}</code> becomes negative after the key is released, so <code>${highlight('while not(?key = -\\a): pass', 'Python')}</code> will wait until the <kbd>A</kbd> key has been released. If you want to identify the last key, whether it is still pressed or not, use <code>${highlight('abs', 'Python')}</code> (e.g. <code>${highlight('if abs(?key) = \\a: # command', 'Python')}</code>).` }),
  element('p', { content: `Whenever a key is pressed, the variable <code>${highlight('?kshift', 'Python')}</code> gives its &lsquo;shift-status&rsquo;, calculated in the same way as <code>${highlight('?click', 'Python')}</code> (i.e. 128 plus 8 if <kbd>shift</kbd> was down, 16 for <kbd>alt</kbd>, 32 for <kbd>ctrl</kbd>, and turning negative after the key is released). So to test if <kbd>ctrl</kbd> was down on the last keypress, use <code>${highlight('if (abs(?kshift) and 32) > 0', 'Python')}</code>, with <code>${highlight('and', 'Python')}</code> here acting as a bitwise boolean operator.` }),
  element('p', { content: `To recover the shift-status for the last press of the <kbd>X</kbd> key (say), use <code>${highlight('keystatus(\\x)', 'Python')}</code>, which can tell you (a) whether <kbd>shift</kbd> / <kbd>alt</kbd> / <kbd>ctrl</kbd> were down; (b) whether the <kbd>X</kbd> is still pressed (since <code>${highlight('keystatus', 'Python')}</code> goes negative on release); (c) whether <kbd>X</kbd> has been pressed at all (since all of these input codes are set to -1 initially, and can be reset to -1 using <code>${highlight('reset(\\x)', 'Python')}</code> etc.).` }),
  element('h4', { content: 'Keyboard Input' }),
  element('p', { content: `The system provides a <em>keyboard buffer</em> to store typed characters. Initially this is set to store up to 32 characters, but can be extended using e.g. <code>${highlight('keybuffer(50)', 'Python')}</code>. To read from the buffer into a string, use e.g. <code>${highlight('s = read(10)', 'Python')}</code>, which reads up to 10 characters (depending on how many are in the buffer). <code>${highlight('keystatus(\\keybuffer)', 'Python')}</code> returns the number of characters it contains, and <code>${highlight('reset(\\keybuffer)', 'Python')}</code> flushes it.` }),
  element('p', { content: `<code>${highlight('s = readln', 'Python')}</code> reads a line of text, waiting until the <kbd>return</kbd> key is pressed and then making <code>${highlight('s', 'Python')}</code> equal to what has been typed into the buffer (discarding the <kbd>return</kbd> character).` }),
  element('p', { content: `The function <code>${highlight('detect', 'Python')}</code> waits a given time for some input to be received (e.g. a specific key pressed), and returns <code>${highlight('True', 'Python')}</code> when that input is received, or <code>${highlight('False', 'Python')}</code> if it is not received in time. Thus <code>${highlight('if detect(\\escape, 5000): #command1', 'Python')}</code> <code>${highlight('else: #command2', 'Python')}</code> gives 5 seconds to press the <kbd>escape</kbd> key (meanwhile continuing to collect any typed characters in the keyboard buffer). By default, text that goes into the keyboard buffer is also &lsquo;echoed&rsquo; to the console (below the Canvas), along with text that is output (using <code>${highlight('write', 'Python')}</code> or <code>${highlight('writeln', 'Python')}</code>). This behaviour can be turned on and off with <code>${highlight('keyecho(True)', 'Python')}</code> and <code>${highlight('keyecho(False)', 'Python')}</code>.` })
]
