!function(e){var n={};function t(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}t.m=e,t.c=n,t.d=function(e,n,o){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:o})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)t.d(o,r,function(n){return e[n]}.bind(null,r));return o},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=15)}([function(e,n){e.exports.element=((e,n={})=>{const t=document.createElement(e);return Object.keys(n).forEach(e=>{switch(e){case"classes":n.classes.forEach(e=>t.classList.add(e));break;case"content":"string"==typeof n.content?t.innerHTML=n.content:n.content.forEach(e=>{"string"==typeof e?t.appendChild(document.createTextNode(e)):t.appendChild(e)});break;case"value":t.value=n.value;break;case"on":n.on.forEach(e=>{t.addEventListener(e.type,e.callback)});break;default:t.setAttribute(e,n[e])}}),t}),e.exports.hex=(n=>`#${e.exports.padded(n.toString(16))}`),e.exports.padded=(n=>n.length<6?e.exports.padded(`0${n}`):n),e.exports.tabs=((n,t)=>e.exports.element("div",{classes:["tsx-tabs",n],content:[a(t),s(t)]})),e.exports.show=(e=>{t(document.querySelector(`[data-target="${e}"]`)),t(document.getElementById(e))});const t=e=>{if(e){Array.prototype.slice.call(e.parentElement.children).forEach(e=>e.classList.remove("active")),e.classList.add("active")}},o=e=>{t(e.currentTarget),t(document.getElementById(e.currentTarget.getAttribute("data-target")))},r=n=>e.exports.element("a",{classes:n.active?["tsx-tab","active"]:["tsx-tab"],content:n.label,"data-target":n.label.replace(/ /g,""),on:[{type:"click",callback:o}]}),a=n=>e.exports.element("nav",{classes:["tsx-tab-list"],content:n.map(r)}),i=n=>e.exports.element("div",{classes:n.active?["tsx-tab-pane","active"]:["tsx-tab-pane"],content:n.content,id:n.label.replace(/ /g,"")}),s=n=>e.exports.element("div",{classes:["tsx-tab-panes"],content:n.map(i)})},function(e,n,t){e.exports.send=((e,n)=>{try{switch(e){case"ready":i("language-changed",a.language.get());break;case"new-program":a.file.new(),i("file-changed",a.file.get());break;case"save-program":case"save-program-as":break;case"set-language":a.language.set(n),i("language-changed",a.language.get());break;case"set-example":a.example.set(n),i("file-changed",a.file.get());break;case"set-file":a.file.set(n.filename,n.content),i("language-changed",a.language.get());break;case"set-name":a.name.set(n,a.language.get()),i("name-changed",a.name.get());break;case"set-code":a.code.set(n,a.language.get()),a.compiled.set(!1,a.language.get()),i("code-changed",{code:a.code.get(),language:a.language.get()});break;case"toggle-assembler":a.assembler.toggle(),i("pcode-changed",{pcode:a.pcode.get(),assembler:a.assembler.get(),decimal:a.decimal.get()});break;case"toggle-decimal":a.decimal.toggle(),i("pcode-changed",{pcode:a.pcode.get(),assembler:a.assembler.get(),decimal:a.decimal.get()});break;case"toggle-show-canvas":a.showCanvas.toggle(),i("show-canvas-changed",a.showCanvas.get());break;case"toggle-show-output":a.showOutput.toggle(),i("show-output-changed",a.showOutput.get());break;case"toggle-show-memory":a.showMemory.toggle(),i("show-memory-changed",a.showMemory.get());break;case"show-settings":i("show-settings");break;case"set-draw-count-max":a.drawCountMax.set(n),i("draw-count-max-changed",a.drawCountMax.get());break;case"set-code-count-max":a.codeCountMax.set(n),i("code-count-max-changed",a.codeCountMax.get());break;case"set-small-size":a.smallSize.set(n),i("small-size-changed",a.smallSize.get());break;case"set-stack-size":a.stackSize.set(n),i("stack-size-changed",a.stackSize.get());break;case"reset-machine-options":a.machineOptions.reset(),i("draw-count-max-changed",a.drawCountMax.get()),i("code-count-max-changed",a.codeCountMax.get()),i("small-size-changed",a.smallSize.get()),i("stack-size-changed",a.stackSize.get());break;case"set-group":a.group.set(n),i("group-changed",a.group.get());break;case"toggle-simple":a.simple.toggle(),i("simple-changed",a.simple.get());break;case"toggle-intermediate":a.intermediate.toggle(),i("intermediate-changed",a.intermediate.get());break;case"toggle-advanced":a.advanced.toggle(),i("advanced-changed",a.advanced.get());break;case"machine-run-halt":if(r.isRunning())r.halt(n);else{if(!a.compiled.get()&&a.code.get().length>0){let e=o.compile(a.code.get(),a.language.get());a.usage.set(e.usage,a.language.get()),a.pcode.set(e.pcode,a.language.get()),a.compiled.set(!0,a.language.get()),i("usage-changed",e.usage),i("pcode-changed",{pcode:e.pcode,assembler:a.assembler.get(),decimal:a.decimal.get()})}a.pcode.get().length>0&&r.run(a.pcode.get(),a.machineOptions.get(),n)}break;case"machine-play-pause":r.isRunning()&&(r.isPaused()?r.play():r.pause());break;default:console.log(`unknown signal '${e}'`)}}catch(e){i("error",e)}}),e.exports.on=((e,n)=>{s[e]?s[e].push(n):s[e]=[n]});const o=t(4),r=t(42),a=t(43),i=(e,n)=>{s[e]&&s[e].forEach(e=>e(n)),"language-changed"===e&&i("file-changed",a.file.get()),"file-changed"===e&&(i("name-changed",a.name.get()),i("code-changed",{code:a.code.get(),language:a.language.get()}),i("usage-changed",a.usage.get()),i("pcode-changed",{pcode:a.pcode.get(),assembler:a.assembler.get(),decimal:a.decimal.get()}))},s={};r.on("run",()=>i("machine-started")),r.on("halt",()=>i("machine-stopped")),r.on("play",()=>i("machine-played")),r.on("pause",()=>i("machine-paused")),r.on("turtx",e=>i("turtx-changed",e)),r.on("turty",e=>i("turty-changed",e)),r.on("turtd",e=>i("turtd-changed",e)),r.on("turtt",e=>i("turtt-changed",e)),r.on("turtc",e=>i("turtc-changed",e))},function(e,n,t){e.exports={categories:t(9),colours:t(20),commands:t(10),cursors:t(21),examples:t(22),fonts:t(23),inputs:t(24),languages:["BASIC","Pascal","Python"],pc:t(11),pcodes:t(12),usage:t(25)}},function(e,n,t){e.exports={error:t(6),factory:t(28),find:t(5),molecules:t(29),pcoder:t(7)}},function(e,n,t){e.exports.highlight=((e,n)=>s(e,n).map(l).join("")),e.exports.compile=((e,n)=>{const t=r(e,n),s=a(t,n);console.log(s);const l=i(s,n);return console.log(l),{usage:o(t,s.slice(1),n),pcode:l}});const o=t(26),r=t(27),a=t(34),i=t(38),s=t(14),l=e=>`<span class="tsx-${e.type}">${e.content}</span>`},function(e,n,t){e.exports.program=(n=>n.parent?e.exports.program(n.parent):n),e.exports.constant=((e,n,t)=>s(e,"constants",n,t)),e.exports.variable=((n,t,o)=>{const r=("BASIC"===o?["TURTX%","TURTY%","TURTD%","TURTT%","TURTC%"]:["turtx","turty","turtd","turtt","turtc"]).indexOf(t)+1,a=n.index>0&&n.globals.indexOf(t)>-1;return r>0?{turtle:r,fulltype:{type:"integer"}}:s(a?e.exports.program(n):n,"variables",t,o)}),e.exports.colour=((e,n)=>r.find(i.bind(null,l(e),n))),e.exports.input=((e,n)=>a.find(i.bind(null,e,n))),e.exports.custom=((e,n,t)=>s(e,"subroutines",n,t)),e.exports.native=((e,n)=>o.find(i.bind(null,l(e),n))),e.exports.command=((n,t,o)=>e.exports.custom(n,t,o)||e.exports.native(t,o));const{commands:o,colours:r,inputs:a}=t(2),i=(e,n,t)=>(t.name||t.names[n])===e,s=(e,n,t,o)=>e.parent?e[n].find(i.bind(null,t,o))||s(e.parent,n,t,o):e[n].find(i.bind(null,t,o)),l=e=>e.replace(/gray/,"grey").replace(/GRAY/,"GREY").replace(/^COLOR$/,"COLOUR").replace(/^color$/,"colour")},function(e,n){e.exports=((e,n)=>{const t=new Error(e.replace("{lex}",`"${n.content}"`));return t.lexeme=n,t.type="Compiler",t})},function(e,n,t){e.exports.merge=((e,n)=>e.slice(0,-1).concat([e[e.length-1].concat(n[0])]).concat(n.slice(1))),e.exports.mergeWithOperator=((n,t,r)=>{const a=e.exports.merge(n,t.pcode),i=e.exports.merge(a,[o[r]]);return Object.assign(t,{pcode:i})}),e.exports.loadLiteralValue=((e,n)=>"string"===e?[o.lstr,n.length].concat(Array.from(n).map(e=>e.charCodeAt(0))):[o.ldin,n]),e.exports.loadInputValue=(n=>n.value<0?e.exports.loadLiteralValue("integer",n.value):e.exports.loadLiteralValue("integer",n.value).concat(o.inpt)),e.exports.loadVariableValue=(e=>e.turtle?[o.ldin,0,o.lptr,o.ldin,e.turtle,o.plus,o.lptr]:0===e.routine.index?[o.ldvg,e.routine.turtleAddress+5+e.index]:e.byref?[o.ldvr,e.routine.index+9,e.index]:[o.ldvv,e.routine.index+9,e.index]),e.exports.loadVariableAddress=(e=>e.turtle?[o.ldin,0,o.lptr,o.ldin,e.turtle,o.plus]:0===e.routine.index?[o.ldag,e.routine.turtleAddress+5+e.index]:[o.ldav,e.routine.index+9,e.index]),e.exports.storeVariableValue=((e,n)=>e.turtle?[o.ldin,0,o.lptr,o.ldin,e.turtle,o.plus,o.sptr]:0===e.routine.index?"string"===e.fulltype.type?[o.ldvg,e.routine.turtleAddress+5+e.index,o.cstr]:[o.stvg,e.routine.turtleAddress+5+e.index]:"string"===e.fulltype.type?[o.ldvv,e.routine.index+9,e.index,o.cstr,o.hclr]:e.byref&&!n?[o.stvr,e.routine.index+9,e.index]:[o.stvv,e.routine.index+9,e.index]),e.exports.loadFunctionReturnValue=(e=>[o.ldvv,e,1]),e.exports.applyOperator=(e=>[o[e]]),e.exports.callCommand=((e,n,t)=>{const a=r.program(n).turtleAddress;switch(e.code){case o.newt:return[o.ldin,0,o.sptr];case o.oldt:return[o.ldin,a,o.ldin,0,o.sptr];case o.incr:case o.decr:return[o.dupl,o.lptr,e.code,o.swap,o.sptr];case o.rndc:return[o.rand,o.incr,o.rgb,o.colr];case o.rand:switch(t){case"BASIC":return[o.rand,o.incr];case"Pascal":return[o.rand];case"Python":return[o.swap,o.dupl,o.rota,o.incr,o.swap,o.subt,o.rand,o.plus]}break;case o.texl:return[o.text,o.newl];case o.uppc:return[o.ldin,1,o.case];case o.lowc:return[o.ldin,-1,o.case];case o.lefs:return[o.ldin,1,o.swap,o.copy];case o.rgts:return[o.swap,o.dupl,o.slen,o.incr,o.rota,o.subt,o.mxin,o.copy];case o.inss:switch(t){case"BASIC":case"Python":return[o.rota,o.rota,o.inss];case"Pascal":return[o.inss]}break;case o.poss:switch(t){case"BASIC":case"Python":return[o.swap,o.poss];case"Pascal":return[o.poss]}break;case o.svd0:return[o.ldin,0,o.sval];case o.bool:return[o.abs];case o.ilin:return[o.text,o.newl,o.rdln];case o.bufr:return[o.bufr,o.ldin,1,o.sptr,o.hfix];case void 0:return[o.subr,e.startLine];default:return[e.code]}}),e.exports.conditional=((e,n,t,r)=>{const a=r.length>0?2:1,i=[n.concat([o.ifno,t.length+e+a])],s=[[o.jump,t.length+r.length+e+a]];return r.length>0?i.concat(t).concat(s).concat(r):i.concat(t)}),e.exports.forLoop=((n,t,r,a,i,s,l)=>{const c=l.length+n+4,d=[r,e.exports.storeVariableValue(t).concat(a),e.exports.loadVariableValue(t).concat([o[i],o.ifno,c])],u=[e.exports.loadVariableValue(t).concat([o[s],o.jump,n+1])];return d.concat(l).concat(u)}),e.exports.repeatLoop=((e,n,t)=>{const r=[n.concat([o.ifno,e])];return t.concat(r)}),e.exports.whileLoop=((e,n,t)=>{const r=[n.concat([o.ifno,t.length+e+2])],a=[[o.jump,e]];return r.concat(t).concat(a)}),e.exports.subroutine=((n,t)=>{const o=e.exports.subroutineStartCode(n),r=d(n);return o.concat(t).concat(r)}),e.exports.subroutineStartCode=(e=>{const n=[[o.pssr,e.index]],t=n.concat(l(e));return e.variables.length>0&&e.parameters.length>0?t.concat(c(e)):e.variables.length>0?t:n}),e.exports.program=((e,n,t)=>{const r=p(e),a=[[o.jump,r.length+n.length+2]],i=[[o.halt]];return n.length>1?r.concat(a).concat(n).concat(t).concat(i):r.concat(t).concat(i)});const{pc:o}=t(2),r=t(5),a=e=>e.variables.filter(e=>"string"===e.fulltype.type),i=e=>{const n=e.routine.turtleAddress+5+e.index;return[o.ldag,n+2,o.stvg,n,o.ldin,e.length-1,o.stvg,n+1]},s=e=>{const n=e.routine.index+9,t=e.index;return[o.ldav,n,t+2,o.stvv,n,t,o.ldin,e.length-1,o.stvv,n,t+1]},l=e=>{const n=[[o.memc,e.index+9,e.memoryNeeded],[o.ldav,e.index+9,1,o.ldin,e.memoryNeeded,o.zptr]];return a(e).length>0?n.concat(a(e).map(s)):n},c=n=>{const t=[];let o=n.parameters.length;for(;o>0;)o-=1,t.push(e.exports.storeVariableValue(n.parameters[o]));return t},d=e=>{const n=e.index+9,t=r.program(e).resultAddress,a=[o.ldvg,n,o.stvg,t],i=[o.memr,n],s=[o.plsr,o.retn];return e.variables.length>0&&"function"===e.type?[a,i.concat(s)]:e.variables.length>0?[i.concat(s)]:[s]},u=[o.home,o.ldin,2,o.thik,o.ldin,32,o.bufr,o.ldin,1,o.sptr,o.hfix,o.ldin,0,o.dupl,o.ldin,1e3,o.dupl,o.dupl,o.dupl,o.reso,o.canv],p=e=>{const n=[((e,n)=>[o.ldin,e,o.dupl,o.dupl,o.ldin,0,o.sptr,o.ldin,5,o.swap,o.sptr,o.incr,o.ldin,n+5,o.zptr,o.ldin,e+n+5,o.stmt])(e.turtleAddress,e.memoryNeeded),u];return a(e).length>0?n.concat(a(e).map(i)):n}},function(e,n,t){const{element:o,show:r,tabs:a}=t(0),i=t(18),s=t(19),l=o("canvas",{classes:["tsx-canvas"],width:500,height:500}),c=l.getContext("2d"),d=o("pre",{classes:["tsx-console"]}),u=o("pre",{classes:["tsx-output"]});e.exports.tabs=a("tsx-system-tabs",[{label:"Settings",active:!1,content:[i]},{label:"Canvas",active:!0,content:[l,d]},{label:"Output",active:!1,content:[u]},{label:"Memory",active:!1,content:[s]}]),e.exports.show=(e=>{"canvas"!==e&&"console"!==e||a.show("Canvas"),"output"===e&&a.show("Output"),"memory"===e&&a.show("Memory")}),e.exports.addEventListener=((e,n)=>{l.addEventListener(e,n)}),e.exports.removeEventListener=((e,n)=>{l.removeEventListener(e,n)}),e.exports.bounds=(()=>l.getBoundingClientRect()),e.exports.resolution=((e,n)=>{l.width=e,l.height=n}),e.exports.cursor=(e=>{const n=e<0||e>15?1:e;l.style.cursor=h[n].css}),e.exports.print=((e,n,t,o)=>{c.textBaseline="top",c.fillStyle=p(e.c),c.font=`${o}pt ${g[15&t].css}`,(16&t)>0&&(c.font=`bold ${c.font}`),(32&t)>0&&(c.font=`italic ${c.font}`),c.fillText(n,e.x,e.y)}),e.exports.line=((e,n,t)=>{c.beginPath(),c.moveTo(e.x,e.y),c.lineTo(n,t),c.lineCap="round",c.lineWidth=e.t,c.strokeStyle=p(e.c),c.stroke()}),e.exports.poly=((e,n,t)=>{c.beginPath(),n.forEach((e,n)=>{0===n?c.moveTo(e[0],e[1]):c.lineTo(e[0],e[1])}),t?(c.closePath(),c.fillStyle=p(e.c),c.fill()):(c.lineCap="round",c.lineWidth=e.t,c.strokeStyle=p(e.c),c.stroke())}),e.exports.arc=((e,n,t,o)=>{c.beginPath(),n===t?c.arc(e.x,e.y,n,0,2*Math.PI,!1):(c.save(),c.translate(e.x-n,e.y-t),c.scale(n,t),c.arc(1,1,1,0,2*Math.PI,!1),c.restore()),o?(c.fillStyle=p(e.c),c.fill()):(c.lineWidth=e.t,c.strokeStyle=p(e.c),c.stroke())}),e.exports.box=((e,n,t,o,r)=>{c.beginPath(),c.moveTo(e.x,e.y),c.lineTo(n,e.y),c.lineTo(n,t),c.lineTo(e.x,t),c.closePath(),c.fillStyle=p(o),c.fill(),r&&(c.lineCap="round",c.lineWidth=e.t,c.strokeStyle=p(e.c),c.stroke())}),e.exports.pixcol=((e,n)=>{const t=c.getImageData(e,n,1,1);return 65536*t.data[0]+256*t.data[1]+t.data[2]}),e.exports.pixset=((e,n,t,o)=>{const r=c.createImageData(1,1);r.data[0]=t>>16&255,r.data[1]=t>>8&255,r.data[2]=255&t,r.data[3]=255,c.putImageData(r,e,n),o&&(c.putImageData(r,e-1,n),c.putImageData(r,e,n-1),c.putImageData(r,e-1,n-1))}),e.exports.blank=(e=>{c.fillStyle=p(e),c.fillRect(0,0,l.width,l.height)}),e.exports.flood=((e,n,t,o,r)=>{const a=c.getImageData(0,0,l.width,l.height),i=[],s=[0,-1,1,0],d=[-1,0,0,1];let u=0,p=4*(n*l.width+e);const h=65536*a.data[p]+256*a.data[p+1]+a.data[p+2];let g,m,y,x,f,b,w=e,v=n;for(i.push(w),i.push(v);i.length>0;)for(v=i.pop(),w=i.pop(),u=0;u<4;u+=1)m=v+d[u],x=(g=w+s[u])>0&&g<=l.width,f=m>0&&m<=l.height,x&&f&&(p=4*(m*l.width+g),y=65536*a.data[p],y+=256*a.data[p+1],x=(y+=a.data[p+2])!==t,f=y!==o||!r,x&&f&&(b=y===h||r)&&(p=4*(m*l.width+g),a.data[p]=(16711680&t)>>16,a.data[p+1]=(65280&t)>>8,a.data[p+2]=255&t,i.push(g),i.push(m)));c.putImageData(a,0,0)}),e.exports.write=(e=>{u.innerHTML+=e}),e.exports.log=(e=>{d.innerHTML+=e}),e.exports.delete=(()=>{d.innerHTML=d.innerHTML.slice(0,-1)}),e.exports.output=((e,n)=>{u.innerHTML="",u.style.background=p(n)}),e.exports.console=((e,n)=>{d.innerHTML="",d.style.background=p(n)}),e.exports.dump=((e,n)=>{s.innerHTML="memory dump was asked for"});const{hex:p}=t(0),{cursors:h,fonts:g}=t(2);t(1).on("show-settings",r.bind(null,"Settings"))},function(e,n,t){const o=t(10),r=(e,n)=>({index:e,title:n,expressions:o.filter(n=>n.category===e)});e.exports=[r(0,"Turtle: relative movement"),r(1,"Turtle: absolute movement"),r(2,"Turtle: drawing shapes"),r(3,"Other Turtle commands"),r(4,"Canvas operations"),r(5,"General arithmetic functions"),r(6,"Trig / exp / log functions"),r(7,"String operations"),r(8,"Type conversion routines"),r(9,"Input and timing routines"),r(10,"Turtle Machine monitoring")]},function(e,n,t){const o=t(11),r=(e,n,t=!1,o=1)=>({name:e,type:n,byref:t,length:o}),a=e=>({names:{BASIC:e.names[0],Pascal:e.names[1],Python:e.names[2]},code:e.code,parameters:e.parameters||[],returns:e.returns,type:e.returns?"function":"procedure",category:e.category,level:e.level,description:e.description});e.exports=[a({names:["FORWARD","forward","forward"],code:o.fwrd,parameters:[r("n","integer")],category:0,level:0,description:"Moves the Turtle forward <code>n</code> units, drawing as it goes (unless the pen is up)."}),a({names:["BACK","back","back"],code:o.back,parameters:[r("n","integer")],category:0,level:0,description:"Moves the Turtle back <code>n</code> units, drawing as it goes (unless the pen is up)."}),a({names:["LEFT","left","left"],code:o.left,parameters:[r("n","integer")],category:0,level:0,description:"Rotates the Turtle left by <code>n</code> degrees."}),a({names:["RIGHT","right","right"],code:o.rght,parameters:[r("n","integer")],category:0,level:0,description:"Rotates the Turtle right by <code>n</code> degrees."}),a({names:["DRAWXY","drawxy","drawxy"],code:o.drxy,parameters:[r("x","integer"),r("y","integer")],category:0,level:1,description:"Moves the Turtle in a straight line to a point <code>x</code> units away along the x-axis and <code>y</code> units away along the y-axis, drawing as it goes (unless the pen is up)."}),a({names:["MOVEXY","movexy","movexy"],code:o.mvxy,parameters:[r("x","integer"),r("y","integer")],category:0,level:1,description:"Moves the Turtle in a straight line to a point <code>x</code> units away along the x-axis and <code>y</code> units away along the y-axis, <em>without</em> drawing (regardless of the current pen status)."}),a({names:["HOME","home","home"],code:o.home,category:1,level:0,description:"Moves the Turtle back to its starting position in the centre of the canvas, facing north, drawing as it goes (unless the pen is up)."}),a({names:["SETX","setx","setx"],code:o.setx,parameters:[r("x","integer")],category:1,level:0,description:"Sets the Turtle&rsquo;s <code>x</code> coordinate directly (without movement or drawing on the canvas). This can also be achieved by direct assignment of the global variable <code>turtx</code>."}),a({names:["SETY","sety","sety"],code:o.sety,parameters:[r("y","integer")],category:1,level:0,description:"Sets the Turtle&rsquo;s <code>y</code> coordinate directly (without movement or drawing on the canvas). This can also be achieved by direct assignment of the global variable <code>turty</code>."}),a({names:["SETXY","setxy","setxy"],code:o.toxy,parameters:[r("x","integer"),r("y","integer")],category:1,level:0,description:"Sets the Turtle&rsquo;s <code>x</code> and <code>y</code> coordinates directly (without movement or drawing on the canvas). This can also be achieved by direct assingment of the global variables <code>turtx</code> and <code>turty</code>."}),a({names:["DIRECTION","direction","direction"],code:o.setd,parameters:[r("n","integer")],category:1,level:0,description:"Sets the Turtle&rsquo;s direction to <code>n</code> degrees (0 for north, 90 for east, 180 for south, 270 for west). This can also be achieved by direct assignment of the global variable <code>turtd</code>. Note that the number of degrees in a circle (360 by default) can be changed with the <code>angles</code> command."}),a({names:["TURNXY","turnxy","turnxy"],code:o.turn,parameters:[r("x","integer"),r("y","integer")],category:1,level:1,description:"Turns the Turtle to face the point <code>x</code> units away alongthe x-axis and <code>y</code> units away along the y-axis."}),a({names:["CIRCLE","circle","circle"],code:o.circ,parameters:[r("radius","integer")],category:2,level:0,description:"Draws a circle outline in the Turtle&rsquo;s current colour and thickness, of the given <code>radius</code>, centred on the Turtle&rsquo;s current location."}),a({names:["BLOT","blot","blot"],code:o.blot,parameters:[r("radius","integer")],category:2,level:0,description:"Draws a filled circle in the Turtle&rsquo;s current colour, of the given <code>radius</code>, centred on the Turtle&rsquo;s current location."}),a({names:["ELLIPSE","ellipse","ellipse"],code:o.elps,parameters:[r("Xradius","integer"),r("Yradius","integer")],category:2,level:0,description:"Draws an ellipse outline in the Turtle&rsquo;s current colour and thickness, of the given <code>Xradius</code> and <code>Yradius</code>, centred on the Turtle&rsquo;s current location."}),a({names:["ELLBLOT","ellblot","ellblot"],code:o.eblt,parameters:[r("Xradius","integer"),r("Yradius","integer")],category:2,level:0,description:"Draws a filled ellipse in the Turtle&rsquo;s current colour, of the given <code>Xradius</code> and <code>Yradius</code>, centred on the Turtle&rsquo;s current location."}),a({names:["POLYLINE","polyline","polyline"],code:o.poly,parameters:[r("n","integer")],category:2,level:1,description:"Draws a polygon outline in the Turtle&rsquo;s current colour and thickness, connecting the last <code>n</code> locations that the Turtle has visited."}),a({names:["POLYGON","polygon","polygon"],code:o.pfil,parameters:[r("n","integer")],category:2,level:1,description:"Draws a filled polygon in the Turtle&rsquo;s current colour and thickness, connecting the last <code>n</code> locations that the Turtle has visited."}),a({names:["FORGET","forget","forget"],code:o.frgt,parameters:[r("n","integer")],category:2,level:1,description:"Makes the Turtle &ldquo;forget&rdquo; the last <code>n</code> points it has visited. Used in conjunction with <code>polyline</code> and <code>polygon</code>."}),a({names:["REMEMBER","remember","remember"],code:o.rmbr,category:2,level:1,description:"Makes the Turtle &ldquo;remember&rdquo; its current location. This is only necessary if its current location was set by a direct assignment of the global variables <code>turtx</code> and <code>turty</code>; when using the standard moving commands, the Turtle automatically remembers where it has been."}),a({names:["BOX","box","box"],code:o.box,parameters:[r("x","integer"),r("y","integer"),r("colour","integer"),r("border","boolean")],category:2,level:1,description:"Draws a box of width <code>x</code> and height <code>y</code>, with the top left corner in the Turtle&rsquo;s current location, filled with the specified <code>colour</code>. If <code>border</code> is <code>true</code>, a border is drawn around the box in the Turtle&rsquo;s current colour and and thickness. This is intended to be used with the <code>print</code> command, to provide a box for framing text."}),a({names:["COLOUR","colour","colour"],code:o.colr,parameters:[r("colour","integer")],category:3,level:0,description:"Sets the <code>colour</code> of the Turtle&rsquo;s pen. Takes as an argument either an RGB value, or one of the Turtle System&rsquo;s fifty predefined colour constants (see the <b>Colours</b> tab). This can also be achieved by direct assignment of the global variable <code>turtc</code>."}),a({names:["RNDCOL","randcol","randcol"],code:o.rndc,parameters:[r("n","integer")],category:3,level:0,description:"Assigns a random colour to the Turte&rsquo;s pen, between 1 and <code>n</code> (maximum 50). The colours are taken from the Turtle System&rsquo;s fifty predefined colours, which are each assigned a number between 1 and 50 (see the <b>Colours</b> tab)."}),a({names:["THICKNESS","thickness","thickness"],code:o.thik,parameters:[r("thickness","integer")],category:3,level:0,description:"Sets the <code>thickness</code> of the Turtle&rsquo;s pen (for line drawing, and outlines of circles, ellipses, boxes, and polygons). This can also be achieved by direct assignment of the global variable <code>turtt</code>."}),a({names:["PENUP","penup","penup"],code:o.pnup,category:3,level:0,description:"Lifts the Turtle&rsquo;s pen, so that subsequent movement will not draw a line on the Canvas."}),a({names:["PENDOWN","pendown","pendown"],code:o.pndn,category:3,level:0,description:"Lowers the Turtle&rsquo;s pen, so that subsequent movement will draw a line on the Canvas."}),a({names:["OUTPUT","output","output"],code:o.outp,parameters:[r("clear","boolean"),r("colour","integer"),r("tofront","boolean")],category:3,level:1,description:"Modifies the textual output. If the first argument is <code>true</code>, it clears any existing text. The second argument specifies the background colour, and the third argument is for switching the display. If the third argument is <code>true</code>, it switches to the <b>Output</b> tab, while if it is <code>false</code>, it switches to the <b>Canvas and Console</b> tab."}),a({names:["CONSOLE","console","console"],code:o.cons,parameters:[r("clear","boolean"),r("colour","integer")],category:3,level:1,description:"Modifies the Console; if the first argument is <code>true</code>, it clears any existing text, while the second argument specifies the background colour."}),a({names:["RGB","rgb","rgb"],code:o.rgb,parameters:[r("colour","integer")],returns:"integer",category:3,level:2,description:"Returns the RGB value of the input <code>colour</code> (an integer between 1 and 50). For example, <code>rgb(red)=255</code>."}),a({names:["MIXCOLS","mixcols","mixcols"],code:o.mixc,parameters:[r("colour1","integer"),r("colour1","integer"),r("proportion1","integer"),r("proportion2","integer")],returns:"integer",category:3,level:2,description:"Mixes the given colours in the given proportions."}),a({names:["NEWTURTLE","newturtle","newturtle"],code:o.newt,parameters:[r("array","integer",!0,5)],category:3,level:2,description:"Points the Turtle to a custom array in memory (this must be an array of five integers, corresponding to the Turtle&rsquo;s five properties, <code>turtx</code>, <code>turty</code>, <code>turtd</code>, <code>turtt</code>, and <code>turtc</code>). Use repeatedly to simulate multiple Turtles."}),a({names:["OLDTURTLE","oldturtle","oldturtle"],code:o.oldt,category:3,level:2,description:"Points the Turtle back to the default (built-in) array in memory. Use in conjunction with <code>newturtle</code>."}),a({names:["UPDATE","update","update"],code:o.udat,category:4,level:0,description:"Makes the Machine update the Canvas, and continue updating with all subsequent drawing commands. Used in conjunction with <em>noupdate</em>."}),a({names:["NOUPDATE","noupdate","noupdate"],code:o.ndat,category:4,level:0,description:"Makes the Machine refrain from updating the Canvas when executing all subsequent drawing commands, until <em>update</em> is called. Use this to create smooth animations, by queueing up several drawing commands to execute simultaneously."}),a({names:["BLANK","blank","blank"],code:o.blnk,parameters:[r("colour","integer")],category:4,level:0,description:"Blanks the entire Canvas with the specified <code>colour</code>."}),a({names:["CANVAS","canvas","canvas"],code:o.canv,parameters:[r("x1","integer"),r("y1","integer"),r("x2","integer"),r("y2","integer")],category:4,level:1,description:"Sets the top left Canvas coordinate to <code>(x1,y1)</code>, and the Canvas width and height to <code>x2</code> and <code>y2</code> respectively. Note that the width and height fix the number of virtual points on the Canvas, not the number of actual pixels."}),a({names:["RESOLUTION","resolution","resolution"],code:o.reso,parameters:[r("x","integer"),r("y","integer")],category:4,level:1,description:"Sets the Canvas resolution, i.e. the number of actual pixels in the <code>x</code> and <code>y</code> dimensions. To be used in conjunction with the <code>canvas</code> command, typically to set the number of actual pixels equal to the number of virtual points on the Canvas."}),a({names:["ANGLES","angles","angles"],code:o.angl,parameters:[r("degrees","integer")],category:4,level:1,description:"Sets the number of <code>degrees</code> in a circle (360 by default)."}),a({names:["PIXSET","pixset","pixset"],code:o.pixs,parameters:[r("x","integer"),r("y","integer"),r("colour","integer")],category:4,level:2,description:"Sets the <code>colour</code> at point <code>(x,y)</code>."}),a({names:["PIXCOL","pixcol","pixcol"],code:o.pixc,parameters:[r("x","integer"),r("y","integer")],returns:"integer",category:4,level:2,description:"Returns the RGB value of the colour at point <code>(x,y)</code>."}),a({names:["RECOLOUR","recolour","recolour"],code:o.rcol,parameters:[r("x","integer"),r("y","integer"),r("colour","integer")],category:4,level:2,description:"Floods the Canvas with the specified <code>colour</code>, starting at point <code>(x,y)</code>, until reaching any different colour."}),a({names:["FILL","fill","fill"],code:o.fill,parameters:[r("x","integer"),r("y","integer"),r("colour","integer"),r("boundary","integer")],category:4,level:2,description:"Floods the Canvas with the specified <code>colour</code>, starting at point <code>(x,y)</code>, until reaching the <code>boundary</code> colour."}),a({names:["INC","inc","inc"],code:o.incr,parameters:[r("variable","integer",!0)],category:5,level:0,description:"Increments the specified <code>variable</code> by 1."}),a({names:["DEC","dec","dec"],code:o.decr,parameters:[r("variable","integer",!0)],category:5,level:0,description:"Decrements the specified <code>variable</code> by 1."}),a({names:["ABS","abs","abs"],code:o.abs,parameters:[r("n","integer")],returns:"integer",category:5,level:0,description:"Returns the absolute value of <code>n</code>, i.e. <code>n</code> if positive, <code>-n</code> if negative."}),a({names:["SIGN","sign","sign"],code:o.sign,parameters:[r("a","integer")],returns:"integer",category:5,level:1,description:"Returns <code>+1</code> if <code>a</code> is positive, <code>-1</code> if <code>a</code> is negative, and <code>0</code> otherwise."}),a({names:["MAX","max","max"],code:o.maxi,parameters:[r("a","integer"),r("b","integer")],returns:"integer",category:5,level:1,description:"Returns the maximum of <code>a</code> and <code>b</code>."}),a({names:["MIN","min","min"],code:o.mini,parameters:[r("a","integer"),r("b","integer")],returns:"integer",category:5,level:1,description:"Returns the minimum of <code>a</code> and <code>b</code>."}),a({names:["SQR","sqrt","sqrt"],code:o.sqrt,parameters:[r("a","integer"),r("mult","integer")],returns:"integer",category:5,level:1,description:"Returns <code>&radic;a</code>, multiplied by <code>mult</code> and rounded to the nearest integer. Use the multiplier to approximate real numbers."}),a({names:["HYPOT","hypot","hypot"],code:o.hyp,parameters:[r("a","integer"),r("b","integer"),r("mult","integer")],returns:"integer",category:5,level:1,description:"Returns <code>&radic;(a<sup>2</sup>+b<sup>2</sup>)</code>, multiplied by <code>mult</code> and rounded to the nearest integer. Use the multiplier to approximate real numbers."}),a({names:["RND",null,null],code:o.rand,parameters:[r("n","integer")],returns:"integer",category:5,level:1,description:"Returns a random integer between 1 and <code>n</code>."}),a({names:[null,"random",null],code:o.rand,parameters:[r("n","integer")],returns:"integer",category:5,level:1,description:"Returns a random non-negative integer less than <code>n</code>."}),a({names:[null,null,"randint"],code:o.rand,parameters:[r("a","integer"),r("b","integer")],returns:"integer",category:5,level:1,description:"Returns a random integer between <code>a</code> and <code>b</code>."}),a({names:["POWER","power","power"],code:o.powr,parameters:[r("a","integer"),r("b","integer"),r("c","integer"),r("mult","integer")],returns:"integer",category:5,level:2,description:"Returns <code>(a/b)<sup>c</sup></code>, multiplied by <code>mult</code> and rounded to the nearest integer. Use the multiplier to approximate real numbers."}),a({names:["ROOT","root","root"],code:o.root,parameters:[r("a","integer"),r("b","integer"),r("c","integer"),r("mult","integer")],returns:"integer",category:5,level:2,description:"Returns <code><sup>c</sup>&radic;(a/b)</code>, multiplied by <code>mult</code> and rounded to the nearest integer. Use the multiplier to approximate real numbers."}),a({names:["DIVMULT","divmult","divmult"],code:o.divm,parameters:[r("a","integer"),r("b","integer"),r("mult","integer")],returns:"integer",category:5,level:2,description:"Returns <code>a/b</code>, multiplied by <code>mult</code> and rounded to the nearest integer. Use the multiplier to approximate real numbers."}),a({names:["MAXINT","maxint","maxint"],code:o.mxin,returns:"integer",category:5,level:2,description:"Returns the maximum integer that the Machine can deal with (2<sup>31</sup>-1)."}),a({names:["SIN","sin","sin"],code:o.sin,parameters:[r("a","integer"),r("b","integer"),r("mult","integer")],returns:"integer",category:6,level:1,description:"Returns <code>sin(a/b)</code>, multiplied by <code>mult</code> and rounded to the nearest integer. Use the multiplier to approximate real numbers."}),a({names:["COS","cos","cos"],code:o.cos,parameters:[r("a","integer"),r("b","integer"),r("mult","integer")],returns:"integer",category:6,level:1,description:"Returns <code>cos(a/b)</code>, multiplied by <code>mult</code> and rounded to the nearest integer. Use the multiplier to approximate real numbers."}),a({names:["TAN","tan","tan"],code:o.tan,parameters:[r("a","integer"),r("b","integer"),r("mult","integer")],returns:"integer",category:6,level:1,description:"Returns <code>tan(a/b)</code>, multiplied by <code>mult</code> and rounded to the nearest integer. Use the multiplier to approximate real numbers."}),a({names:["PI","pi","pi"],code:o.pi,parameters:[r("mult","integer")],returns:"integer",category:6,level:1,description:"Returns the value of Pi, multiplied by <code>mult</code> and rounded to the nearest integer. Use the multiplier to approximate real numbers."}),a({names:["EXP","exp","exp"],code:o.exp,parameters:[r("a","integer"),r("b","integer"),r("mult","integer")],returns:"integer",category:6,level:1,description:"Returns <code>a<sup>b</sup></code>, multiplied by <code>mult</code> and rounded to the nearest integer. Use the multiplier to approximate real numbers."}),a({names:["LN","ln","ln"],code:o.ln,parameters:[r("a","integer"),r("b","integer"),r("mult","integer")],returns:"integer",category:6,level:1,description:"Returns <code>ln(a/b)</code>, multiplied by <code>mult</code> and rounded to the nearest integer. Use the multiplier to approximate real numbers."}),a({names:["ANTILOG","antilog","antilog"],code:o.alog,parameters:[r("a","integer"),r("b","integer"),r("mult","integer")],returns:"integer",category:6,level:2,description:"Returns <code>antilog<sub>10</sub>(a/b)</code> - i.e. <code>10<sup>a/b</sub></code> - multiplied by <code>mult</code> and rounded to the nearest integer. Use the multiplier to approximate real numbers."}),a({names:["LOG10","log10","log10"],code:o.log,parameters:[r("a","integer"),r("b","integer"),r("mult","integer")],returns:"integer",category:6,level:2,description:"Returns <code>log<sub>10</sub>(a/b)</code>, multiplied by <code>mult</code> and rounded to the nearest integer. Use the multiplier to approximate real numbers."}),a({names:["ASN","arcsin","asin"],code:o.asin,parameters:[r("a","integer"),r("b","integer"),r("mult","integer")],returns:"integer",category:6,level:2,description:"Returns <code>arcsin(a/b)</code>, multiplied by <code>mult</code> and rounded to the nearest integer. Use the multiplier to approximate real numbers."}),a({names:["ACS","arccos","acos"],code:o.acos,parameters:[r("a","integer"),r("b","integer"),r("mult","integer")],returns:"integer",category:6,level:2,description:"Returns <code>arccos(a/b)</code>, multiplied by <code>mult</code> and rounded to the nearest integer. Use the multiplier to approximate real numbers."}),a({names:["ATN","arctan","atan"],code:o.atan,parameters:[r("a","integer"),r("b","integer"),r("mult","integer")],returns:"integer",category:6,level:2,description:"Returns <code>arctan(a/b)</code>, multiplied by <code>mult</code> and rounded to the nearest integer. Use the multiplier to approximate real numbers."}),a({names:["WRITE","write","write"],code:o.text,parameters:[r("string","string")],category:7,level:0,description:"Writes the input <code>string</code> to the console and textual output area of the System."}),a({names:["WRITELN","writeln","writeline"],code:o.texl,parameters:[r("string","string")],category:7,level:0,description:"Writes the input <code>string</code> to the console and textual output area of the System, followed by a line break."}),a({names:["PRINT","print","print"],code:o.prnt,parameters:[r("string","string"),r("font","integer"),r("size","integer")],category:7,level:0,description:"Prints the input <code>string</code> in the Turtle&rsquo;s current colour and at the Turtle&rsquo;s current location, in the specified <code>font</code> and <code>size</code>. Can be used in conjunction with the <code>box</code> drawing command. For a list of available fonts, see the <b>Constants</b> tab."}),a({names:["UCASE$","uppercase","upper"],code:o.uppc,parameters:[r("string","string")],returns:"string",category:7,level:1,description:"Returns the input <code>string</code> as all uppercase."}),a({names:["LCASE$","lowercase","lower"],code:o.lowc,parameters:[r("string","string")],returns:"string",category:7,level:1,description:"Returns the input <code>string</code> as all lowercase."}),a({names:["LEN","length","len"],code:o.slen,parameters:[r("string","string")],returns:"integer",category:7,level:1,description:"Returns the length of the input <code>string</code> (i.e. the number of characters)."}),a({names:["DEL$","delete",null],code:o.dels,parameters:[r("string","string"),r("index","integer"),r("length","integer")],returns:"string",category:7,level:2,description:"Returns the input <code>string</code> with some characters removed, starting at the given <code>index</code> and of the specified <code>length</code>."}),a({names:["LEFT$",null,null],code:o.lefs,parameters:[r("string","string"),r("length","integer")],returns:"string",category:7,level:2,description:"Returns a copy of the characters in the input <code>string</code>, starting on the left and of the specified <code>length</code>."}),a({names:["MID$","copy","copy"],code:o.copy,parameters:[r("string","string"),r("index","integer"),r("length","integer")],returns:"string",category:7,level:2,description:"Returns a copy of the characters in the input <code>string</code>, starting at the given <code>index</code> and of the specified <code>length</code>."}),a({names:["RIGHT$",null,null],code:o.rgts,parameters:[r("string","string"),r("length","integer")],returns:"string",category:7,level:2,description:"Returns a copy of the characters in the input <code>string</code>, starting on the right and of the specified <code>length</code>."}),a({names:["INS$",null,"insert"],code:o.inss,parameters:[r("string","string"),r("index","integer"),r("substr","string")],returns:"string",category:7,level:2,description:"Returns the input <code>string</code> with the specified <code>substring</code> inserted at the given <code>index</code>."}),a({names:[null,"insert",null],code:o.inss,parameters:[r("substr","string"),r("string","string"),r("index","integer")],returns:"string",category:7,level:2,description:"Returns the input <code>string</code> with the specified <code>substring</code> inserted at the given <code>index</code>."}),a({names:["REPLACE","replace","replace"],code:o.repl,parameters:[r("string","string"),r("substr","string"),r("replace","string"),r("n","integer")],returns:"string",category:7,level:2,description:"Returns the input <code>string</code> with up to <code>n</code> occurences of <code>substring</code> replaced by <code>replace</code>. Set <code>n</code> equal to <code>0</code> to replace every occurence."}),a({names:["INSTR",null,"find"],code:o.poss,parameters:[r("string","string"),r("substr","string")],returns:"integer",category:7,level:2,description:"Searches for the input <code>substring</code> within the given <code>string</code>; returns the index of the first character if found, 0 otherwise."}),a({names:[null,"pos",null],code:o.poss,parameters:[r("substr","string"),r("string","string")],returns:"integer",category:7,level:2,description:"Searches for the input <code>substring</code> within the given <code>string</code>; returns the index of the first character if found, 0 otherwise."}),a({names:["STR$","string","string"],code:o.itos,parameters:[r("n","integer")],returns:"string",category:8,level:0,description:"Returns the integer <code>n</code> as a string, e.g. <code>str(12)='12'</code>."}),a({names:["VAL","val","integer"],code:o.svd0,parameters:[r("string","string")],returns:"integer",category:8,level:0,description:"Returns the input <code>string</code> as an integer, e.g. <code>val('12')=12</code>. Returns <code>0</code> if the string cannot be converted (i.e. if it is not an integer string)."}),a({names:["VALDEF","valdef","intdef"],code:o.sval,parameters:[r("string","string"),r("default","string")],returns:"integer",category:8,level:0,description:"Returns the input <code>string</code> as an integer, e.g. <code>val('12')=12</code>. Returns the specified <code>default</code> value if the string cannot be converted (i.e. if it is not an integer string)."}),a({names:["QSTR$","qstr","qstr"],code:o.qtos,parameters:[r("a","integer"),r("b","integer"),r("decplaces","integer")],returns:"string",category:8,level:1,description:"Returns the value of <code>a/b</code> to the specified number of decimal places, as a decimal string, e.g. <code>qstr(2,3,4)='0.6667'</code>."}),a({names:["QVAL","qval","qval"],code:o.qval,parameters:[r("string","string"),r("mult","integer"),r("default","integer")],returns:"integer",category:8,level:1,description:"Returns the input decimal <code>string</code> as an integer, multiplied by <code>mult</code> and rounded to the nearest integer, e.g. <code>qval('1.5',10)=15</code>. Returns the specified <code>default</code> value if the string cannot be converted (i.e. if it is not a decimal string)."}),a({names:["CHR$","chr","chr"],code:o.null,parameters:[r("n","integer")],returns:"char",category:8,level:2,description:"Returns the character with ASCII character code <code>n</code>, e.g. <code>chr(65)='A'</code>."}),a({names:["ASC","ord","ord"],code:o.null,parameters:[r("char","char")],returns:"integer",category:8,level:2,description:"Returns the ASCII code of the input character <code>char</code> (which must be a string of length 1), e.g. <code>ord('A')=65</code>."}),a({names:["BOOLINT","boolint",null],code:o.null,parameters:[r("boolean","boolean")],returns:"integer",category:8,level:2,description:"Returns the input <code>boolean</code> as an integer (-1 for <code>true</code>, 0 for <code>false</code>)."}),a({names:[null,null,"boolint"],code:o.bool,parameters:[r("boolean","boolean")],returns:"integer",category:8,level:2,description:"Returns the input <code>boolean</code> as an integer (1 for <code>true</code>, 0 for <code>false</code>)."}),a({names:["HEX$","hexstr","hex"],code:o.hexs,parameters:[r("n","integer"),r("minlength","integer")],category:8,level:2,description:"Returns a string representation of integer <code>n</code> in hexadecimal format, padded with leading zeros as up to <code>minlength</code>, e.g. <code>hexstr(255,6)='0000FF'</code>."}),a({names:["PAUSE","pause","pause"],code:o.wait,parameters:[r("m","integer")],category:9,level:0,description:"Makes the Turtle Machine wait <code>m</code> milliseconds before performing the next operation. This is useful for controlling the speed of animations."}),a({names:["GETLINE$","readln","readline"],code:o.rdln,returns:"string",category:9,level:0,description:"Waits for the RETURN key to be pressed, then returns everything in the keybuffer up to (and not including) the new line character."}),a({names:["INPUT$",null,"input"],code:o.ilin,parameters:[r("prompt","string")],returns:"string",category:9,level:0,description:"Gives an input prompt, then returns the input when the RETURN key is pressed (using the keybuffer)."}),a({names:["CURSOR","cursor","cursor"],code:o.curs,parameters:[r("cursorcode","integer")],category:9,level:1,description:"Sets which cursor to display (1-15) when the mouse pointer is over the canvas. 0 hides the cursor; any value outside the range 0-15 resets the default cursor. For a list of available cursors, see the <b>Cursors</b> tab."}),a({names:["KEYECHO","keyecho","keyecho"],code:o.kech,parameters:[r("on","boolean")],category:9,level:1,description:"Turns the keyboard echo to the console on (<code>true</code>) or off (<code>false</code>)."}),a({names:["DETECT","detect","detect"],code:o.tdet,parameters:[r("keycode","integer"),r("m","integer")],returns:"boolean",category:9,level:1,description:"Waits a maximum of <code>m</code> milliseconds for the key with the specified <code>keycode</code> to be pressed; returns <code>true</code> if pressed (and stops waiting), <code>false</code> otherwise."}),a({names:["GET$","read","read"],code:o.read,parameters:[r("n","integer")],returns:"string",category:9,level:1,description:"Returns the first <code>n</code> characters from the keybuffer as a string."}),a({names:["TIME","time","time"],code:o.time,returns:"integer",category:9,level:1,description:"Returns the time (in milliseconds) since the program began."}),a({names:["TIMESET","timeset","timeset"],code:o.tset,parameters:[r("m","integer")],category:9,level:1,description:"Artificially sets the time since the program began to <code>m</code> milliseconds."}),a({names:["RESET","reset","reset"],code:o.iclr,parameters:[r("?input","integer")],category:9,level:2,description:"Resets the specified <code>?input</code> (<code>?mousex</code>, <code>?mousey</code>, <code>?click</code>, etc.) to its initial value (i.e. -1)."}),a({names:["KEYSTATUS","keystatus","keystatus"],code:o.inpt,parameters:[r("keycode","integer")],returns:"integer",category:9,level:2,description:"Returns the <code>?kshift</code> value for the most recent press of the key with the specified <code>keycode</code>."}),a({names:["KEYBUFFER","keybuffer","keybuffer"],code:o.bufr,parameters:[r("n","integer")],category:9,level:2,description:"Creates a new custom keybuffer of length <code>n</code>. A keybuffer of length 32 is available by default; use this command if you need a larger buffer."}),a({names:["HALT","halt","halt"],code:o.halt,category:10,level:0,description:"Halts the program."}),a({names:["TRACE","trace","trace"],code:o.trac,parameters:[r("on","boolean")],category:10,level:2,description:"Turns the PCode trace facility on (<code>true</code>) or off (<code>false</code>)."}),a({names:["WATCH","watch","watch"],code:o.memw,parameters:[r("address","integer")],category:10,level:2,description:"Sets an <code>address</code> in memory for the trace facility to watch."}),a({names:["DUMP","dump","dump"],code:o.dump,category:10,level:2,description:"&ldquo;Dumps&rdquo; the current memory state into the display in the memory tab."}),a({names:["HEAPRESET","heapreset","heapreset"],code:o.hrst,category:10,level:2,description:"Resets the memory heap to the initial global value."})]},function(e,n,t){const o=t(12);e.exports=o.filter(e=>void 0!==e).reduce((e,n)=>{const t=e;return t[n.str.toLowerCase()]=n.code,t},{})},function(e,n){const t=(e,n,t)=>({code:e,args:n,str:t});e.exports=[t(0,0,"NULL"),t(1,0,"DUPL"),t(2,0,"SWAP"),t(3,0,"ROTA"),t(4,0,"INCR"),t(5,0,"DECR"),void 0,void 0,t(8,0,"NOT"),t(9,0,"AND"),t(10,0,"OR"),t(11,0,"XOR"),void 0,void 0,void 0,void 0,t(16,0,"NEG"),t(17,0,"ABS"),t(18,0,"SIGN"),t(19,0,"RAND"),void 0,void 0,void 0,void 0,t(24,0,"PLUS"),t(25,0,"SUBT"),t(26,0,"MULT"),t(27,0,"DIVR"),t(28,0,"DIV"),t(29,0,"MOD"),void 0,void 0,t(32,0,"DIVM"),t(33,0,"SQRT"),t(34,0,"HYP"),t(35,0,"ROOT"),t(36,0,"POWR"),t(37,0,"LOG"),t(38,0,"ALOG"),t(39,0,"LN"),t(40,0,"EXP"),t(41,0,"SIN"),t(42,0,"COS"),t(43,0,"TAN"),t(44,0,"ASIN"),t(45,0,"ACOS"),t(46,0,"ATAN"),t(47,0,"PI"),t(48,0,"CTOS"),t(49,0,"ITOS"),t(50,0,"HEXS"),t(51,0,"SVAL"),t(52,0,"QTOS"),t(53,0,"QVAL"),t(54,0,"SCAT"),t(55,0,"SLEN"),t(56,0,"CASE"),t(57,0,"COPY"),t(58,0,"DELS"),t(59,0,"INSS"),t(60,0,"POSS"),t(61,0,"REPL"),void 0,void 0,t(64,0,"EQAL"),t(65,0,"NOEQ"),t(66,0,"LESS"),t(67,0,"MORE"),t(68,0,"LSEQ"),t(69,0,"MREQ"),t(70,0,"MAXI"),t(71,0,"MINI"),t(72,0,"SEQL"),t(73,0,"SNEQ"),t(74,0,"SLES"),t(75,0,"SMOR"),t(76,0,"SLEQ"),t(77,0,"SMEQ"),t(78,0,"SMAX"),t(79,0,"SMIN"),t(80,1,"LDIN"),t(81,1,"LDVG"),t(82,2,"LDVV"),t(83,2,"LDVR"),t(84,1,"LDAG"),t(85,2,"LDAV"),void 0,t(87,-1,"LSTR"),t(88,0,"LDMT"),void 0,void 0,void 0,void 0,void 0,void 0,void 0,t(96,2,"ZERO"),t(97,1,"STVG"),t(98,2,"STVV"),t(99,2,"STVR"),void 0,void 0,void 0,void 0,t(104,0,"STMT"),void 0,void 0,void 0,void 0,void 0,void 0,void 0,t(112,0,"LPTR"),t(113,0,"SPTR"),t(114,0,"CPTR"),t(115,0,"ZPTR"),void 0,void 0,void 0,void 0,t(120,0,"TEST"),t(121,0,"CSTR"),void 0,void 0,void 0,void 0,void 0,void 0,t(128,1,"JUMP"),t(129,1,"IFNO"),t(130,0,"HALT"),void 0,void 0,void 0,void 0,void 0,t(136,1,"SUBR"),t(137,0,"RETN"),void 0,void 0,t(140,1,"PSSR"),t(141,0,"PLSR"),t(142,0,"PSRJ"),t(143,0,"PLRJ"),t(144,2,"MEMC"),t(145,1,"MEMR"),t(146,0,"HFIX"),t(147,0,"HCLR"),t(148,0,"HRST"),void 0,void 0,void 0,t(152,-2,"NEWT"),t(153,-2,"OLDT"),t(154,-2,"RNDC"),t(155,-2,"TEXL"),t(156,-2,"UPPC"),t(157,-2,"LOWC"),t(158,-2,"LEFS"),t(159,-2,"RGTS"),t(160,0,"PNUP"),t(161,0,"PNDN"),t(162,0,"UDAT"),t(163,0,"NDAT"),t(164,0,"KECH"),void 0,t(166,0,"OUTP"),t(167,0,"CONS"),t(168,0,"TRAC"),t(169,0,"MEMW"),t(170,0,"DUMP"),t(171,-2,"SVD0"),t(172,-2,"BOOL"),t(173,-2,"ILIN"),void 0,void 0,t(176,0,"TIME"),t(177,0,"TSET"),t(178,0,"WAIT"),t(179,0,"TDET"),void 0,void 0,void 0,void 0,t(184,0,"INPT"),t(185,0,"ICLR"),t(186,0,"BUFR"),t(187,0,"READ"),t(188,0,"RDLN"),t(189,0,"PRNT"),t(190,0,"TEXT"),t(191,0,"NEWL"),t(192,0,"FDIR"),t(193,0,"OPEN"),t(194,0,"CLOS"),t(195,0,"FPTR"),t(196,0,"FBEG"),t(197,0,"EOF"),t(198,0,"FRDS"),t(199,0,"FRLN"),t(200,0,"FWRS"),t(201,0,"FWNL"),void 0,void 0,void 0,void 0,void 0,void 0,t(208,0,"CANV"),t(209,0,"RESO"),t(210,0,"PIXC"),t(211,0,"PIXS"),t(212,0,"ANGL"),t(213,0,"CURS"),void 0,void 0,t(216,0,"HOME"),t(217,0,"SETX"),t(218,0,"SETY"),t(219,0,"SETD"),t(220,0,"THIK"),t(221,0,"COLR"),t(222,0,"RGB"),t(223,0,"MIXC"),t(224,0,"TOXY"),t(225,0,"MVXY"),t(226,0,"DRXY"),t(227,0,"FWRD"),t(228,0,"BACK"),t(229,0,"LEFT"),t(230,0,"RGHT"),t(231,0,"TURN"),void 0,void 0,void 0,void 0,t(236,0,"RMBR"),t(237,0,"FRGT"),void 0,void 0,t(240,0,"POLY"),t(241,0,"PFIL"),t(242,0,"CIRC"),t(243,0,"BLOT"),t(244,0,"ELPS"),t(245,0,"EBLT"),t(246,0,"BOX"),void 0,t(248,0,"BLNK"),void 0,void 0,void 0,t(252,0,"RCOL"),t(253,0,"FILL"),void 0,t(255,0,"MXIN")]},function(e,n,t){e.exports=((e,n,t)=>{if("null"!==e&&n!==e&&("string"!==e||"char"!==n)&&("boolint"!==e||"boolean"!==n&&"integer"!==n)&&("boolint"!==n||"boolean"!==e&&"integer"!==e))throw o(`Type error: '${e}' expected but '${n}' found.`,t)});const o=t(6)},function(e,n,t){e.exports=((e,n)=>o[n](e));const o={BASIC:t(31),Pascal:t(32),Python:t(33)}},function(e,n,t){const{tabs:o}=t(0),{controls:r,help:a,machine:i,popup:s,program:l,system:c}=t(16),d=t(1),u=document.getElementById("tsx");switch(u.classList.add("tsx"),u.classList.add("tsx-system"),document.body.parentElement.classList.add("tsx-browser"),t(286),document.body.appendChild(s.overlay),u.getAttribute("data-page")){case"about":u.classList.add("tsx-help"),u.appendChild(c),u.appendChild(a.system);break;case"help":u.classList.add("tsx-help"),u.appendChild(c),u.appendChild(a.language);break;default:u.appendChild(o("tsx-top-tabs",[{label:"Program",active:!0,content:[c,l.tabs]},{label:"Machine",active:!1,content:[r,i.tabs]}]))}d.on("error",s.show),d.send("ready")},function(e,n,t){e.exports={controls:t(17),help:t(270),machine:t(8),popup:t(279),program:t(280),system:t(285)}},function(e,n,t){const{element:o}=t(0),r=t(8),a=o("button",{content:"RUN",classes:["tsx-run-halt-button"],on:[{type:"click",callback:()=>{m.send("machine-run-halt",r)}}]}),i=o("button",{content:"&#10074;&#10074;",classes:["tsx-play-pause-button"],on:[{type:"click",callback:()=>{m.send("machine-play-pause")}}]}),s=o("dd",{classes:["tsx-turtxy"],content:"500"}),l=o("dd",{classes:["tsx-turtxy"],content:"500"}),c=o("dd",{classes:["tsx-turtd"],content:"0"}),d=o("dd",{classes:["tsx-turttc"],content:"2"}),u=o("dd",{classes:["tsx-turttc"],style:"background-color:#000;"}),p=o("dl",{classes:["tsx-turtle-properties"],content:[o("dt",{content:"X"}),s,o("dt",{content:"Y"}),l,o("dt",{content:"D"}),c,o("dt",{content:"T"}),d,o("dt",{content:"C"}),u]}),h=o("div",{classes:["tsx-controls"],content:[a,i,p]});e.exports=h;const{hex:g}=t(0),m=t(1);m.on("machine-started",()=>{a.innerHTML="HALT",i.innerHTML="&#10074;&#10074;"}),m.on("machine-stopped",()=>{a.innerHTML="RUN",i.innerHTML="&#10074;&#10074;"}),m.on("machine-played",()=>{i.innerHTML="&#10074;&#10074;"}),m.on("machine-paused",()=>{i.innerHTML="&#9658;"}),m.on("turtx-changed",e=>{s.innerHTML=e.toString(10)}),m.on("turty-changed",e=>{l.innerHTML=e.toString(10)}),m.on("turtd-changed",e=>{c.innerHTML=e.toString(10)}),m.on("turtt-changed",e=>{d.innerHTML=e.toString(10)}),m.on("turtc-changed",e=>{u.style.background=g(e)})},function(e,n,t){const{element:o}=t(0),r=o("div",{content:"settings page"});e.exports=r},function(e,n,t){const{element:o}=t(0),r=o("div",{classes:["tsx-memory"]});e.exports=r},function(e,n,t){const{padded:o}=t(0),r=(e,n,t,r)=>({index:e,names:{BASIC:n.toUpperCase(),Pascal:n,Python:n},type:"integer",value:t,hex:{BASIC:`&${o(t.toString(16))}`,Pascal:`$${o(t.toString(16))}`,Python:`0x${o(t.toString(16))}`},css:`#${o(t.toString(16))}`,dark:r});e.exports=[r(1,"green",2263842,!0),r(2,"red",16711680,!0),r(3,"blue",255,!0),r(4,"yellow",16776960,!1),r(5,"violet",9055202,!0),r(6,"lime",65280,!1),r(7,"orange",16755200,!1),r(8,"skyblue",45311,!1),r(9,"brown",9849600,!0),r(10,"pink",15602313,!0),r(11,"darkgreen",25600,!0),r(12,"darkred",11674146,!0),r(13,"darkblue",128,!0),r(14,"ochre",12628016,!0),r(15,"indigo",4915330,!0),r(16,"olive",8421376,!0),r(17,"orangered",16737792,!0),r(18,"teal",32896,!0),r(19,"darkbrown",6045747,!0),r(20,"magenta",16711935,!0),r(21,"lightgreen",10025880,!1),r(22,"lightred",13458524,!1),r(23,"lightblue",10075135,!1),r(24,"cream",16777147,!1),r(25,"lilac",11572223,!1),r(26,"yellowgreen",11193395,!1),r(27,"peach",16764080,!1),r(28,"cyan",65535,!1),r(29,"lightbrown",11567184,!1),r(30,"lightpink",16758465,!1),r(31,"seagreen",3978097,!1),r(32,"maroon",8388608,!0),r(33,"royal",4286945,!0),r(34,"gold",16762880,!1),r(35,"purple",8388736,!0),r(36,"emerald",51543,!1),r(37,"salmon",16416882,!1),r(38,"turquoise",48833,!1),r(39,"coffee",9596735,!1),r(40,"rose",16746666,!1),r(41,"greengrey",7377008,!0),r(42,"redgrey",11567232,!0),r(43,"bluegrey",8421536,!0),r(44,"yellowgrey",9474160,!0),r(45,"darkgrey",4210752,!0),r(46,"midgrey",8421504,!0),r(47,"lightgrey",10526880,!1),r(48,"silver",12632256,!1),r(49,"white",16777215,!1),r(50,"black",0,!0)]},function(e,n){const t=(e,n,t)=>({index:e,name:n,css:t});e.exports=[t(0,"None","none"),t(1,"Default","default"),t(2,"Pointer","pointer"),t(3,"Crosshair","crosshair"),t(4,"Text","text"),t(5,"Move","move"),t(6,"Resize NESW","nesw-resize"),t(7,"Resize NS","ns-resize"),t(8,"Resize NWSE","nwse-resize"),t(9,"Resize EW","ew-resize"),t(10,"Resize N","n-resize"),t(11,"Wait","wait"),t(12,"Progress","progress"),t(13,"No Drop","no-drop"),t(14,"Forbidden","not-allowed"),t(15,"Help","help")]},function(e,n){const t=(e,n,t)=>({index:e,title:n,examples:t});e.exports.help=[t(1,"Drawing, counting, and procedures/methods",["DrawPause","OlympicRings1","OlympicRings2","ThePlough","ForLoop","Circles","NestedLoops","SimpleProcedure","ColourSpiral","ParameterProcedure","Polygons","YouAreHere"]),t(2,"Further commands and structures",["Stars","PolygonRings","Clock","DigitalClock","CycleColours","Triangles","Flashlights","RefParams","Balls3D","AskInput","StringFunctions","MathFunctions","TrigonometricGraphs"]),t(3,"Smooth movement and interaction",["MovingBall","BouncingBall","TurtleMove","TurtleBounce","MultiBounce","GravitySteps","SolarSystem","SimpleDraw","FiveTurtles"]),t(4,"Complex applications",["PaintApp","SnakeGame","Shoot","Mandelbrot","Quine","NoughtsAndCrosses"]),t(5,"Artificial life and social models",["GameOfLife","Schelling","IteratedPD"])],e.exports.csac=[t(1,"Introduction, Computer Science for Fun, and Turtling",["DrawPause","ColourSpiral"]),t(2,"Animation and Movement",["MovingBall","BouncingBall","TurtleMove","TurtleBounce","AskInput"]),t(3,"Computing in Physics: Cannons and Rockets",["GravitySteps","AimCannon","AutoCannon","Launch"]),t(4,"Cellular Automata: Modelling Disease, 'Life', and Shell Patterns",["LifeStart","Disease","GameOfLife","Automata"]),t(5,"Computing in Chemistry: Diffusion and Brownian Motion",["Diffusion","BrownianMotion"]),t(6,"Computing in Biology: Evolution and Behaviour",["Cheetahs","SexRatio","Flocking"]),t(7,"Chaos and Self-Similarity",["Logistic","LogisticSpider","Mandelbrot","MandelbrotMini","MandelbrotSpectrum","MandelbrotMiniSpectrum","Triangles","Sierpinski","SierpinskiDots","IFSBackground","SierpinskiColour","SierpinskiIFS","BarnsleyIFS","BarnsleyColour","TreeIFS","DragonIFS","DragonColour"]),t(8,"Waves and Quantum Mechanics",["Interference","WaveSuperposer","TwoSlits"]),t(9,"Games and Computer Science",["KnightsTour","Nim","NoughtsAndCrosses"]),t(10,"Philosophy and Social Science",["Schelling","IteratedPD"])],e.exports.names={AimCannon:"Firing a cannon (manual)",AskInput:"Asking for typed input",AutoCannon:"Firing a cannon (automatic)",Automata:"One-dimensional cellular automata",Balls3D:"3D colour effects",BarnsleyColour:"Barnsley colour",BarnsleyIFS:"Barnsley IFS",BouncingBall:"Bouncing ball (using variables)",BrownianMotion:"Brownian motion",Cheetahs:"Cheetahs and gazelles",Circles:"Circling circles",Clock:"Analogue clock (using REPEAT)",ColourSpiral:"Spiral of colours",CycleColours:"Cycling colours (using MOD)",Diffusion:"A model of diffusion",DigitalClock:"Digital clock (using IF and WHILE)",Disease:"Spread of disease",DragonColour:"Dragon colour",DragonIFS:"Dragon IFS",DrawPause:"Simple drawing with pauses",FiveTurtles:"Five turtles moving to the mouse",Flashlights:"Using Booleans",Flocking:"Flocking behaviour",ForLoop:"FOR (counting) loop",GameOfLife:"Conway's Game of Life",GravitySteps:"Movement under gravity",IFSBackground:"Iterated function systems (IFS) background",Interference:"Interference",IteratedPD:"Iterated Prisoner's Dilemma",KnightsTour:"Knight's tour",Launch:"Launching a rocket into orbit",LifeStart:"Initialising Conway's Game of Life",Logistic:"Logistic equation",LogisticSpider:"Logistic spider",Mandelbrot:"Mandelbrot set",MandelbrotMini:"Mandelbrot mini",MandelbrotMiniSpectrum:"Mandelbrot mini spectrum",MandelbrotSpectrum:"Mandelbrot spectrum",MathFunctions:"Mathematical functions",MovingBall:"Moving ball (using variables)",MultiBounce:"Multiple bouncing balls",NestedLoops:"Nested FOR loops",Nim:"Nim",NoughtsAndCrosses:"Noughts and crosses",OlympicRings1:"Olympic rings 1 (using PENUP)",OlympicRings2:"Olympic rings 2 (with variable)",PaintApp:"Painting application",ParameterProcedure:"Procedure with parameter",PolygonRings:"Polygon rings",Polygons:"POLYGON and POLYLINE",Quine:"Quine (self-replicating) program",RefParams:"Reference parameters",Schelling:"Schelling's segregation model",SexRatio:"The sex ratio",Shoot:"Arcade shooting game",Sierpinski:"Sierpinski triangle",SierpinskiColour:"Sierpinski colour",SierpinskiDots:"Sierpinski dots",SierpinskiIFS:"Sierpinski IFS",SimpleDraw:"Drawing to the mouse",SimpleProcedure:"Simple procedure",SnakeGame:"Snake (classic game)",SolarSystem:"Solar system (using ARRAY)",Stars:"Stars (using ANGLES and FORGET)",StringFunctions:"String functions",ThePlough:"The plough constellation",TreeIFS:"Tree IFS",Triangles:"Recursive triangles",TrigonometricGraphs:"Trigonometric graphs",TurtleBounce:"Bouncing ball (using the Turtle)",TurtleMove:"Moving ball (using the Turtle)",TwoSlits:"Young's two-slit experiment",WaveSuperposer:"Wave superposer",YouAreHere:"Text and arrow (using PRINT)"}},function(e,n){const t=(e,n,t)=>({index:e,name:n,css:t});e.exports=[t(0,"Arial","Arial, sans-serif"),t(1,"Arial Black",'"Arial Black", sans-serif'),t(2,"Comic Sans MS",'"Comic Sans MS", cursive, sans-serif'),t(3,"Courier New",'"Courier New", Courier, monospace'),t(4,"Georgia","Georgia, serif"),t(5,"Impact","Impact, Charcoal, sans-serif"),t(6,"Lucida Console",'"Lucida Console", monospace'),t(7,"Lucida Sans Unicode",'"Lucida Sans Unicode", sans-serif'),t(8,"Palatino Linotype",'"Palatino Linotype", "Book Antiqua", Palatino, serif'),t(9,"Symbol","Symbol"),t(10,"Tahoma","Tahoma, Geneva, sans-serif"),t(11,"Times New Roman",'"Times New Roman", Times, serif'),t(12,"Trebuchet MS",'"Trebuchet MS", helvetica, sans-serif'),t(13,"Verdana","Verdana, Geneva, sans-serif"),t(14,"Webdings","Webdings"),t(15,"Wingdings","Wingdings")]},function(e,n){const t=(e,n)=>({names:{BASIC:e.toUpperCase(),Pascal:e,Python:e},value:n});e.exports=[t("?kshift",-10),t("?key",-9),t("?mousey",-8),t("?mousex",-7),t("?clicky",-6),t("?clickx",-5),t("?click",-4),t("?mmouse",-3),t("?rmouse",-2),t("?lmouse",-1),t("\\backspace",8),t("\\tab",9),t("\\enter",13),t("\\shift",16),t("\\ctrl",17),t("\\alt",18),t("\\pause",19),t("\\capslock",20),t("\\escape",27),t("\\space",32),t("\\pgup",33),t("\\pgdn",34),t("\\end",35),t("\\home",36),t("\\left",37),t("\\up",38),t("\\right",39),t("\\down",40),t("\\insert",45),t("\\delete",46),t("\\0",48),t("\\1",49),t("\\2",50),t("\\3",51),t("\\4",52),t("\\5",53),t("\\6",54),t("\\7",55),t("\\8",56),t("\\9",57),t("\\a",65),t("\\b",66),t("\\c",67),t("\\d",68),t("\\e",69),t("\\f",70),t("\\g",71),t("\\h",72),t("\\i",73),t("\\j",74),t("\\k",75),t("\\l",76),t("\\m",77),t("\\n",78),t("\\o",79),t("\\p",80),t("\\q",81),t("\\r",82),t("\\s",83),t("\\t",84),t("\\u",85),t("\\v",86),t("\\w",87),t("\\x",88),t("\\y",89),t("\\z",90),t("\\lwin",91),t("\\rwin",92),t("\\#0",96),t("\\#1",97),t("\\#2",98),t("\\#3",99),t("\\#4",100),t("\\#5",101),t("\\#6",102),t("\\#7",103),t("\\#8",104),t("\\#9",105),t("\\multiply",106),t("\\add",107),t("\\subtract",109),t("\\decimal",110),t("\\divide",111),t("\\f1",112),t("\\f2",113),t("\\f3",114),t("\\f4",115),t("\\f5",116),t("\\f6",117),t("\\f7",118),t("\\f8",119),t("\\f9",120),t("\\f10",121),t("\\f11",122),t("\\f12",123),t("\\numlock",144),t("\\scrolllock",145),t("\\semicolon",186),t("\\equals",187),t("\\comma",188),t("\\dash",189),t("\\fullstop",190),t("\\forwardslash",191),t("\\singlequote",192),t("\\openbracket",219),t("\\backslash",220),t("\\closebracket",221),t("\\hash",222),t("\\backtick",223)]},function(e,n,t){const o=t(9),r=(e,n)=>({names:{BASIC:e[0],Pascal:e[1],Python:e[2]},level:n});e.exports=o.concat({title:"Command structures",expressions:[r(["IF","if","if"],0),r(["ELSE","else","else"],0),r(["FOR","for","for"],0),r(["REPEAT","repeat","repeat"],1),r(["WHILE","while","while"],1),r(["DEF",null,"def"],1),r([null,"procedure",null],1),r([null,"function",null],2)]},{title:"Variable scope modifiers",expressions:[r(["LOCAL",null,null],1),r(["PRIVATE",null,null],2),r([null,null,"global"],1),r([null,null,"nonlocal"],2)]})},function(e,n,t){e.exports=((e,n,t)=>o.concat({title:"Subroutine calls",expressions:n}).map(i.bind(null,t,e)).filter(e=>e.expressions.length>0));const{usage:o}=t(2),r=(e,n)=>` ${n.line.toString(10)}`,a=(e,n)=>e+n.count,i=(e,n,t)=>{const o=t.expressions.filter(((e,n,t)=>{const o=t.name||t.names[e];return n.filter(e=>e.content===o).length>0}).bind(null,e,n)).map(((e,n,t)=>{const o=t.name||t.names[e],a=n.filter(e=>e.content===o);return{name:o,level:t.level+1,count:a.length,lines:a.reduce(r,"").trim()}}).bind(null,e,n));return{title:t.title,expressions:o,total:o.reduce(a,0)}}},function(e,n,t){e.exports=((e,n)=>{const t=r(e,n),s=[],l=["BASIC","Pascal","Python"].indexOf(n);let c=0,d=1,u=!0,p=0;for(;c<t.length;){switch(t[c].type){case"linebreak":d+=1,u=!0,p=0;break;case"spaces":u&&(p=t[c].content.length),u=!1;break;case"comment":u=!1;break;case"unterminated-comment":throw o(a[0],i(t[c],d,p,n));case"unterminated-string":throw o(a[1],i(t[c],d,p,n));case"bad-binary":throw o(a[2+l],i(t[c],d,p,n));case"bad-octal":throw o(a[5+l],i(t[c],d,p,n));case"bad-hexadecimal":throw o(a[8+l],i(t[c],d,p,n));case"bad-decimal":throw o(a[11],i(t[c],d,p,n));case"illegal":throw o(a[12],i(t[c],d,p,n));default:u=!1,s.push(i(t[c],d,p,n))}c+=1}return s});const{error:o}=t(3),r=t(14),a=["Unterminated comment.","Unterminated string.","Binary numbers in Turtle BASIC begin with '%'.","Binary numbers in Turtle Pascal begin with '%'.","Binary numbers in Turtle Python begin with '0b'.","Turtle BASIC does not support octal numbers.","Octal numbers in Turtle Pascal begin with '&'","Octal numbers in Turtle Python begin with '0o'","Hexadecimal numbers in Turtle BASIC begin with '&'","Hexadecimal numbers in Turtle Pascal begin with '$'","Hexadecimal numbers in Turtle Python begin with '0x'","The Turtle System does not support real numbers.","Illegal character in this context."],i=(e,n,t,o)=>({type:s(e.type,e.content),content:"Pascal"===o?e.content.toLowerCase():e.content,value:l(e.type,e.content),line:n,offset:t}),s=(e,n)=>{switch(e){case"binary":case"octal":case"hexadecimal":case"decimal":return"integer";case"command":case"colour":case"custom":case"variable":return"identifier";default:return e}},l=(e,n)=>{switch(e){case"operator":switch(n.toLowerCase()){case"+":return"plus";case"-":return"subt";case"*":return"mult";case"/":return"divr";case"div":case"//":return"div";case"mod":case"%":return"mod";case"=":case"==":return"eqal";case"<>":case"!=":return"noeq";case"<=":return"lseq";case">=":return"mreq";case"<":return"less";case">":return"more";case"not":return"not";case"and":return"and";case"or":return"or";case"xor":case"eor":return"xor";default:return null}case"string":return n.slice(1,-1).replace(/''/g,"'").replace(/\\('|")/g,"$1");case"boolean":return"true"===n.toLowerCase()?-1:0;case"binary":return parseInt(n.slice(1),2);case"octal":return parseInt(n.slice(1),8);case"hexadecimal":return parseInt(n.slice(1),16);case"decimal":return parseInt(n);case"turtle":return["x","y","d","t","c"].indexOf(n[4].toLowerCase())+1;default:return null}}},function(e,n){e.exports.program=((e,n)=>({language:n,name:e,index:0,indent:0,constants:[],variables:[],subroutines:[],lexemes:[],turtleAddress:null,memoryNeeded:null})),e.exports.subroutine=((e,n,t)=>({name:e,type:n,level:-1,index:null,indent:null,globals:[],nonlocals:[],constants:[],parameters:[],variables:[],parent:t,subroutines:[],lexemes:[],memoryNeeded:null})),e.exports.constant=((e,n,t)=>({name:e,type:n,value:t})),e.exports.variable=((e,n,t=!1)=>({name:e.content,lexeme:e,routine:n,byref:t,index:null,fulltype:null,private:null})),e.exports.fulltype=((e,n=null,t=null,o=null)=>"string"===e?{type:e,length:33,start:t,fulltype:o}:{type:e,length:n,start:t,fulltype:o})},function(e,n,t){e.exports.expression=((e,n,t,o,r)=>{const a=["eqal","less","lseq","more","mreq","noeq"];"boolean"===o&&(o="null");let i=c(e,n,t,o,r);for(;e.lexemes[i.lex]&&a.indexOf(e.lexemes[i.lex].value)>-1;){let n=l(e.lexemes[i.lex].value,i.type),t=c(e,i.lex+1,i.type,o,r);i=s.mergeWithOperator(i.pcode,t,n)}return i}),e.exports.variableAssignment=((n,t,o,r)=>{const l=i.variable(n,t,r);if(!l)throw a(`Variable "${t}" is not defined.`,n.lexemes[o]);if(!n.lexemes[o])throw a(`Variable "${t}" must be assigned a value.`,n.lexemes[o-1]);const c=e.exports.expression(n,o,"null",l.fulltype.type,r);return{lex:c.lex,pcode:s.merge(c.pcode,[s.storeVariableValue(l)])}}),e.exports.procedureCall=((e,n,t,o=!0)=>{const r=i.command(e,e.lexemes[n].content,t);if(!r)throw a("{lex} is not defined.",e.lexemes[n]);if(o&&"procedure"!==r.type)throw a("{lex} is a function, not a procedure.",e.lexemes[n]);return 0===r.parameters.length?m(e,n,r,t):y(e,n,r,t)});const o=t(30),r=t(13),a=t(6),i=t(5),s=t(7),l=(e,n)=>{return"string"===n||"char"===n?["seql","sles","sleq","smor","smeq","sneq","scat"][["eqal","less","lseq","more","mreq","noeq","plus"].indexOf(e)]:e},c=(e,n,t,o,r)=>{const a=["plus","subt","or","xor"];let i=d(e,n,t,o,r);for(;e.lexemes[i.lex]&&a.indexOf(e.lexemes[i.lex].value)>-1;){let n=l(e.lexemes[i.lex].value,i.type),t=d(e,i.lex+1,i.type,o,r);i=s.mergeWithOperator(i.pcode,t,n)}return i},d=(e,n,t,o,r)=>{const a=["and","div","divr","mod","mult"];let i=u(e,n,t,o,r);for(;e.lexemes[i.lex]&&a.indexOf(e.lexemes[i.lex].value)>-1;){let n=l(e.lexemes[i.lex].value,i.type),t=u(e,i.lex+1,i.type,o,r);i=s.mergeWithOperator(i.pcode,t,n)}return i},u=(e,n,t,r,i)=>{switch(e.lexemes[n].type){case"operator":return p(e,n,r,i)||(()=>{throw a("{lex} makes no sense here.",e.lexemes[n])})();case"boolean":case"char":case"integer":case"string":return o.literal(e.lexemes,n,r);case"keycode":case"query":return o.input(e.lexemes,n,r,i)||(()=>{throw a("{lex} is not a valid input code.",e.lexemes[n])})();case"turtle":case"identifier":return o.constant(e,n,r,i)||o.variable(e,n,r,i)||o.colour(e,n,r,i)||h(e,n,r,i)||(()=>{throw a("{lex} is not defined.",e.lexemes[n])})();default:return g(e,n,t,r,i)||(()=>{throw a("{lex} makes no sense here.",e.lexemes[n])})()}},p=(e,n,t,o)=>{if("-"===e.lexemes[n].content||"not"===e.lexemes[n].value){const a="-"===e.lexemes[n].content?"integer":"boolint",i="-"===e.lexemes[n].content?[s.applyOperator("neg")]:[s.applyOperator("not")];r(t,"integer",e.lexemes[n]);const l=u(e,n+1,a,t,o);return Object.assign(l,{pcode:s.merge(l.pcode,i)})}return null},h=(n,t,o,l)=>{const c=i.command(n,n.lexemes[t].content,l);if(c){if("function"!==c.type)throw a("{lex} is a procedure, not a function.",n.lexemes[t]);r(o,c.returns,n.lexemes[t]);const i=e.exports.procedureCall(n,t,l,!1);return c.code||i.pcode.push(s.loadFunctionReturnValue(c.resultAddress)),Object.assign(i,{type:c.returns})}return null},g=(n,t,o,r,i)=>{if("("===n.lexemes[t].content){const s=e.exports.expression(n,t+1,o,r,i);if(n.lexemes[s.lex]&&")"===n.lexemes[s.lex].content)return Object.assign(s,{lex:s.lex+1});throw a("Closing bracket missing.",n.lexemes[t-1])}return null},m=(e,n,t,o)=>{if("Python"===o){if(!e.lexemes[n+1]||"("!==e.lexemes[n+1].content)throw a("Opening bracket missing after command {lex}.",e.lexemes[n]);if(!e.lexemes[n+2]||")"!==e.lexemes[n+2].content)throw a("Command {lex} takes no arguments.",e.lexemes[n-1]);return{lex:n+3,pcode:[s.callCommand(t,e,o)]}}if(e.lexemes[n+1]&&"("===e.lexemes[n+1].content)throw a("Command {lex} takes no arguments.",e.lexemes[n]);return{lex:n+1,pcode:[s.callCommand(t,e,o)]}},y=(e,n,t,o)=>{if(!e.lexemes[n+1]||"("!==e.lexemes[n+1].content)throw a("Opening bracket missing after command {lex}.",e.lexemes[n]);const r=x(e,n+2,t,o),i=[s.callCommand(t,e,o)];return Object.assign(r,{pcode:s.merge(r.pcode,i)})},x=(e,n,t,o)=>{const r=t.parameters.length;let i=0,l=[[]];for(;i<r&&")"!==e.lexemes[n].content;){let c=f(e,n,t,i,o);if(i+=1,n=c.lex,l=s.merge(l,c.pcode),i<r){if(!e.lexemes[n]||","!==e.lexemes[n].content)throw a("Comma needed after parameter.",e.lexemes[n]);n+=1}}const c=t.name||t.names[o];if(i<r)throw a(`Not enough arguments given for command "${c}".`,e.lexemes[n]);if(","===e.lexemes[n].content)throw a(`Too many arguments given for command "${c}"`,e.lexemes[n]);if(")"!==e.lexemes[n].content)throw a(`Closing bracket missing after command "${c}"`,e.lexemes[n-1]);return{lex:n+1,pcode:l}},f=(n,t,o,r,l)=>{if(o.parameters[r].byref){let e=i.variable(n,n.lexemes[t].content,l);if(!e)throw a("{lex} is not defined.}",n.lexemes[t]);return{lex:t+1,pcode:[s.loadVariableAddress(e)]}}const c=o.parameters[r].type||o.parameters[r].fulltype.type;return e.exports.expression(n,t,"null",c,l)}},function(e,n,t){e.exports.literal=((e,n,t)=>{const{type:r,value:i}=e[n];return o(t,r,e[n]),"char"===r&&"string"===t?{type:r,lex:n+1,pcode:[a.loadLiteralValue(r,i),a.applyOperator("ctos")]}:{type:r,lex:n+1,pcode:[a.loadLiteralValue(r,i)]}}),e.exports.input=((e,n,t,i)=>{const s=r.input(e[n].content,i);if(s)return o(t,s.type,e[n]),{type:"integer",lex:n+1,pcode:[a.loadInputValue(s)]}}),e.exports.constant=((e,n,t,i)=>{const{lexemes:s}=e,l=r.constant(e,s[n].content,i);if(l)return o(t,l.type,s[n]),{type:l.type,lex:n+1,pcode:[a.loadLiteralValue(l.type,l.value)]}}),e.exports.variable=((e,n,t,i)=>{const{lexemes:s}=e,l=r.variable(e,s[n].content,i);if(l)return o(t,l.fulltype.type,s[n]),{type:l.fulltype.type,lex:n+1,pcode:[a.loadVariableValue(l)]}}),e.exports.colour=((e,n,t,i)=>{const{lexemes:s}=e,l=r.colour(s[n].content,i);if(l)return o(t,"integer",s[n]),{type:"integer",lex:n+1,pcode:[a.loadLiteralValue("integer",l.value)]}});const o=t(13),r=t(5),a=t(7)},function(e,n){e.exports=(e=>{let n=[];for(;e.length>0;){let v=t(e)||o(e)||r(e)||s(e)||a(e)||i(e)||l(e)||c(e)||d(e)||u(e)||p(e)||h(e)||f(e)||g(e)||m(e)||b(e)||y(e)||x(e)||w(e);n.push(v),e=e.slice(v.content.length)}return n});const t=e=>{return!!("\n"===e[0])&&{type:"linebreak",content:"\n"}},o=e=>{const n=e.match(/^( +)/);return!!n&&{type:"spaces",content:n[0]}},r=e=>{return!!e.match(/^REM\b/)&&{type:"comment",content:e.split("\n")[0]}},a=e=>{const n=e.match(/^(\+|-|\*|\/|DIV\b|MOD\b|=|<>|<=|>=|<|>|NOT\b|AND\b|OR\b|EOR\b)/);return!!n&&{type:"operator",content:n[0]}},i=e=>{const n=e.match(/^(\(|\)|,|:)/);return!!n&&{type:"punctuation",content:n[0]}},s=e=>{const n="'"===e[0],t='"'===e[0],o=e.match(/[^\\](')/),r=e.match(/[^\\](")/);return n&&o?{type:"string",content:e.slice(0,o.index+2)}:n?{type:"unterminated-string",content:e.split("\n")[0]}:t&&r?{type:"string",content:e.slice(0,r.index+2)}:!!t&&{type:"unterminated-string",content:e.split("\n")[0]}},l=e=>{const n=e.match(/^(TRUE|FALSE)\b/);return!!n&&{type:"boolean",content:n[0]}},c=e=>{const n=e.match(/^(%[01]+)\b/),t=e.match(/^(0b[01]+)\b/);return n?{type:"binary",content:n[0]}:!!t&&{type:"bad-binary",content:t[0]}},d=e=>{const n=e.match(/^((\$|#|(0x))[A-Fa-f0-9]+)\b/),t=e.match(/^(&[A-Fa-f0-9]+)\b/);return n?{type:"bad-hexadecimal",content:n[0]}:!!t&&{type:"hexadecimal",content:t[0]}},u=e=>{const n=e.match(/^(\d+\.\d+)/),t=e.match(/^(\d+)\b/);return n?{type:"bad-decimal",content:n[0]}:!!t&&{type:"decimal",content:t[0]}},p=e=>{const n=e.match(/^(DEF|DIM|ELSE|END|ENDIF|ENDPROC|ENDWHILE|FOR|IF|LOCAL|NEXT|PRIVATE|REPEAT|RETURN|STEP|THEN|TO|UNTIL|WHILE)\b/);return!!n&&{type:"keyword",content:n[0]}},h=e=>{const n=e.match(/^(ABS\b|ACS\b|ANGLES\b|ANTILOG\b|ASC\b|ASN\b|ATN\b|BACK\b|BLANK\b|BLOT\b|BOOLINT\b|BOX\b|CANVAS\b|CHR\$|CIRCLE\b|COLOU?R\b|CONSOLE\b|COS\b|CURSOR\b|DEC\b|DEL\$|DETECT\b|DIRECTION\b|DIVMULT\b|DRAWXY\b|DUMP\b|ELLBLOT\b|ELLIPSE\b|EXP\b|FILL\b|FORGET\b|FORWARD\b|GET\$|GETLINE\$|HEAPRESET|HEX\$|HOME\b|HYPOT\b|INC\b|INPUT\$|KEYBUFFER\b|KEYECHO\b|KEYSTATUS\b|LCASE\$|LEFT\$|LEFT\b|LEN\b|LN\b|LOG10\b|MAX\b|MAXINT\b|MID\$|MIN\b|MIXCOLS\b|MOVEXY\b|NEWTURTLE\b|NOUPDATE\b|OLDTURTLE\b|OUTPUT\b|PAUSE\b|PENDOWN\b|PENUP\b|PI\b|PIXCOL\b|PIXSET\b|POLYGON\b|POLYLINE\b|POWER\b|PRINT\b|QSTR\$|QVAL\b|RECOLOUR\b|REMEMBER\b|RESET\b|RESOLUTION\b|RGB\b|RIGHT\$|RIGHT\b|RND\b|RNDCOL\b|ROOT\b|SETX\b|SETXY\b|SETY\b|SIGN\b|SIN\b|SQR\b|STR\$|TAN\b|THICKNESS\b|TIME\b|TIMESET\b|TRACE\b|TURNXY\b|UPDATE\b|UCASE\$|VAL\b|VALDEF\b|WATCH\b|WRITE\b|WRITELN\b)/);return!!n&&{type:"command",content:n[0]}},g=e=>{const n=e.match(/^(TURT[XYDTC]%)\b/);return!!n&&{type:"turtle",content:n[0]}},m=e=>{const n=e.match(/^(TRUE|FALSE|GREEN|DARKGREEN|LIGHTGREEN|SEAGREEN|GREENGREY|GREENGRAY|RED|DARKRED|LIGHTRED|MAROON|REDGREY|REDGRAY|BLUE|DARKBLUE|LIGHTBLUE|ROYAL|BLUEGREY|YELLOW|OCHRE|CREAM|GOLD|YELLOWGREY|YELLOWGRAY|VIOLET|INDIGO|LILAC|PURPLE|DARKGREY|DARKGRAY|LIME|OLIVE|YELLOWGREEN|EMERALD|MIDGREY|MIDGRAY|ORANGE|ORANGERED|PEACH|SALMON|LIGHTGREY|LIGHTGRAY|SKYBLUE|TEAL|CYAN|TURQUOISE|SILVER|BROWN|DARKBROWN|LIGHTBROWN|COFFEE|WHITE|PINK|MAGENTA|LIGHTPINK|ROSE|BLACK)\b/);return!!n&&{type:"colour",content:n[0]}},y=e=>{const n=e.match(/^(\\[#A-Z0-9]+)/);return!!n&&{type:"keycode",content:n[0]}},x=e=>{const n=e.match(/^(\?[A-Z]+)\b/);return!!n&&{type:"query",content:n[0]}},f=e=>{const n=e.match(/^((PROC|FN)[_a-zA-Z]+)\b/);return!!n&&{type:"custom",content:n[0]}},b=e=>{const n=e.match(/^([_a-zA-Z0-9]+[$|%])/);return!!n&&{type:"variable",content:n[0]}},w=e=>{const n=e.match(/^\d+/),t="#"===e[0];return n?{type:"unterminated-integer",content:e}:t?{type:"bad-hexadecimal",content:e}:{type:"illegal",content:e.split(/\b/)[0]}}},function(e,n){e.exports=(e=>{const n=[];for(;e.length>0;){let E=t(e)||o(e)||r(e)||a(e)||i(e)||s(e)||l(e)||c(e)||d(e)||u(e)||p(e)||h(e)||g(e)||m(e)||y(e)||x(e)||f(e)||b(e)||w(e)||v(e);n.push(E),e=e.slice(E.content.length)}return n});const t=e=>{return!!("\n"===e[0])&&{type:"linebreak",content:"\n"}},o=e=>{const n=e.match(/^( +)/);return!!n&&{type:"spaces",content:n[0]}},r=e=>{const n="{"===e[0],t=e.match(/}/);return n&&t?{type:"comment",content:e.slice(0,t.index+1)}:!!n&&{type:"unterminated-comment",content:e.split("\n")[0]}},a=e=>{const n=e.match(/^(\+|-|\*|\/|div\b|mod\b|=|<>|<=|>=|<|>|:=|not\b|and\b|or\b|xor\b)/i);return!!n&&{type:"operator",content:n[0]}},i=e=>{const n=e.match(/^(\(|\)|\[|\]|,|:|;|\.\.|\.)/);return!!n&&{type:"punctuation",content:n[0]}},s=e=>{const n="'"===e[0],t='"'===e[0],o=e.match(/[^\\](')/),r=e.match(/[^\\](")/);return n&&o?{type:"string",content:e.slice(0,o.index+2)}:n?{type:"unterminated-string",content:e.split("\n")[0]}:t&&r?{type:"string",content:e.slice(0,r.index+2)}:!!t&&{type:"unterminated-string",content:e.split("\n")[0]}},l=e=>{const n=e.match(/^(true|false)\b/i);return!!n&&{type:"boolean",content:n[0]}},c=e=>{const n=e.match(/^(%[01]+)\b/),t=e.match(/^(0b[01]+)\b/);return n?{type:"binary",content:n[0]}:!!t&&{type:"bad-binary",content:t[0]}},d=e=>{const n=e.match(/^(&[0-7]+)\b/),t=e.match(/^(0o[0-7]+)\b/);return n?{type:"octal",content:n[0]}:!!t&&{type:"bad-octal",content:t[0]}},u=e=>{const n=e.match(/^((&|#|(0x))[A-Fa-f0-9]+)\b/),t=e.match(/^(\$[A-Fa-f0-9]+)\b/);return n?{type:"bad-hexadecimal",content:n[0]}:!!t&&{type:"hexadecimal",content:t[0]}},p=e=>{const n=e.match(/^(\d+\.\d+)/),t=e.match(/^(\d+)\b/);return n?{type:"bad-decimal",content:n[0]}:!!t&&{type:"decimal",content:t[0]}},h=e=>{const n=e.match(/^(begin|const|do|downto|else|end|for|function|if|of|procedure|program|repeat|result|then|to|until|var|while)\b/i);return!!n&&{type:"keyword",content:n[0]}},g=e=>{const n=e.match(/^(array|boolean|char|integer|string)\b/i);return!!n&&{type:"type",content:n[0]}},m=e=>{const n=e.match(/^(abs|angles|antilog|arccos|arcsin|arctan|back|blank|blot|boolint|box|canvas|chr|circle|colou?r|console|copy|cos|cursor|dec|delete|detect|direction|divmult|drawxy|dump|ellblot|ellipse|exp|fill|forget|forward|heapreset|hexstr|home|hypot|inc|insert|keybuffer|keyecho|keystatus|left|length|ln|log10|lowercase|max|maxint|min|mixcols|movexy|newturtle|noupdate|oldturtle|ord|output|pause|pendown|penup|pi|pixcol|pixset|polygon|polyline|pos|power|print|qstr|qval|randcol|random|read|readln|recolour|remember|reset|resolution|rgb|right|root|setx|setxy|sety|sign|sin|sqrt|str|tan|thickness|time|timeset|trace|turnxy|update|uppercase|val|valdef|watch|write|writeln)\b/i);return!!n&&{type:"command",content:n[0]}},y=e=>{const n=e.match(/^(turt[xydtc])\b/i);return!!n&&{type:"turtle",content:n[0]}},x=e=>{const n=e.match(/^(true|false|green|darkgreen|lightgreen|seagreen|greengrey|greengray|red|darkred|lightred|maroon|redgrey|redgray|blue|darkblue|lightblue|royal|bluegrey|yellow|ochre|cream|gold|yellowgrey|yellowgray|violet|indigo|lilac|purple|darkgrey|darkgray|lime|olive|yellowgreen|emerald|midgrey|midgray|orange|orangered|peach|salmon|lightgrey|lightgray|skyblue|teal|cyan|turquoise|silver|brown|darkbrown|lightbrown|coffee|white|pink|magenta|lightpink|rose|black)\b/i);return!!n&&{type:"colour",content:n[0]}},f=e=>{const n=e.match(/^(\\[#a-z0-9]+)/i);return!!n&&{type:"keycode",content:n[0]}},b=e=>{const n=e.match(/^(\?[a-z]+)\b/i);return!!n&&{type:"query",content:n[0]}},w=e=>{const n=e.match(/^([_a-zA-Z][_a-zA-Z0-9]*)\b/);return!!n&&{type:"identifier",content:n[0]}},v=e=>({type:"illegal",content:e.split(/\b/)[0]})},function(e,n){e.exports=(e=>{let n=[];for(;e.length>0;){let v=t(e)||o(e)||r(e)||a(e)||i(e)||s(e)||l(e)||c(e)||d(e)||u(e)||p(e)||h(e)||g(e)||m(e)||y(e)||x(e)||f(e)||b(e)||w(e);n.push(v),e=e.slice(v.content.length)}return n});const t=e=>{return!!("\n"===e[0])&&{type:"linebreak",content:"\n"}},o=e=>{const n=e.match(/^( +)/);return!!n&&{type:"spaces",content:n[0]}},r=e=>{return!!e.match(/^#/)&&{type:"comment",content:e.split("\n")[0]}},a=e=>{const n=e.match(/^(\+|-|\*|\/\/|\/|%|==|!=|<=|>=|=|<|>|not\b|and\b|or\b|xor\b)/);return!!n&&{type:"operator",content:n[0]}},i=e=>{const n=e.match(/^(\(|\)|,|:)/);return!!n&&{type:"punctuation",content:n[0]}},s=e=>{const n="'"===e[0],t='"'===e[0],o=e.match(/[^\\](')/),r=e.match(/[^\\](")/);return n&&o?{type:"string",content:e.slice(0,o.index+2)}:n?{type:"unterminated-string",content:e.split("\n")[0]}:t&&r?{type:"string",content:e.slice(0,r.index+2)}:!!t&&{type:"unterminated-string",content:e.split("\n")[0]}},l=e=>{const n=e.match(/^(true|false)\b/);return!!n&&{type:"boolean",content:n[0]}},c=e=>{const n=e.match(/^(0b[01]+)\b/),t=e.match(/^(%[01]+)\b/);return n?{type:"binary",content:n[0]}:!!t&&{type:"bad-binary",content:t[0]}},d=e=>{const n=e.match(/^(0o[0-7]+)\b/),t=e.match(/^(&[0-7]+)\b/);return n?{type:"octal",content:n[0]}:!!t&&{type:"bad-octal",content:t[0]}},u=e=>{const n=e.match(/^(0x[A-Fa-f0-9]+)\b/),t=e.match(/^((&|#|\$)[A-Fa-f0-9]+)\b/);return n?{type:"hexadecimal",content:n[0]}:!!t&&{type:"bad-hexadecimal",content:t[0]}},p=e=>{const n=e.match(/^(\d+\.\d+)/),t=e.match(/^(\d+)\b/);return n?{type:"bad-decimal",content:n[0]}:!!t&&{type:"decimal",content:t[0]}},h=e=>{const n=e.match(/^(def|else|for|global|if|in|nonlocal|pass|range|return|while)\b/);return!!n&&{type:"keyword",content:n[0]}},g=e=>{const n=e.match(/^(abs|acos|angles|antilog|asin|atan|back|blank|blot|boolint|box|canvas|chr|circle|colou?r|console|copy|cos|cursor|dec|detect|direction|divmult|drawxy|dump|ellblot|ellipse|exp|fill|find|forget|forward|heapreset|hex|home|hypot|inc|input|insert|int|intdef|keybuffer|keyecho|keystatus|left|len|ln|log10|lower|max|maxint|min|mixcols|movexy|newturtle|noupdate|oldturtle|ord|output|pause|pendown|penup|pi|pixcol|pixset|polygon|polyline|power|print|qstr|qval|randcol|randint|read|readline|recolour|remember|reset|resolution|rgb|right|root|setx|setxy|sety|sign|sin|sqrt|str|tan|thickness|time|timeset|trace|turnxy|update|upper|watch|write|writeline)\b/);return!!n&&{type:"command",content:n[0]}},m=e=>{const n=e.match(/^(turt[xydtc])\b/);return!!n&&{type:"turtle",content:n[0]}},y=e=>{const n=e.match(/^(green|darkgreen|lightgreen|seagreen|greengrey|greengray|red|darkred|lightred|maroon|redgrey|redgray|blue|darkblue|lightblue|royal|bluegrey|yellow|ochre|cream|gold|yellowgrey|yellowgray|violet|indigo|lilac|purple|darkgrey|darkgray|lime|olive|yellowgreen|emerald|midgrey|midgray|orange|orangered|peach|salmon|lightgrey|lightgray|skyblue|teal|cyan|turquoise|silver|brown|darkbrown|lightbrown|coffee|white|pink|magenta|lightpink|rose|black)\b/);return!!n&&{type:"colour",content:n[0]}},x=e=>{const n=e.match(/^(\\[#a-z0-9]+)/i);return!!n&&{type:"keycode",content:n[0]}},f=e=>{const n=e.match(/^(\?[a-z]+)\b/);return!!n&&{type:"query",content:n[0]}},b=e=>{const n=e.match(/^([_a-zA-Z][_a-zA-Z0-9]*)\b/);return!!n&&{type:"identifier",content:n[0]}},w=e=>({type:"illegal",content:e.split(/\b/)[0]})},function(e,n,t){e.exports=((e,n)=>{const t=s[n](e),r=t[0],a=t.slice(1);if("Python"===n){l(t,0),t.length>1&&c(t,t.length-1);const e=d(t);if(e)throw o("Could not detetermine type of variable {lex}.",e.lexeme)}return t.forEach(u),r.turtleAddress=p(a),t});const{error:o,molecules:r,factory:a,find:i}=t(3),s={BASIC:t(35),Pascal:t(36),Python:t(37)},l=(e,n)=>{for(var t,o,s=e[n],c=s.lexemes,d=0;d<c.length;)if("identifier"===c[d].type)if((t=i.variable(s,c[d].content,"Python"))&&null===t.fulltype){if(c[d+=1]&&"in"===c[d].content)t.fulltype=a.fulltype("integer"),d+=1;else if(c[d]&&"="===c[d].content&&c[d+=1])try{o=r.expression(s,d,"null","null","Python"),t.fulltype=a.fulltype(o.type),d=o.lex}catch(e){d+=1}}else d+=1;else if("return"===c[d].content){if(t=i.variable(s,"return","Python"),c[d+=1])try{o=r.expression(s,d,"null","null","Python"),t.fulltype=a.fulltype(o.type),d=o.lex}catch(e){d+=1}}else d+=1;return 0===n?1===e.length?e:l(e,e.length-1):n>1?l(e,n-1):e},c=function(e,n){for(var t,o,s,l=e[n],d=l.lexemes,u=0;u<d.length;){if("identifier"===d[u].type&&(t=i.custom(l,d[u].content,"Python"))&&t.parameters.length>0)for(o=0,u+=2;o<t.parameters.length;){try{s=r.expression(l,u,"null","null","Python"),null===t.parameters[o].fulltype&&(t.parameters[o].fulltype=a.fulltype(s.type)),u=s.lex+1}catch(e){}o+=1}u+=1}return 1===n?e:c(e,n-1)},d=e=>{return e.reduce((e,n)=>e.concat(n.variables),[]).find(e=>null===e.fulltype)},u=e=>{let n=0;e.variables.forEach(e=>{n+=1,e.index=n,e.fulltype&&null!==e.fulltype.length&&(n+=e.fulltype.length)}),e.memoryNeeded=n},p=e=>10+(e=>e.some(e=>"function"===e.type)?e.length+1:e.length)(e)},function(e,n,t){const{factory:o}=t(3),r=(e,n)=>({type:"Compiler",message:((e,n)=>{switch(e){case"progDef":return'Subroutines must be defined after program "END".';case"progNoDim":return"The online compiler does not support arrays. Please compile your program in the downloadable system.";case"progDim":return'"DIM" commands must occur at the top of the program.';case"progPrivate":return"Private variables cannot be defined in the main program.";case"progLocal":return"Local variables cannot be defined in the main program.";case"progAfter":return'No program text can appear after program "END" (except subroutine definitions).';case"progNoEnd":return'Program must finish with "END".';case"subName":return'"DEF" must be followed by a valid procedure or function name. (Procedure names must begin with "PROC", and function names must begin with "FN".)';case"subBadName":return"";case"subDim":return'"DIM" commands can only occur within the main program. To declare a local or private array, use "LOCAL" or "PRIVATE" instead.';case"subEmpty":return"Subroutine definition must be followed by some commands.";case"subPrivate":return"Private variables must be declared at the start of the subroutine.";case"subLocal":return"Local variables must be declared at the start of the subroutine.";case"subDef":return'The next subroutine must be defined after subroutine "ENDPROC".';case"subEndFn":return'Function must end with "=&lt;expression&gt;", not "ENDPROC".';case"subEndProc":return'Procedure must end with "ENDPROC", not "=&lt;expression&gt;".';case"subEmptyResult":return'"=" must be followed by a return value.';case"subAfter":return"No program text can appear after subroutine end (except further subroutine definitions).";case"subNoEndProc":return'Procedure must finish with "ENDPROC".';case"subNoEndFunc":return'Function must finish with "=&lt;expression$gt;".';case"parName":return"Parameter name expected.";case"parTurtle":return`"${n.content}" is the name of a Turtle property, and cannot be used as a parameter name.`;case"parId":return`"${n.content}" is not a valid parameter name. Integer parameters must end with "%", and string parameters must end with "$".`;case"parDupl":return`"${n.content}" is already a parameter for this subroutine.`;case"parBracket":return"Closing bracket needed after parameters.";case"parComma":return"Comma needed after parameter.";case"varName":return"Variable name expected.";case"varTurtle":return`"${n.content}" is the name of a Turtle property, and cannot be used as a variable name.`;case"varId":return`"${n.content}" is not a valid variable name. Integer variables must end with "%", and string variables must end with "$".`;case"varDupl":return`"${n.content}" is already a variable in the current scope.`;default:return"Bad error message ID."}})(e,n),lexeme:n}),a=(e,n)=>e.variables.some(e=>(e.name||e.names.basic)===n),i=e=>{const n="%"===e.slice(-1)?"boolint":"string",t="boolint"===n?0:34;return o.fulltype(n,t)},s=e=>"PROC"===e.slice(0,4)?"procedure":"FN"===e.slice(0,2)&&"function";e.exports=(e=>{const n=[];for(var t,l,c,d,u,p,h=0,g="start";h<e.length;)switch(g){case"start":if(t=!0,l=!1,c=!1,d=o.program("!","BASIC"),n.push(d),"DEF"===e[h].content)throw r("progDef",e[h]);g="DIM"===e[h].content?"dim":"prog";break;case"dim":break;case"prog":if("DIM"===e[h].content)throw r("progDim",e[h]);if("PRIVATE"===e[h].content)throw r("progPrivate",e[h]);if("LOCAL"===e[h].content)throw r("progLocal",e[h]);if("DEF"===e[h].content)throw r("progDef",e[h]);"END"===e[h].content?(t=!1,g="end"):("variable"===e[h].type&&(a(n[0],e[h].content)||((u=o.variable(e[h].content,n[0],!1)).fulltype=i(e[h].content),n[0].variables.push(u))),n[0].lexemes.push(e[h])),h+=1;break;case"end":if(e[h]){if("DEF"!==e[h].content){if(0===d.index)throw r("progAfter",e[h]);throw r("subAfter",e[h])}h+=1,g="def"}break;case"def":if(!e[h])throw r("subName",e[h-1]);if(!s(e[h].content))throw r("subBadName",e[h]);if((d=o.subroutine(e[h].content,s(e[h].content,n[0]))).parent=n[0],n.push(d),n[0].subroutines.push(d),"procedure"===d.type?l=!0:(c=!0,u=o.variable("result",d),d.variables.push(u)),!e[h+1])throw r("subAfter",e[h]);"("===e[h+=1].content?(h+=1,g="parameters"):g="variables";break;case"parameters":if(!e[h])throw r("parName",e[h-1]);if(byref="RETURN"===e[h].content,!e[h="RETURN"===e[h].content?h+1:h])throw r("parName",e[h-1]);if("turtle"===e[h].type)throw r("parTurtle",e[h]);if("variable"!==e[h].type)throw r("parId",e[h]);if(a(d,e[h].content))throw r("parDupl",e[h]);if((u=o.variable(e[h].content,d,byref)).fulltype=i(e[h].content),d.parameters.push(u),d.variables.push(u),!e[h+=1])throw r("parBracket",e[h-1]);if("variable"===e[h].type)throw r("parComma",e[h]);if(")"===e[h].content)g="variables";else if(","!==e[h].content)throw r("parBracket",e[h]);h+=1;break;case"variables":if(!e[h])throw r("subEmpty",e[h-1]);switch(e[h].content){case"DIM":throw r("subDim",e[h]);case"PRIVATE":h+=1,g="private";break;case"LOCAL":h+=1,g="local";break;default:g="subroutine"}break;case"private":if(!e[h])throw r("varName",e[h-1]);if("turtle"===e[h].type)throw r("varTurtle",e[h]);if("variable"!==e[h].type)throw r("varId",e[h]);if(a(d,e[h].content))throw r("varDupl",e[h]);if((u=o.variable(e[h].content,n[0])).fulltype=i(e[h].content),u.private=d,n[0].variables.push(u),!e[h+=1])throw r("subNoEnd",e[h-1]);","===e[h].content?h+=1:g="variables";break;case"local":if(!e[h])throw r("varName",e[h-1]);if("turtle"===e[h].type)throw r("varTurtle",e[h]);if("variable"!==e[h].type)throw r("varId",e[h]);if(a(d,e[h].content))throw r("varDupl",e[h]);if((u=o.variable(e[h].content,d)).fulltype=i(e[h].content),d.variables.push(u),!e[h+=1]){if("procedure"===d.type)throw r("subNoEndProc",e[h]);throw r("subNoEndFn",e[h])}","===e[h].content?h+=1:g="variables";break;case"subroutine":if("DIM"===e[h].content)throw r("subDim",e[h]);if("PRIVATE"===e[h].content)throw r("subPrivate",e[h]);if("LOCAL"===e[h].content)throw r("subLocal",e[h]);if("DEF"===e[h].content)throw r("subDef",e[h]);if("variable"===e[h].type&&(a(n[0],e[h].content)||a(d,e[h].content)||((u=o.variable(e[h].content,n[0])).fulltype=i(e[h].content),n[0].variables.push(u))),"ENDPROC"===e[h].content){if("procedure"!==d.type)throw r("subEndFn",e[h]);h+=1,l=!1,g="end"}else if(e[h].line>e[h-1].line&&"="===e[h].content){if("function"!==d.type)throw r("subEndProc",e[h]);d.lexemes.push(e[h]),h+=1,g="result"}else d.lexemes.push(e[h]),h+=1;break;case"result":if(!e[h])throw r("subEmptyResult",e[h-1]);for(p=e[h].line;e[h]&&e[h].line===p;)d.lexemes.push(e[h]),h+=1;c=!1,g="end"}if(t)throw r("progNoEnd",e[h-1]);if(l)throw r("subNoEndProc",e[h-1]);if(c)throw r("subNoEndFn",e[h-1]);return n})},function(e,n,t){const{factory:o,find:r}=t(3),a=(e,n)=>({type:"Compiler",message:((e,n)=>{switch(e){case"progBegin":return'Program must start with keyword "PROGRAM".';case"progName":return'"PROGRAM" must be followed by a legal program name.';case"progTurtle":return"Program cannot be given the name of a Turtle attribute.";case"progId":return`"${n.content}" is not a valid program name.`;case"progSemi":return"Program name must be followed by a semicolon.";case"constVar":return"Constants must be defined before any variables.";case"constSub":return"Constants must be defined before any subroutines.";case"varSub":return"Variables must be defined before any subroutines.";case"progWeird":return'Expected "BEGIN", constant/variable definitions, or subroutine definitions.';case"constDef":return"Constant must be assigned a value.";case"constNegString":return"Strings cannot be negated.";case"constNegBoolean":return"Boolean values cannot be negated.";case"constSemi":return"Constant declaration must be followed by a semicolon.";case"constValue":return`"${n.content}" is not a valid constant value.`;case"constName":return"No constant name found.";case"constTurtle":return`"${n.content}" is the name of a predefined Turtle property, and cannot be used as a constant name.`;case"constId":return`"${n.content}" is not a valid constant name.`;case"constProg":return`Constant name "${n.content}" is already the name of the program.`;case"constDupl":return`"${n.content}" is already the name of a constant in the current scope.`;case"varType":return"Variable name must be followed by a colon, then the variable type (array, boolean, char, integer, or string).";case"varBadType":return`"${n.content}" is not a valid variable type (expected "array", "boolean", "char", "integer", or "string").`;case"varStringNoSize":return"Opening bracket must be followed by an integer value.";case"varStringBadSize":return"String size must be an integer.";case"varStringRbkt":return'String size must be followed by a closing square bracket "]".';case"varArrayBadSize":return'Array declarations take the form "array[n..m]", where "n" and "m" are integer values specifying the start and end index of the array.';case"varArrayNoConstant":return`Constant "${n.content}" has not been declared.`;case"varArrayBadConstant":return`"${n.content}" is not an integer constant.`;case"varArrayOf":return'Array declaration must be followed by "of", and then the type of the elements of the array.';case"varName":return"No variable name found.";case"varTurtle":return`"${n.content}" is the name of a predefined Turtle property, and cannot be used as a variable name.`;case"varId":return`"${n.content}" is not a valid variable name.`;case"varProg":return`Variable name "${n.content}" is already the name of the program.`;case"varDupl":return`"${n.content}" is already the name of a constant or variable in the current scope.`;case"varComma":return"Comma missing between variable declarations.";case"parNoRbkt":return'Parameter declarations must be followed by a closing bracket ")".';case"parArrayNoRef":return"Array parameters can only be passed by reference, not by value.";case"parArraySize":return"Array references parameters cannot be given a size specification.";case"subName":return"No subroutine name found.";case"subTurtle":return`"${n.content}" is the name of a predefined Turtle property, and cannot be used as a subroutine name.`;case"subId":return`"${n.content}" is not a valid subroutine name.`;case"subProg":return`Subroutine name "${n.content}" is already the name of the program.`;case"subDupl":return`"${n.content}" is already the name of a subroutine in the current scope.`;case"subSemi":return"Subroutine declaration must be followed by a semicolon.";case"fnType":return"Function must be followed by a colon, the the return type (integer, boolean, char, or string).";case"fnBadType":return`"${n.content}" is not a valid return type (expected "integer", "boolean", "char", or "string").`;case"subEnd":return'Routine commands must finish with "END".';case"constAfter":return"No program text found after constant declarations.";case"varAfter":return"No text found after variable declarations.";case"varSemi":return"Variable declaration(s) must be followed by a semicolon.";case"progDot":return'Program "END" must be followed by a full stop.';case"progOver":return'No text can appear after program "END".';default:return e}})(e,n),lexeme:n}),i=(e,n)=>e.variables.concat(e.constants).some(e=>e.name===n),s=(e,n,t=!1,o=null)=>{if(t){if(!e[n])throw a(o,e[n-1]);if(";"!==e[n].content)throw a(o,e[n])}for(;e[n]&&";"===e[n].content;)n+=1;return n},l=(e,n)=>{const[t,r]=e.slice(n,n+2);if(!t||"program"!==t.content)throw a("progBegin",t);if(!r)throw a("progName",t);if("turtle"===r.type)throw a("progTurtle",r);if("identifier"!==r.type)throw a("progId",r);return{lex:s(e,n+2,!0,"progSemi"),routine:o.program(r.content,"Pascal")}},c=(e,n,t)=>{const o=e[n];if(!o)throw a("progWeird",e[n-1]);switch(o.content){case"const":if(t.variables.length>0)throw a("constVar",o);if(t.subroutines.length>0)throw a("constSub",o);return{lex:n+1,state:"const"};case"var":if(t.subroutines.length>0)throw a("varSub",o);return{lex:n+1,state:"var"};case"function":case"procedure":return{lex:n+1,state:o.content};case"begin":return{lex:s(e,n+1),state:"begin"};default:throw a("progWeird",o)}},d=(e,n,t,i)=>{const l=e[n];let c;if(!l)throw a("constDef",e[n-1]);switch(l.type){case"string":throw a("constNegString",l);case"boolean":throw a("constNegBoolean",l);case"integer":return{lex:s(e,n+1,!0,"constSemi"),constant:o.constant(t,l.type,-l.value)};case"identifier":if(!(c=r.constant(i,l.content,"Pascal")||r.colour(l.content,"Pascal")))throw a("constValue",l);return{lex:s(e,n+1,!0,"constSemi"),constant:o.constant(t,c.type,-c.value)};default:throw a("constValue",l)}},u=(e,n,t,i)=>{const l=e[n];let c;if(!l)throw a("constDef",e[n-1]);switch(l.type){case"boolean":case"integer":case"string":return{lex:s(e,n+1,!0,"constSemi"),constant:o.constant(t,l.type,l.value)};case"identifier":if(!(c=r.constant(i,l.content,"Pascal")||r.colour(l.content,"Pascal")))throw a("constValue",l);return{lex:s(e,n+1,!0,"constSemi"),constant:o.constant(t,c.type,c.value)};default:throw a("constValue",l)}},p=(e,n,t)=>{const[o,s,l]=e.slice(n,n+3);if(!o)throw a("constName",e[n-1]);if("turtle"===o.type)throw a("constTurtle",o);if("identifier"!==o.type)throw a("constId",o);if(o.content===r.mainProgram(t).name)throw a("constProg",o);if(i(t,o.content))throw a("constDupl",o);if(!s)throw a("constDef",o);if("="!==s.content)throw a("constDef",s);if(!l)throw a("constDef",s);return"-"===l.content?d(e,n+3,o.content,t):u(e,n+2,o.content,t)},h=(e,n,t)=>{const[i,s,l,c,d,u]=e.slice(n,n+6);let p,h,g;if(!i)throw a("varArrayBadSize",type);if("["!==i.content)throw a("varArrayBadSize",i);if(!s)throw a("varArrayBadSize",i);switch(s.type){case"identifier":if(!(p=r.constant(t,s.content,"Pascal")))throw a("varArrayNoConstant",s);if("integer"!==p.type)throw a("varArrayBadConstant",s);g=p.value;break;case"integer":g=s.value;break;default:throw a("varArrayBadSize",s)}if(!l)throw a("varArrayBadSize",s);if(".."!==l.content)throw a("varArrayBadSize",l);if(!c)throw a("varArrayBadSize",l);switch(c.type){case"identifier":if(!(p=r.constant(t,c.content,"Pascal")))throw a("varArrayNoConstant",c);if("integer"!==p.type)throw a("varArrayBadConstant",c);h=p.value;break;case"integer":h=c.value;break;default:throw a("varArrayBadSize",c)}if(!d)throw a("varArrayBadSize",c);if("]"!==d.content)throw a("varArrayBadSize",d);if(!u)throw a("varArrayOf",d);if("of"!==u.content)throw a("varArrayOf",u);return result=m(e,n+6,t),{lex:result.lex,fulltype:o.fulltype("array",h-g+1,g,result.fulltype)}},g=(e,n,t,o)=>{if(!o)throw a("parArrayNoRef",type);if(!e[n])throw a("varArrayOf",e[n-1]);if("["===e[n].content)throw a("parArraySize",e[n]);if("of"!==e[n].content)throw a("varArrayOf",e[n]);return m(e,n+1,t,!0,o)},m=(e,n,t,r,i)=>{const s=e[n];if(!e[n])throw a("varType",e[n-1]);switch(s.content){case"boolean":case"integer":case"char":return{lex:n+1,fulltype:o.fulltype(s.content)};case"string":if(e[n+1]&&"["===e[n+1].content){const[t,r]=e.slice(n+2,n+4);if(!t)throw a("varStringNoSize",e[n+1]);if("integer"!==t.type)throw a("varStringBadSize",t);if(!r)throw a("varStringRbkt",t);if("]"!==r.content)throw a("varStringRbkt",r);return{lex:n+4,fulltype:o.fulltype("string",t.value)}}return{lex:n+1,fulltype:o.fulltype("string")};case"array":return r?g(e,n+1,t,i):h(e,n+1,t);default:throw a("varBadType",s)}},y=(e,n,t,s=!1,l=!1)=>{const c=[];let d=!0;for(;d;){if(!e[n])throw a("varName",e[n-1]);if("turtle"===e[n].type)throw a("varTurtle",e[n]);if("identifier"!==e[n].type)throw a("varId",e[n]);if(e[n].content===r.mainProgram(t).name)throw a("varProg",e[n]);if(i(t,e[n].content))throw a("varDupl",e[n]);if(c.push(o.variable(e[n].content,t,l)),!e[n+1])throw a("varType",lexmes[n]);if(","===e[n+1].content)n+=2;else if(":"===e[n+1].content)n+=2,d=!1;else switch(e[n+1].type){case"identifier":throw a("varComma",e[n+1]);case"type":default:throw a("varType",e[n+1])}}return({lex:n,fulltype:fulltype}=m(e,n,t,s,l)),c.forEach(e=>e.fulltype=fulltype),{lex:n,variables:c}},x=(e,n,t,i)=>{const l=e[n];let c,d,u;if(!l)throw a("subName",e[n-1]);if("turtle"===l.type)throw a("subTurtle",l);if("identifier"!==l.type)throw a("subId",l);if(l.content===r.mainProgram(i).name)throw a("subProg",l);if(r.customCommand(i,l.content,"Pascal"))throw a("subDupl",l);if(c=o.subroutine(l.content,t,i),"function"===t&&c.variables.push(o.variable("result",c,!1)),!e[n+=1])throw a("subSemi",l);if("("===e[n].content&&(({parameters:d,lex:n}=((e,n,t)=>{let o=[],r=[],i=!0;for(;i;){if(({lex:n,variables:r}=e[n]&&"var"===e[n].content?y(e,n+1,t,!0,!0):y(e,n,t,!0,!1)),o=o.concat(r),!e[n])throw a("parNoRbkt",e[n-1]);switch(e[n].content){case";":n+=1;break;case")":n+=1,i=!1;break;default:throw a("parNoRbkt",e[n])}}return{lex:n,parameters:o}})(e,n+1,c)),c.parameters=d,c.variables=c.variables.concat(d)),"function"===t){if(!e[n])throw a("fnType",e[n-1]);if(":"!==e[n].content)throw a("fnType",e[n]);({lex:n,fulltype:u}=m(e,n+1,c)),c.variables[0].fulltype=u}return{lex:n=s(e,n,!0,"subSemi"),routine:c}},f=(e,n)=>{let t=[],o=1;for(;o>0&&e[n];)"begin"===e[n].content&&(o+=1),"end"===e[n].content&&(o-=1),t.push(e[n]),n+=1;if(o>0)throw a("subEnd",e[n]);return{lex:n,content:t.slice(0,-1)}};e.exports=(e=>{const n=[],t=[];let o,r,i,d,u,h=0,g=0,m="program";for(;g<e.length;)switch(m){case"program":({lex:g,routine:o}=l(e,g)),n.push(o),t.push(o),m="crossroads";break;case"crossroads":({lex:g,state:m}=c(e,g,o));break;case"const":if(({lex:g,constant:i}=p(e,g,o)),o.constants.push(i),!e[g])throw a("constAfter",e[g-1]);"identifier"!==e[g].type&&(m="crossroads");break;case"var":if(({lex:g,variables:d}=y(e,g,o)),o.variables=o.variables.concat(d),!e[g=s(e,g,!0,"varSemi")])throw a("varAfter",e[g-1]);"identifier"!==e[g].type&&(m="crossroads");break;case"procedure":case"function":r=t[t.length-1],({lex:g,routine:o}=x(e,g,m,r)),r.subroutines.push(o),t.push(o),m="crossroads";break;case"begin":({lex:g,content:u}=f(e,g)),o.lexemes=u,m="end";break;case"end":if(0===o.index){if(!e[g])throw a("progDot",e[g-1]);if("."!==e[g].content)throw a("progDot",e[g]);if(e[g+1])throw a("progOver",e[g+1]);g+=1}else g=s(e,g,!0,"subSemi"),h+=1,o.index=h,n.push(t.pop()),o=t[t.length-1],m="crossroads"}return n})},function(e,n,t){e.exports=(e=>{const n=[],t=[];let a,p=0,h="crossroads";for(a=r.program("!","Python"),n.push(a),t.push(a);p<e.length;)switch(h){case"crossroads":({lex:p,state:h}=i(e,p,a));break;case"global":({lex:p,state:h}=s(e,p,a));break;case"nonlocal":({lex:p,state:h}=l(e,p,a));break;case"def":({lex:p,routine:a,state:h}=c(e,p,a)),t.push(a);break;case"parameters":({lex:p,state:h}=d(e,p,a));break;case"commands":({lex:p,state:h}=u(e,p,a)),null===a.index&&(a.index=n.length,n.push(t.pop()),a=t[t.length-1])}if(0===n[0].lexemes.length){if(!n.some(e=>"main"===e.name))throw o('Program must have some commands or define a "main" procedure.',e[e.length-1]);n[0].lexemes=[{type:"identifier",content:"main",indent:0},{type:"punctuation",content:"(",indent:0},{type:"punctuation",content:")",indent:0}]}return n});const{error:o,factory:r,find:a}=t(3),i=(e,n,t)=>{if(!e[n])throw o("No commands given.",e[n-1]);if(t.indent){if(e[n].offset<t.indent)throw o("Not enough indentation.",e[n]);if(e[n].offset>t.indent)throw o("Too much indentation.",e[n])}else t.indent=e[n].offset;switch(e[n].content){case"global":if(0===t.index)throw o("Global variables are only allowed in subroutines.",e[n]);if(t.subroutines.length>0)throw o("Global variables must be declared before any subroutine definitions.",e[n]);return{lex:n+1,state:"global"};case"nonlocal":if(0===t.index)throw o("Nonlocal variables are only allowed in subroutines.",e[n]);if(t.subroutines.length>0)throw o("Nonlocal variables must be declared before any subroutine definitions.",e[n]);return{lex:n+1,state:"nonlocal"};case"def":if(t.lexemes.length>0)throw o("Subroutine definitions must come before the routine's commands",e[n]);return{lex:n+1,state:"def"};default:return{lex:n,state:"commands"}}},s=(e,n,t)=>{if(!e[n])throw o('"global" must be followed by an identifier.',e[n-1]);if(e[n].line!==e[n-1].line)throw o("Global variable declarations must be on a single line.",e[n]);for(;e[n]&&e[n].line===e[n-1].line;){if("turtle"!==e[n].type&&"identifier"!==e[n].type)throw o("{lex} is not a valid variable name.",e[n]);if(t.globals.indexOf(e[n].content)>-1)throw o("Global variable {lex} has already been declared.",e[n]);t.globals.push(e[n].content);const i=a.program(t);if("turtle"===e[n].type||i.variables.some(t=>t.name===e[n].content)||i.variables.push(r.variable(e[n],i)),e[n+1].line>e[n].line)return{lex:n+1,state:"crossroads"};if(!e[n+1]||","!==e[n+1].content)throw o("Comma missing after global variable declaration.",e[n]);if(!e[n+2])throw o("Expected more global variable declarations after comma.",e[n+1]);if(e[n+2].line>e[n+1].line)throw o("Global variable declarations must be on a single line.",e[n+2]);n+=2}return{lex:n,state:"crossroads"}},l=(e,n,t)=>{if(!e[n])throw o('"local" must be followed by an identifier.',e[n-1]);if(e[n].line>e[n-1].line)throw o("Nonlocal variable definitions must be on a single line.",e[n]);if(t.nonlocals.indexOf(e[n].content)>-1)throw o("Nonlocal variable {lex} has already been defined.",e[n]);for(;e[n]&&e[n].line===e[n-1].line;){if("turtle"===e[n].type)throw o("Turtle variables are global, not nonlocal.",e[n]);if("identifier"!==e[n].type)throw o("{lex} is not a valid variable name.",e[n]);if(t.nonlocals.indexOf(e[n].content)>-1)throw o("Nonlocal variable {lex} has already been declared.",e[n]);if(t.nonlocals.push(e[n].content),e[n+1].line>e[n].line)return{lex:n+1,state:"crossroads"};if(!e[n+1]||","!==e[n+1].content)throw o("Comma missing after nonlocal variable declaration.",e[n]);if(!e[n+2])throw o("Expected more nonlocal variable declarations after comma.",e[n+1]);if(e[n+2].line>e[n+1].line)throw o("Nonlocal variable declarations must be on a single line.",e[n+2]);n+=2}return{lex:n,state:"crossroads"}},c=(e,n,t)=>{if(!e[n])throw o('"def" must be followed by an identifier.',e[n-1]);if(e[n-1].line!==e[n].line)throw o('Subroutine name must be on the same line as "def".',e[n]);if("turtle"===e[n].type)throw o("Subroutine cannot have the name of a global Turtle variable.",e[n]);if("identifier"!==e[n].type)throw o("{lex} is not a valid subroutine name.",e[n]);if(p(e[n].content,t))throw o("{lex} is already the name of a subroutine or variable in the current scope.",e[n]);if((t=r.subroutine(e[n].content,"procedure",t)).parent.subroutines.push(t),!e[n+1])throw o("Subroutine definition must be followed by an open bracket.",e[n-1]);if("("!==e[n+1].content)throw o("Subroutine definition must be followed by an open bracket.",e[n]);if(e[n].line!==e[n+1].line)throw o("Open bracket must be on the same line as the subroutine definition.",e[n]);return{lex:n+2,routine:t,state:"parameters"}},d=(e,n,t)=>{if(!e[n])throw o("Expecting parameter definition or closing bracket.",e[n-1]);if(")"===e[n].content){if(e[n-1].line!==e[n].line)throw o("Closing bracket after parameters cannot be on a new line.",e[n]);if(!e[n+1])throw o("Subroutine definition must be followed by a colon.",e[n]);if(":"!==e[n+1].content)throw o("Subroutine definition must be followed by a colon.",e[n+1]);if(e[n+1].line>e[n].line)throw o("Colon following subroutine definition cannot be on a new line.",e[n+1]);if(!e[n+2])throw o("No commands found following subroutine declaration.",e[n+1]);if(e[n+2].line===e[n+1].line)throw o("Subroutine commands must be on a new line.",e[n]);return{lex:n+2,state:"crossroads"}}if("turtle"===e[n].type)throw o("{lex} is the name of a predefined global Turtle variable.",e[n]);if("identifier"!==e[n].type)throw o("{lex} is not a valid identifier.",e[n]);if(e[n-1].line!==e[n].line)throw o("Parameter declaration cannot be on a new line.",e[n]);if(t.parameters.some(t=>t.name===e[n].content))throw o("{lex} is already the name of a parameter for this subroutine.",e[n]);let a=r.variable(e[n],t);if(t.parameters.push(a),t.variables.push(a),!e[n+1])throw o("Closing bracket missing after parameter declarations.",e[n]);if("turtle"===e[n+1].type||"identifier"===e[n+1].type)throw o("Comma missing between parameters.",e[n+1]);if(","===e[n+1].content){if(!e[n+2])throw o("Expected parameter declaration after comma.",e[n+1]);if(")"===e[n+2].content)throw o("Parameter list cannot end with a comma.",e[n+1]);return{lex:n+2,state:"parameters"}}if(")"===e[n+1].content)return{lex:n+1,state:"parameters"};throw o("py1parser43","parsNoCommaOrBracket",e[n])},u=(e,n,t)=>{let a;for(;e[n]&&e[n].offset>=t.indent;){if("return"===e[n].content){if(0===t.index)throw o("cmdMainReturn",e[n]);if("main"===t.name)throw o("cmdMainSubReturn",e[n]);if("function"===t.type)throw o("cmdRepeatReturn",e[n]);t.type="function",a=r.variable(e[n],t,!1),t.variables.unshift(a)}h(t,e,n)&&(a=r.variable(e[n],t,!1),t.variables.push(a)),t.lexemes.push(e[n]),n+=1}return{lex:n,state:"crossroads"}},p=(e,n)=>0===n.index?n.subroutines.some(n=>n.name===e):n.subroutines.some(n=>n.name===e)||n.globals.indexOf(e)>-1||n.nonlocals.indexOf(e)>-1,h=(e,n,t)=>"identifier"===n[t].type&&(!!n[t+1]&&(("="===n[t+1].content||"in"===n[t+1].content)&&(!(e.globals.indexOf(n[t].content)>-1)&&(!(e.nonlocals.indexOf(n[t].content)>-1)&&!a.variable(e,n[t].content,"Python")))))},function(e,n,t){e.exports=((e,n)=>{const t=e[0],r=e.slice(1).length>0?4:3,s=a(e,r,n),l=r+s.length,c=i(t,l,n);return o.program(e[0],s,c)});const{pcoder:o}=t(3),r={BASIC:t(39),Pascal:t(40),Python:t(41)},a=(e,n,t)=>{let r=[],a=1;for(;a<e.length;){e[a].startLine=n;const s=o.subroutineStartCode(e[a]).length;let l=i(e[a],n+s,t),c=o.subroutine(e[a],l);r=r.concat(c),a+=1,n+=c.length}return r},i=(e,n,t)=>{let o=[],a=0;for(;a<e.lexemes.length;){let i=r[t].call(null,e,a,n+o.length);o=o.concat(i.pcode),a=i.lex}return o}},function(e,n){e.exports=((e,n,t)=>({lex:n,pcode:[]}))},function(e,n,t){const{pc:o}=t(2),{molecules:r,find:a,pcoder:i}=t(3),s=(e,n)=>({messageId:e,message:((e,n)=>{switch(e){case"ifExpression":return'"IF" must be followed by a boolean expression.';case"ifThen":return'"IF ..." must be followed by "THEN".';case"ifNothing":return'No commands found after "IF".';case"elseNothing":return'No commands found after "ELSE".';case"forVariable":return'"FOR" must be followed by an integer variable.';case"forTurtle":return'Turtle attribute cannot be used as a "FOR" variable.';case"forNotFound":return`Variable "${n.content}" not defined.`;case"forNotInteger":return`"${n.content}" is not an integer variable.`;case"forAssignment":return'"FOR" variable must be assigned an initial value.';case"forEquals":return'Assignment operator is ":=", not "=".';case"forInitial":return'"FOR" loop variable must be assigned an initial value.';case"forToDownTo":return'"FOR ... := ..." must be followed by "TO" or "DOWNTO".';case"forToNothing":return`"${n.content.toUpperCase()}" must be followed by an integer (or integer constant).`;case"forDo":return'"FOR" loop range must be followed by "DO".';case"forNothing":return'No commands found after "FOR" loop initialisation.';case"repeatExpression":return'"UNTIL" must be followed by a boolean expression.';case"whileExpression":return'"WHILE" must be followed by a boolean expression.';case"whileDo":return'"WHILE ..." must be followed by "DO".';case"whileNothing":return'No commands found after "WHILE ... DO".';case"blockNothing":return'No commands found after "BEGIN".';case"blockBegin":return`"END" expected, not "${n.content.toUpperCase()}".`;case"blockRepeat":return`"UNTIL" expected, not "${n.content.toUpperCase()}".`;case"blockNoEnd":return'"BEGIN" does not have any matching "END".';case"cmdEqal":return'Variable assignment requires ":=" rather than "=".';case"cmdSemicolon":return"Semicolon needed after command.";case"cmdWeird":return`Command cannot begin with "${n.content}".`;default:return e}})(e),lexeme:n}),l=(e,n)=>{switch(n.content){case"end":if("begin"!==e)throw s("blockBegin",n);return!0;case"until":if("repeat"!==e)throw s("blockRepeat",n);return!0;default:return!1}},c=(e,n,t,o,r)=>{const a=e.lexemes;let i,c=[],u=!1;if(!a[n])throw s("blockNothing",a[n-1]);for(;!u&&n<a.length;)(u=l(o,a[n]))?n+=1:(({lex:n,pcode:i}=d(e,n,t+c.length)),c=c.concat(i));if(!u)throw s("blockNoEnd",a[n-1]);return{lex:n,pcode:c}},d=function(e,n,t){const l=e.lexemes,d=["begin","do","dot","repeat","semicolon","then"],u=["else","end","semicolon","until"];let p,h;if("turtle"===l[n].type||"identifier"===l[n].type){if(l[n+1]&&"="===l[n+1].content)throw s("cmd01");l[n+1]&&":="===l[n+1].content?(p=a.variable(e,l[n].content,"Pascal"),({lex:n,pcode:h}=r.variableAssignment(e,p,n+2,"Pascal"))):({lex:n,pcode:h}=r.procedureCall(e,n,"Pascal"))}else switch(l[n].content){case"if":({lex:n,pcode:h}=((e,n,t)=>{const a=e.lexemes;let i=[],l={},d=0,u=0;if(!a[n])throw s("if01","ifExpression",a[n-1]);if(n=(l=r.expression(e,n,"null","bool",!1)).lex,(i=l.pcode)[d=i.length-1].push(o.ifno),!a[n])throw s("if02","ifThen",a[n-1]);if("then"!==a[n].type)throw s("if03","ifThen",a[n]);if(!a[n+=1])throw s("if07","ifNothing",a[n]);if(n=(l="begin"===a[n].type?c(e,n+1,offset+i.length,"begin"):structure(routines,sub,n,addresses,offset+i.length)).lex,i=i.concat(l.pcode),"else"===a[n].content){if(!a[n+=1])throw s("if04","elseNothing",a[n]);u=i.length,i.push([o.jump]),n=(l="begin"===a[n].content?c(routines,sub,n+1,addresses,(offset,i.length)):structure(routines,sub,n,addresses,offset+i.length)).lex,(i=i.concat(l.pcode))[u].push(offset+i.length+1),i[d].push(offset+u+2)}else i[d].push(offset+i.length+1);return{lex:n,pcode:i}})(e,n+1));break;case"for":({lex:n,pcode:h}=((e,n,t)=>{e.lexemes;return{lex:n,pcode:i.forLoop(t,void 0,void 0,void 0,void 0,void 0,void 0)}})(e,n+1,t));break;case"repeat":({lex:n,pcode:h}=((e,n,t)=>{let a=e.lexemes,i=[],l={};if(n=(l=c(routines,sub,n,addresses,(offset,i.length))).lex,i=i.concat(l.pcode),!a[n])throw s("repeat01","repeatExpression",a[n-1]);return n=(l=r.expression(routines,sub,n,addresses,"null","bool",!1)).lex,(i=i.concat(l.pcode))[i.length-1].push(o.ifno),i[i.length-1].push(offset+1),{lex:n,pcode:i}})(e,n+1));break;case"while":({lex:n,pcode:h}=((e,n,t,a,i)=>{let l=e[0].language,d=e[n].lexemes,u=[],p={},h=0;if(!d[t])throw s("while01","whileExpression",d[t-1]);if(t=(p=r.expression(e,n,t,a,"null","bool",!1)).lex,(u=p.pcode)[h=u.length-1].push(o.ifno),"Pascal"===l){if(!d[t])throw s("while02","whileDo",d[t-1]);if("do"!==d[t].type)throw s("while03","whileDo",d[t]);t+=1}if(!d[t])throw s("while04","whileNothing",d[t]);switch(l){case"BASIC":p=d[t].line>d[t-1].line?c(e,n,t,a,u.length):structure(e,n,t,a,i+u.length);break;case"Pascal":p="begin"===d[t].type?c(e,n,t+1,a,u.length):structure(e,n,t,a,i+u.length)}return t=p.lex,(u=u.concat(p.pcode)).push([o.jump,i+1]),u[h].push(i+u.length+1),{lex:t,pcode:u}})(e,n+1,t));break;default:throw s("cmdWeird",l[n])}if(l[n])if(""!==l[n].content){if(-1===d.indexOf(l[n-1].content)&&-1===u.indexOf(l[n].content))throw s("cmdSemicolon",l[n])}else for(;l[n]&&""===l[n].content;)n+=1;return{lex:n,pcode:h}};e.exports=d},function(e,n,t){e.exports=((e,n,t)=>{switch(e.lexemes[n].type){case"turtle":case"identifier":if(e.lexemes[n+1]&&"=="===e.lexemes[n+1].content)throw o('Variable assignment in Python uses "=", not "==".',e.lexemes[n+1]);return e.lexemes[n+1]&&"="===e.lexemes[n+1].content?r.variableAssignment(e,e.lexemes[n].content,n+2,"Python"):r.procedureCall(e,n,"Python");case"keyword":switch(e.lexemes[n].content){case"return":return r.variableAssignment(e,"return",n+1,"Python");case"if":return s(e,n+1,t);case"for":return l(e,n+1,t);case"while":return c(e,n+1,t)}break;default:throw o("{lex} makes no sense here.",e.lexemes[n])}});const{error:o,molecules:r,find:a,pcoder:i}=t(3),s=(e,n,t)=>{const a=e.lexemes;let s,l,c,u=[];if(!a[n])throw o("if01",a[n-1]);if(!d(a,n))throw o("if02",a[n]);if(n=(c=r.expression(e,n,"null","boolean","Python")).lex,s=c.pcode[0],!a[n])throw o("if03",a[n-1]);if(!p(a,n,":"))throw o("if04",a[n]);if(!a[n+=1])throw o("if05",a[n-1]);if(d(a,n))throw o("if06",a[n]);if(!h(a,n))throw o("if07",a[n]);if(n=(c=g(e,n,t+1,a[n].offset)).lex,l=c.pcode,a[n]&&"else"===a[n].type){if(d(a,n))throw o("if08",a[n]);if(!a[n+=1])throw o("if09",a[n-1]);if(!p(a,n,":"))throw o("if10",a[n]);if(!a[n+=1])throw o("if11",a[n-1]);if(d(a,n))throw o("if12",a[n]);if(!h(a,n))throw o("if13",a[n]);n=(c=g(e,n,t+l.length+2,a[n].offset)).lex,u=c.pcode}return{lex:n,pcode:i.conditional(t,s,l,u)}},l=(e,n,t)=>{const s=e.lexemes;let l,c,m,y,x,f,b;if(!s[n])throw o("for01",s[n-1]);if("turtle"===s[n].type)throw o("for02",s[n]);if(!u(s,n,"identifier"))throw o("for03",s[n]);if(!(c=a.variable(e,s[n].content,"Python")))throw o("for04",s[n]);if("integer"!==c.fulltype.type&&"boolint"!==c.fulltype.type)throw o("for05",s[n]);if(!s[n+=1])throw o("for06",s[n-1]);if(!p(s,n,"in"))throw o("for07",s[n]);if(!s[n+=1])throw o("for08",s[n-1]);if(!p(s,n,"range"))throw o("for09",s[n]);if(!s[n+=1])throw o("for10",s[n-1]);if(!p(s,n,"("))throw o("for11",s[n]);if(!s[n+=1])throw o("for12",s[n-1]);if(!d(s,n))throw o("for13",s[n]);if(n=(l=r.expression(e,n,"null","integer","Python")).lex,x=l.pcode[0],!s[n])throw o("for14",s[n-1]);if(!p(s,n,","))throw o("for15",s[n]);if(!s[n+=1])throw o("for16",s[n-1]);if(!d(s,n))throw o("for17",s[n]);if(n=(l=r.expression(e,n,"null","integer","Python")).lex,f=l.pcode[0],!s[n])throw o("for18",s[n-1]);if(!p(s,n,","))throw o("for19",s[n]);if(!s[n+=1])throw o("for20",s[n-1]);if(!d(s,n))throw o("for21",s[n]);if("integer"===s[n].type){if(1!==s[n].value)throw o("for22",s[n]);m="more",y="incr"}else{if("-"!==s[n].content)throw o("for26",s[n]);if(!s[n+=1])throw o("for23",s[n-1]);if(!u(s,n,"integer"))throw o("for24",s[n]);if(1!==s[n].value)throw o("for25",s[n]);m="less",y="decr"}if(!s[n+=1])throw o("for27",s[n-1]);if(!p(s,n,")"))throw o("for28",s[n]);if(!s[n+=1])throw o("for29",s[n-1]);if(!p(s,n,":"))throw o("for30",s[n]);if(!s[n+=1])throw o("for31",s[n-1]);if(d(s,n))throw o("for32",s[n]);if(!h(s,n))throw o("for33",s[n]);return n=(l=g(e,n,t+3,s[n].offset)).lex,b=l.pcode,{lex:n,pcode:i.forLoop(t,c,x,f,m,y,b)}},c=(e,n,t)=>{const a=e.lexemes;let s,l,c;if(!a[n])throw o("while01");if(!d(a,n))throw o("while02");if(n=(s=r.expression(e,n,"null","boolean","Python")).lex,l=s.pcode[0],!a[n])throw o("while03");if(!p(a,n,":"))throw o("while04");if(!a[n+=1])throw o("while05");if(d(a,n))throw o("while06");if(!h(a,n))throw o("while07");return n=(s=g(e,n,t+1,a[n].offset)).lex,c=s.pcode,{lex:n,pcode:i.whileLoop(t,l,c)}},d=(e,n)=>e[n].line===e[n-1].line,u=(e,n,t)=>d(e,n)&&e[n].type===t,p=(e,n,t)=>d(e,n)&&e[n].content===t,h=(e,n)=>e[n].offset>e[n-1].offset,g=(n,t,r,a)=>{const i=n.lexemes;let s,l=[],c=!1;if(!i[t])throw o("blockNothing",i[t-1]);for(;!c&&t<i.length;)(c=i[t].offset<a)||(s=l,({lex:t,pcode:l}=e.exports(n,t,r+l.length)),l=s.concat(l));return{lex:t,pcode:l}}},function(e,n,t){e.exports.on=((e,n)=>{i[e]=n}),e.exports.isRunning=(()=>s.running),e.exports.isPaused=(()=>s.paused),e.exports.run=((e,n,t)=>{(a=t).resolution(1e3,1e3),a.console(!0,16777215),a.output(!0,16777215),l.length=2097152,c.length=256,d.length=16,l.fill(0),c.fill(-1),d.fill(-1),u.length=0,p.length=0,h.length=0,g.length=0,m.length=0,y=-1,x=n.stackSize-1,b=f=x,w=f,C=0,P=0,I=1e3,N=1e3,A=1e3,L=1e3,D=360,B=!1,v=Date.now(),E=!0,T=!0,R=!0,k="",S=null,O=null,s.running=!0,s.paused=!1,window.addEventListener("keydown",M),window.addEventListener("keyup",F),window.addEventListener("keypress",$),a.addEventListener("contextmenu",Y),a.addEventListener("mousemove",U),a.addEventListener("touchmove",Y),a.addEventListener("touchmove",U),a.addEventListener("mousedown",Y),a.addEventListener("mousedown",X),a.addEventListener("touchstart",X),a.addEventListener("mouseup",G),a.addEventListener("touchend",G),i.run(),H(e,0,0,n)}),e.exports.halt=(()=>{window.removeEventListener("keydown",M),window.removeEventListener("keyup",F),window.removeEventListener("keypress",$),a.removeEventListener("contextmenu",Y),a.removeEventListener("mousemove",U),a.removeEventListener("touchmove",Y),a.removeEventListener("touchmove",U),a.removeEventListener("mousedown",Y),a.removeEventListener("mousedown",X),a.removeEventListener("touchstart",X),a.removeEventListener("mouseup",G),a.removeEventListener("touchend",G),a.cursor(1),s.running=!1,s.paused=!1,i.halt()}),e.exports.play=(()=>{s.paused=!1,i.play()}),e.exports.pause=(()=>{s.paused=!0,i.pause()});const{colours:o,pc:r}=t(2);let a;const i={},s={running:!1,paused:!1},l=[],c=[],d=[],u=[],p=[],h=[],g=[],m=[];let y,x,f,b,w,v,E,T,R,k,S,O,C,P,I,N,A,L,D,B;const M=e=>{const n=e.keyCode||e.charCode;if(8===n){e.preventDefault();const n=l[1],t=l[n+1],o=l[n+2];t<o&&(l[o]=0,l[n+2]-=1),k=k.slice(0,-1),R&&a.delete()}n>=37&&n<=40&&e.preventDefault(),d[9]=n,d[10]=128,e.shiftKey&&(d[10]+=8),e.altKey&&(d[10]+=16),e.ctrlKey&&(d[10]+=32),c[n]=d[10]},F=e=>{const n=e.keyCode||e.charCode;d[9]=-d[9],d[10]=-d[10],c[n]=-c[n]},$=e=>{const n=e.keyCode||e.charCode;l.addToBuffer(n),R&&a.log(String.fromCharCode(n))},U=e=>{switch(e.type){case"mousemove":d[7]=te(e.clientX),d[8]=oe(e.clientY);break;case"touchmove":case"touchstart":d[7]=te(e.touches[0].clientX),d[8]=oe(e.touches[0].clientY)}},X=e=>{const n=Date.now();switch(d[4]=128,e.shiftKey&&(d[4]+=8),e.altKey&&(d[4]+=16),e.ctrlKey&&(d[4]+=32),n-l.getQuery(11)<300&&(d[4]+=64),d[11]=n,e.type){case"mousedown":switch(d[5]=te(e.clientX),d[6]=oe(e.clientY),e.button){case 0:d[4]+=1,d[1]=d[4],d[2]=-1,d[3]=-1;break;case 1:d[4]+=4,d[1]=-1,d[2]=-1,d[3]=d[4];break;case 2:d[4]+=2,d[1]=-1,d[2]=d[4],d[3]=-1}break;case"touchstart":d[5]=te(e.touches[0].clientX),d[6]=oe(e.touches[0].clientY),d[4]+=1,d[1]=d[4],d[2]=-1,d[3]=-1,U(e)}},G=e=>{switch(d[4]=-d[4],e.type){case"mouseup":switch(e.button){case 0:d[1]=-d[1];break;case 1:d[2]=-d[3];break;case 2:d[2]=-d[2]}break;case"touchend":d[1]=-d[1]}},Y=e=>{e.preventDefault()},H=(n,t,x,k)=>{if(!s.running)return;if(s.paused)return void setTimeout(H,1,n,t,x,k);window.removeEventListener("keypress",S),window.removeEventListener("keypress",O);let M,F,$,U,X=0,G=0;for(;X<k.drawCountMax&&G<=k.codeCountMax;){switch(n[t][x]){case r.dupl:M=p.pop(),p.push(M,M);break;case r.swap:F=p.pop(),M=p.pop(),p.push(F,M);break;case r.rota:$=p.pop(),F=p.pop(),M=p.pop(),p.push(F,$,M);break;case r.incr:M=p.pop(),p.push(M+1);break;case r.decr:M=p.pop(),p.push(M-1);break;case r.not:M=p.pop(),p.push(~M);break;case r.and:F=p.pop(),M=p.pop(),p.push(M&F);break;case r.or:F=p.pop(),M=p.pop(),p.push(M|F);break;case r.xor:F=p.pop(),M=p.pop(),p.push(M^F);break;case r.neg:M=p.pop(),p.push(-M);break;case r.abs:M=p.pop(),p.push(Math.abs(M));break;case r.sign:M=p.pop(),p.push(Math.sign(M));break;case r.rand:M=p.pop(),p.push(Math.floor(Math.random()*Math.abs(M)));break;case r.plus:F=p.pop(),M=p.pop(),p.push(M+F);break;case r.subt:F=p.pop(),M=p.pop(),p.push(M-F);break;case r.mult:F=p.pop(),M=p.pop(),p.push(M*F);break;case r.divr:F=p.pop(),M=p.pop(),p.push(Math.round(M/F));break;case r.div:F=p.pop(),M=p.pop(),p.push(Math.floor(M/F));break;case r.mod:F=p.pop(),M=p.pop(),p.push(M%F);break;case r.divm:$=p.pop(),F=p.pop(),M=p.pop(),p.push(Math.round(M/F*$));break;case r.sqrt:F=p.pop(),M=p.pop(),p.push(Math.round(Math.sqrt(M)*F));break;case r.hyp:$=p.pop(),F=p.pop(),M=p.pop(),p.push(Math.round(Math.sqrt(M*M+F*F)*$));break;case r.root:U=p.pop(),$=p.pop(),F=p.pop(),M=p.pop(),p.push(Math.round(Math.pow(M/F,1/$)*U));break;case r.powr:U=p.pop(),$=p.pop(),F=p.pop(),M=p.pop(),p.push(Math.round(Math.pow(M/F,$)*U));break;case r.log:$=p.pop(),F=p.pop(),M=p.pop(),p.push(Math.round(Math.log(M/F)/Math.LN10*$));break;case r.alog:$=p.pop(),F=p.pop(),M=p.pop(),p.push(Math.round(Math.pow(10,M/F)*$));break;case r.ln:$=p.pop(),F=p.pop(),M=p.pop(),p.push(Math.round(Math.log(M/F)*$));break;case r.exp:$=p.pop(),F=p.pop(),M=p.pop(),p.push(Math.round(Math.exp(M/F)*$));break;case r.sin:U=p.pop(),$=p.pop(),M=(F=p.pop())/$*(2*Math.PI)/D,p.push(Math.round(Math.sin(M)*U));break;case r.cos:U=p.pop(),$=p.pop(),M=(F=p.pop())/$*(2*Math.PI)/D,p.push(Math.round(Math.cos(M)*U));break;case r.tan:U=p.pop(),$=p.pop(),M=(F=p.pop())/$*(2*Math.PI)/D,p.push(Math.round(Math.tan(M)*U));break;case r.asin:U=p.pop(),$=p.pop(),F=p.pop(),M=D/(2*Math.PI),p.push(Math.round(Math.asin(F/$)*U*M));break;case r.acos:U=p.pop(),$=p.pop(),F=p.pop(),M=D/(2*Math.PI),p.push(Math.round(Math.acos(F/$)*U*M));break;case r.atan:U=p.pop(),$=p.pop(),F=p.pop(),M=D/(2*Math.PI),p.push(Math.round(Math.atan2(F,$)*U*M));break;case r.pi:M=p.pop(),p.push(Math.round(Math.PI*M));break;case r.ctos:M=p.pop(),W(String.fromCharCode(M));break;case r.itos:M=p.pop(),W(M.toString());break;case r.hexs:for(F=p.pop(),M=p.pop().toString(16).toUpperCase();M.length<F;)M="0"+M;W(M);break;case r.sval:$=p.pop(),F=p.pop(),M=V(F),U="#"===M[0]?isNaN(parseInt(M.slice(1),16))?$:parseInt(M.slice(1),16):isNaN(parseInt(M,10))?$:parseInt(M,10),p.push(U);break;case r.qtos:U=p.pop(),$=p.pop(),F=p.pop(),W((M=F/$).toFixed(U));break;case r.qval:$=p.pop(),F=p.pop(),M=V(p.pop()),U=isNaN(parseFloat(M))?$:parseFloat(M),p.push(Math.round(U*F));break;case r.scat:F=V(p.pop()),M=V(p.pop()),W(M+F);break;case r.slen:M=V(p.pop()),p.push(M.length);break;case r.case:F=p.pop(),M=V(p.pop()),W(F>0?M.toUpperCase():F<0?M.toLowerCase():M);break;case r.copy:$=p.pop(),F=p.pop(),M=V(p.pop()),W(M.substr(F-1,$));break;case r.dels:U=p.pop(),$=p.pop(),M=(F=V(p.pop())).substr(0,$-1)+F.substr($-1+U),W(M);break;case r.inss:U=p.pop(),$=V(p.pop()),F=V(p.pop()),M=$.substr(0,U-1)+F+$.substr(U-1),W(M);break;case r.poss:F=V(p.pop()),M=V(p.pop()),p.push(F.indexOf(M)+1);break;case r.repl:if(U=p.pop(),$=V(p.pop()),F=V(p.pop()),M=V(p.pop()),U>0){for(;U>0;)M=M.replace(F,$),U-=1;W(M)}else W(M.replace(new RegExp(F,"g"),$));break;case r.eqal:F=p.pop(),M=p.pop(),p.push(M===F?-1:0);break;case r.noeq:F=p.pop(),M=p.pop(),p.push(M!==F?-1:0);break;case r.less:F=p.pop(),M=p.pop(),p.push(M<F?-1:0);break;case r.more:F=p.pop(),M=p.pop(),p.push(M>F?-1:0);break;case r.lseq:F=p.pop(),M=p.pop(),p.push(M<=F?-1:0);break;case r.mreq:F=p.pop(),M=p.pop(),p.push(M>=F?-1:0);break;case r.maxi:F=p.pop(),M=p.pop(),p.push(Math.max(M,F));break;case r.mini:F=p.pop(),M=p.pop(),p.push(Math.min(M,F));break;case r.seql:F=V(p.pop()),M=V(p.pop()),p.push(M===F?-1:0);break;case r.sneq:F=V(p.pop()),M=V(p.pop()),p.push(M!==F?-1:0);break;case r.sles:F=V(p.pop()),M=V(p.pop()),p.push(M<F?-1:0);break;case r.smor:F=V(p.pop()),M=V(p.pop()),p.push(M>F?-1:0);break;case r.sleq:F=V(p.pop()),M=V(p.pop()),p.push(M<=F?-1:0);break;case r.smeq:F=V(p.pop()),M=V(p.pop()),p.push(M>=F?-1:0);break;case r.smax:F=V(p.pop()),M=V(p.pop()),W(Math.max(M,F));break;case r.smin:F=V(p.pop()),M=V(p.pop()),W(Math.min(M,F));break;case r.ldin:M=n[t][x+1],p.push(M),x+=1;break;case r.ldvg:M=n[t][x+1],p.push(l[M]),x+=1;break;case r.ldvv:M=n[t][x+1],F=n[t][x+2],p.push(l[l[M]+F]),x+=2;break;case r.ldvr:M=n[t][x+1],F=n[t][x+2],p.push(l[l[l[M]+F]]),x+=2;break;case r.ldag:M=n[t][x+1],p.push(M),x+=1;break;case r.ldav:M=n[t][x+1],F=n[t][x+2],p.push(l[M]+F),x+=2;break;case r.lstr:for(F=(x+=1)+(M=n[t][x]),$="";x<F;)x+=1,$+=String.fromCharCode(n[t][x]);W($);break;case r.ldmt:p.push(h.length-1);break;case r.zero:M=n[t][x+1],F=n[t][x+2],l[l[M]+F]=0,x+=2;break;case r.stvg:M=p.pop(),l[n[t][x+1]]=M,x+=1;break;case r.stvv:M=n[t][x+1],F=n[t][x+2],$=p.pop(),l[l[M]+F]=$,x+=2;break;case r.stvr:M=n[t][x+1],F=n[t][x+2],$=p.pop(),l[l[l[M]+F]]=$,x+=2;break;case r.stmt:M=p.pop(),h.push(M);break;case r.lptr:M=p.pop(),p.push(l[M]);break;case r.sptr:F=p.pop(),M=p.pop(),l[F]=M;break;case r.cptr:$=p.pop(),F=p.pop(),M=p.pop(),K(M,F,$);break;case r.zptr:F=p.pop(),M=p.pop(),z(M,F);break;case r.test:break;case r.cstr:F=p.pop(),M=p.pop(),U=l[F-1],$=l[M],K(M,F,Math.min($,U)+1);break;case r.jump:t=n[t][x+1]-1,x=-1;break;case r.ifno:0===p.pop()?(t=n[t][x+1]-1,x=-1):x+=1;break;case r.halt:return void e.exports.halt();case r.subr:-1===y&&(y=b),g.push(t+1),t=n[t][x+1]-1,x=-1;break;case r.retn:t=g.pop(),x=-1;break;case r.pssr:m.push(n[t][x+1]),x+=1;break;case r.plsr:m.pop();break;case r.psrj:p.push(t+1);break;case r.plrj:g.pop(),t=p.pop()-1,x=-1;break;case r.memc:if(M=n[t][x+1],F=n[t][x+2],($=h.pop())+F>k.stackSize)throw e.exports.halt(),q("Memory stack has overflowed into memory heap. Probable cause is unterminated recursion.");h.push(l[M]),l[M]=$,h.push($+F),x+=2;break;case r.memr:h.pop(),M=n[t][x+1],F=h.pop(),h.push(l[M]),l[M]=F,x+=2;break;case r.hfix:b=f;break;case r.hclr:f=b;break;case r.hrst:y>-1&&(f=y,b=y);break;case r.pnup:E=!1;break;case r.pndn:E=!0;break;case r.udat:T=!0,X=k.drawCountMax;break;case r.ndat:T=!1;break;case r.kech:M=-1===p.pop(),R=M;break;case r.outp:$=-1===p.pop(),F=p.pop(),M=-1===p.pop(),a.output(M,F),$?a.show("output"):a.show("console");break;case r.cons:F=p.pop(),M=-1===p.pop(),a.console(M,F);break;case r.trac:case r.memw:p.pop();break;case r.dump:a.dump(l),k.showMemory&&a.show("memory");break;case r.time:M=Date.now(),M-=v,p.push(M);break;case r.tset:M=Date.now(),F=p.pop(),v=M-F;break;case r.wait:return M=p.pop(),(x+=1)===n[t].length&&(t+=1,x=0),void setTimeout(H,M,n,t,x,k);case r.tdet:return F=p.pop(),M=p.pop(),p.push(0),(x+=1)===n[t].length&&(t+=1,x=0),$=setTimeout(H,M,n,t,x,k),S=j.bind(null,F,$,n,t,x,k),void window.addEventListener("keyup",S);case r.inpt:(M=p.pop())<0?p.push(d[-M]):p.push(c[M]);break;case r.iclr:(M=p.pop())<0?d[-M]=-1:c[M]=-1;break;case r.bufr:(M=p.pop())>0&&(F=f+4,p.push(f+1),l[f+1]=F+M,l[f+2]=F,l[f+3]=F,l.fill(0,F,F+M),f=F+M,w=Math.max(f,w));break;case r.read:M=p.pop(),F=l[1],$="",U="";let s=!1;for(;M>0&&!s;)l[F+1]===l[F+2]?s=!0:(U=l[l[F+1]],$+=String.fromCharChode(U),l[F+1]+=1),M-=1;W($);break;case r.rdln:return M=Math.pow(2,31)-1,(x+=1)===n[t].length&&(t+=1,x=0),F=setTimeout(H,M,n,t,x,k),O=Q.bind(null,F,n,t,x,k),void window.addEventListener("keypress",O);case r.prnt:$=p.pop(),F=p.pop(),M=V(p.pop()),a.print(Z(),M,F,$);break;case r.text:M=V(p.pop()),a.write(M);break;case r.newl:a.write("\n");break;case r.fdir:case r.open:case r.clos:case r.fptr:case r.fbeg:case r.eof:case r.frds:case r.frln:case r.fwrs:case r.fwnl:break;case r.canv:N=p.pop(),I=p.pop(),P=p.pop(),C=p.pop(),l[l[0]+1]=Math.round(C+I/2),l[l[0]+2]=Math.round(P+N/2),l[l[0]+3]=0,i.turtx(l[l[0]+1]),i.turty(l[l[0]+2]),i.turtd(l[l[0]+3]),u.push([l[l[0]+1],l[l[0]+2]]),X=k.drawCountMax;break;case r.reso:F=p.pop(),M=p.pop(),Math.min(M,F)<k.smallSize&&(M*=2,F*=2,B=!0),A=M,L=F,a.resolution(M,F),a.blank(16777215),X=k.drawCountMax;break;case r.pixc:F=p.pop(),M=p.pop(),p.push(a.pixcol(_(M),J(F)));break;case r.pixs:$=p.pop(),F=p.pop(),M=p.pop(),a.pixset(_(M),J(F),$,B),T&&(X+=1);break;case r.angl:M=p.pop(),F=Math.round(M+l[l[0]+3]*M/D),l[l[0]+3]=F%M,i.turtd(l[l[0]+3]),D=M;break;case r.curs:M=p.pop(),a.cursor(M);break;case r.home:M=C+I/2,F=P+N/2,l[l[0]+1]=Math.round(M),l[l[0]+2]=Math.round(F),l[l[0]+3]=0,i.turtx(l[l[0]+1]),i.turty(l[l[0]+2]),i.turtd(l[l[0]+3]),u.push([l[l[0]+1],l[l[0]+2]]);break;case r.setx:M=p.pop(),l[l[0]+1]=M,i.turtx(M),u.push([l[l[0]+1],l[l[0]+2]]);break;case r.sety:M=p.pop(),l[l[0]+2]=M,i.turty(M),u.push([l[l[0]+1],l[l[0]+2]]);break;case r.setd:M=p.pop()%D,l[l[0]+3]=M,i.turtd(M);break;case r.thik:M=p.pop(),l[l[0]+4]=M,i.turtt(M);break;case r.colr:M=p.pop(),l[l[0]+5]=M,i.turtc(M);break;case r.rgb:M=p.pop(),(M%=50)<=0&&(M+=50),M=o[M-1].value,p.push(M);break;case r.mixc:U=p.pop(),$=p.pop(),F=p.pop();const G=(e,n)=>Math.round((e*$+n*U)/($+U)),Y=e=>Math.floor(e/65536),ee=e=>Math.floor((65280&e)/256),te=e=>255&e,oe=G(Y(M=p.pop()),Y(F)),re=G(ee(M),ee(F)),ae=G(te(M),te(F));p.push(65536*oe+256*re+ae);break;case r.toxy:F=p.pop(),M=p.pop(),l[l[0]+1]=M,l[l[0]+2]=F,i.turtx(M),i.turty(F),u.push([M,F]);break;case r.mvxy:F=p.pop()+l[l[0]+2],M=p.pop()+l[l[0]+1],l[l[0]+1]=M,l[l[0]+2]=F,i.turtx(M),i.turty(F),u.push([M,F]);break;case r.drxy:F=p.pop()+l[l[0]+2],M=p.pop()+l[l[0]+1],E&&(a.line(Z(),_(M),J(F)),T&&(X+=1)),l[l[0]+1]=M,l[l[0]+2]=F,i.turtx(M),i.turty(F),u.push([M,F]);break;case r.fwrd:$=p.pop(),F=l[l[0]+3],F=Math.cos(F*Math.PI/(D/2)),F=-Math.round(F*$),F+=l[l[0]+2],M=l[l[0]+3],M=Math.sin(M*Math.PI/(D/2)),M=Math.round(M*$),M+=l[l[0]+1],E&&(a.line(Z(),_(M),J(F)),T&&(X+=1)),l[l[0]+1]=M,l[l[0]+2]=F,i.turtx(M),i.turty(F),u.push([M,F]);break;case r.back:$=p.pop(),F=l[l[0]+3],F=Math.cos(F*Math.PI/(D/2)),F=Math.round(F*$),F+=l[l[0]+2],M=l[l[0]+3],M=Math.sin(M*Math.PI/(D/2)),M=-Math.round(M*$),M+=l[l[0]+1],E&&(a.line(Z(),_(M),J(F)),T&&(X+=1)),l[l[0]+1]=M,l[l[0]+2]=F,i.turtx(M),i.turty(F),u.push([M,F]);break;case r.left:M=(l[l[0]+3]-p.pop())%D,l[l[0]+3]=M,i.turtd(M);break;case r.rght:M=(l[l[0]+3]+p.pop())%D,l[l[0]+3]=M,i.turtd(M);break;case r.turn:F=p.pop(),M=p.pop(),Math.abs(F)>=Math.abs(M)?($=Math.atan(-M/F),F>0?$+=Math.PI:M<0&&($+=2,$*=Math.PI)):($=Math.atan(F/M),M>0?$+=Math.PI:($+=3,$*=Math.PI),$/=2),$=Math.round($*D/Math.PI/2)%D,l[l[0]+3]=$,i.turtd($);break;case r.rmbr:u.push([l[l[0]+1],l[l[0]+2]]);break;case r.frgt:u.length-=p.pop();break;case r.poly:$=p.pop(),F=u.length,M=$>F?0:F-$,a.poly(Z(),u.slice(M,F).map(ne),!1),T&&(X+=1);break;case r.pfil:$=p.pop(),F=u.length,M=$>F?0:F-$,a.poly(Z(),u.slice(M,F).map(ne),!0),T&&(X+=1);break;case r.circ:M=p.pop(),a.arc(Z(),_(M+C),J(M+P),!1),T&&(X+=1);break;case r.blot:M=p.pop(),a.arc(Z(),_(M+C),J(M+P),!0),T&&(X+=1);break;case r.elps:F=p.pop(),M=p.pop(),a.arc(Z(),_(M+C),J(F+P),!1),T&&(X+=1);break;case r.eblt:F=p.pop(),M=p.pop(),a.arc(Z(),_(M+C),J(F+P),!0),T&&(X+=1);break;case r.box:U=-1===p.pop(),$=p.pop(),F=l[l[0]+2]+p.pop(),M=l[l[0]+1]+p.pop(),a.box(Z(),_(M),J(F),$,U),T&&(X+=1);break;case r.blnk:M=p.pop(),a.blank(M),T&&(X+=1);break;case r.rcol:$=p.pop(),F=p.pop(),M=p.pop(),a.flood(M,F,$,0,!1),T&&(X+=1);break;case r.fill:U=p.pop(),$=p.pop(),F=p.pop(),M=p.pop(),a.flood(M,F,$,U,!0),T&&(X+=1);break;case r.mxin:p.push(Math.pow(2,31)-1)}if(G+=1,x+=1,!n[t])throw e.exports.halt(),q("The program has tried to jump to a line that does not exist. This is either a bug in our compiler, or in your assembled code.");x===n[t].length&&(t+=1,x=0)}setTimeout(H,0,n,t,x,k)},q=e=>{const n=new Error(e);return n.type="Machine",n},W=e=>{const n=Array.from(e).map(e=>e.charCodeAt(0));p.push(f+1),l[f+=1]=e.length,n.forEach(e=>{l[f+=1]=e}),w=Math.max(f,w)},V=e=>{const n=l[e],t=e+1,o=l.slice(t,t+n).reduce((e,n)=>e+String.fromCharCode(n),"");return e+n+1>b&&(f=e+n),o},z=(e,n)=>{n>0&&(l[e]=0,z(e+1,n-1))},K=(e,n,t)=>{t>0&&(l[n]=l[e],K(e+1,n+1,t-1))},j=(e,n,t,o,r,a,i)=>{(i.keyCode||i.charCode)===e&&(p.pop(),p.push(-1),window.clearTimeout(n),H(t,o,r,a))},Q=(e,n,t,o,r,a)=>{const i=a.keyCode||a.charCode;13===i?(W(k),k="",window.clearTimeout(e),H(n,t,o,r)):8===i?k=k.slice(0,-1):k+=String.fromCharCode(i)},Z=()=>({x:_(l[l[0]+1]),y:J(l[l[0]+2]),d:l[l[0]+3],t:ee(l[l[0]+4]),c:l[l[0]+5]}),_=e=>{const n=(e-C)*A/I;return B?Math.round(n)+1:Math.round(n)},J=e=>{const n=(e-P)*L/N;return B?Math.round(n)+1:Math.round(n)},ee=e=>B?2*e:e,ne=([e,n])=>[_(e),J(n)],te=e=>{const{left:n,width:t}=a.bounds(),o=(e-n)*I/t+C;return Math.round(o)},oe=e=>{const{height:n,top:t}=a.bounds(),o=(e-t)*N/n+P;return Math.round(o)}},function(e,n,t){e.exports.language={get:()=>c("language"),set:e=>{if("String"!==s(e))throw i(`language must be a string; ${s(e)} received`);if(-1===r.indexOf(e))throw i(`"${e}" is not a valid language`);l("language",e)}},e.exports.name={get:()=>c(`name-${c("language")}`),set:(e,n)=>{if("String"!==s(e))throw i(`file name must be a string; ${s(e)} received`);l(`name-${n}`,e)}},e.exports.compiled={get:()=>c(`compiled-${c("language")}`),set:(e,n)=>{if("Boolean"!==s(e))throw i(`compiled must be a boolean; ${s(e)} received`);l(`compiled-${n}`,e)}},e.exports.code={get:()=>c(`code-${c("language")}`),set:(e,n)=>{if("String"!==s(e))throw i(`program code must be a string; ${s(e)} received`);l(`code-${n}`,e)}},e.exports.usage={get:()=>c(`usage-${c("language")}`),set:(e,n)=>{if("Array"!==s(e))throw i(`program usage must be an array; ${s(e)} received`);l(`usage-${n}`,e)}},e.exports.pcode={get:()=>c(`pcode-${c("language")}`),set:(e,n)=>{if("Array"!==s(e))throw i(`program pcode must be an array; ${s(e)} received`);l(`pcode-${n}`,e)}},e.exports.file={get:()=>({name:c(`name-${c("language")}`),compiled:c(`compiled-${c("language")}`),code:c(`code-${c("language")}`),usage:c(`usage-${c("language")}`),pcode:c(`pcode-${c("language")}`)}),new:()=>{const e=c("language");return l(`name-${e}`,""),l(`compiled-${e}`,!1),l(`code-${e}`,""),l(`usage-${e}`,[]),l(`pcode-${e}`,[]),!0},set:(e,n)=>{const t=e.split("."),o=t.pop(),r=t.join(".");if("String"!==s(n))throw i("Invalid file contents.");switch(o){case"tgb":l("language","BASIC"),l("name-BASIC",r),l("compiled-BASIC",!1),l("code-BASIC",n.trim()),l("usage-BASIC",[]),l("pcode-BASIC",[]);break;case"tgp":l("language","Pascal"),l("name-Pascal",r),l("compiled-Pascal",!1),l("code-Pascal",n.trim()),l("usage-Pascal",[]),l("pcode-Pascal",[]);break;case"tgy":l("language","Python"),l("name-Python",r),l("compiled-Python",!1),l("code-Python",n.trim()),l("usage-Python",[]),l("pcode-Python",[]);break;case"tgx":try{const e=JSON.parse(n);l("language",e.language),l(`name-${e.language}`,e.name),l(`compiled-${e.language}`,!0),l(`code-${e.language}`,e.code.trim()),l(`usage-${e.language}`,e.usage),l(`pcode-${e.language}`,e.pcode)}catch(e){throw i("Invalid TGX file.")}break;default:throw i("Invalid file type.")}}},e.exports.example={set:e=>(r.forEach(n=>{l(`name-${n}`,o.names[e]),l(`compiled-${n}`,!1),l(`code-${n}`,a[n][e].trim()),l(`usage-${n}`,[]),l(`pcode-${n}`,[])}),!0)},e.exports.assembler={get:()=>c("assembler"),toggle:()=>l("assembler",!c("assembler"))},e.exports.decimal={get:()=>c("decimal"),toggle:()=>l("decimal",!c("decimal"))},e.exports.showCanvas={get:()=>c("show-canvas"),toggle:()=>l("show-canvas",!c("show-canvas"))},e.exports.showOutput={get:()=>c("show-output"),toggle:()=>l("show-output",!c("show-output"))},e.exports.showMemory={get:()=>c("show-memory"),toggle:()=>l("show-memory",!c("show-memory"))},e.exports.drawCountMax={get:()=>c("draw-count-max"),set:e=>l("draw-count-max",e)},e.exports.codeCountMax={get:()=>c("code-count-max"),set:e=>l("code-count-max",e)},e.exports.smallSize={get:()=>c("small-size"),set:e=>l("small-size",e)},e.exports.stackSize={get:()=>c("stack-size"),set:e=>l("stack-size",e)},e.exports.machineOptions={get:()=>({showCanvas:c("show-canvas"),showOutput:c("show-output"),showMemory:c("show-memory"),drawCountMax:c("draw-count-max"),codeCountMax:c("code-count-max"),smallSize:c("small-size"),stackSize:c("stack-size")}),reset:()=>{l("draw-count-max",4),l("code-count-max",1e5),l("small-size",60),l("stack-size",2e4)}},e.exports.group={get:()=>c("group"),set:e=>l("group",e)},e.exports.simple={get:()=>c("simple"),toggle:()=>l("simple",!c("simple"))},e.exports.intermediate={get:()=>c("intermediate"),toggle:()=>l("intermediate",!c("intermediate"))},e.exports.advanced={get:()=>c("advanced"),toggle:()=>l("advanced",!c("advanced"))};const{examples:o,languages:r}=t(2),a=t(44),i=e=>{const n=new Error(e);return n.type="System",n},s=e=>Object.prototype.toString.call(e).slice(8,-1),l=(e,n)=>window.localStorage.setItem(e,JSON.stringify(n)),c=e=>JSON.parse(window.localStorage.getItem(e));l("language",c("language")||"Pascal"),r.forEach(e=>{l(`name-${e}`,c(`name-${e}`)||""),l(`compiled-${e}`,c(`compiled-${e}`)||!1),l(`code-${e}`,c(`code-${e}`)||""),l(`usage-${e}`,c(`usage-${e}`)||[]),l(`pcode-${e}`,c(`pcode-${e}`)||[])}),l("assembler",c("assembler")||!0),l("decimal",c("decimal")||!0),l("show-canvas",c("show-canvas")||!0),l("show-output",c("show-output")||!1),l("show-memory",c("show-memory")||!0),l("draw-count-max",c("draw-count-max")||4),l("code-count-max",c("code-count-max")||1e5),l("small-size",c("small-size")||60),l("stack-size",c("stack-size")||2e4),l("group",c("group")||0),l("simple",c("simple")||!0),l("intermediate",c("intermediate")||!1),l("advanced",c("advanced")||!1)},function(e,n,t){e.exports={BASIC:t(45),Pascal:t(120),Python:t(195)}},function(e,n,t){e.exports={AimCannon:t(46),AskInput:t(47),AutoCannon:t(48),Automata:t(49),Balls3D:t(50),BarnsleyColour:t(51),BarnsleyIFS:t(52),BouncingBall:t(53),BrownianMotion:t(54),Cheetahs:t(55),Circles:t(56),Clock:t(57),ColourSpiral:t(58),CycleColours:t(59),Diffusion:t(60),DigitalClock:t(61),Disease:t(62),DragonColour:t(63),DragonIFS:t(64),DrawPause:t(65),FiveTurtles:t(66),Flashlights:t(67),Flocking:t(68),ForLoop:t(69),GameOfLife:t(70),GravitySteps:t(71),IFSBackground:t(72),Interference:t(73),IteratedPD:t(74),KnightsTour:t(75),Launch:t(76),LifeStart:t(77),Logistic:t(78),LogisticSpider:t(79),Mandelbrot:t(80),MandelbrotMini:t(81),MandelbrotMiniSpectrum:t(82),MandelbrotSpectrum:t(83),MathFunctions:t(84),MovingBall:t(85),MultiBounce:t(86),NestedLoops:t(87),Nim:t(88),NoughtsAndCrosses:t(89),OlympicRings1:t(90),OlympicRings2:t(91),PaintApp:t(92),ParameterProcedure:t(93),PolygonRings:t(94),Polygons:t(95),Quine:t(96),RefParams:t(97),Schelling:t(98),SexRatio:t(99),Shoot:t(100),Sierpinski:t(101),SierpinskiColour:t(102),SierpinskiDots:t(103),SierpinskiIFS:t(104),SimpleDraw:t(105),SimpleProcedure:t(106),SnakeGame:t(107),SolarSystem:t(108),Stars:t(109),StringFunctions:t(110),ThePlough:t(111),TreeIFS:t(112),Triangles:t(113),TrigonometricGraphs:t(114),TurtleBounce:t(115),TurtleMove:t(116),TwoSlits:t(117),WaveSuperposer:t(118),YouAreHere:t(119)}},function(e,n){e.exports='REM AimCannon\n\nGUNLENGTH% = 1000\nDISTANCECOL% = GREEN\nTIMECOL% = RED\nCANVAS(0, 0, 10500, 10000)\nPROCgraphaxes\nTURTD% = 45\nTHICKNESS(20)\nREPEAT\n  PROCaim\n  WRITE("Elevation: " + STR$(90 - TURTD%))\n  PROCfire(COS(90 - TURTD%, 1, 96), SIN(90 - TURTD%, 1, -96), 1, 9950)\n  WRITE("  Distance: " + STR$(TURTX%))\n  WRITELN("  Time: " + STR$(steps%))\n  PROCplot(90 - TURTD%, TURTX%, DISTANCECOL%)\n  PROCplot(90 - TURTD%, steps% * 50, TIMECOL%)\nUNTIL 0 = 1\nEND\n\nDEF PROCgraphaxes\n  THICKNESS(5)\n  SETXY(9700, 600)\n  DRAWXY(0, 3900)\n  DRAWXY(-9000, 0) REM x axis 700 to 9700\n  DRAWXY(0, -3900) REM y axis 4500 to 600\n  FOR n% = 0 TO 90\n    IF n% MOD 5 = 0 THEN\n      SETXY(650 + n% * 100, 4600)\n      PRINT(STR$(n%), 2, 16)\n    ENDIF\n  NEXT\n  FOR n% = 0 TO 9\n    SETXY(100, 4350 - n% * 400)\n    PRINT(STR$(n% * 1000), 2, 16)\n  NEXT\n  FOR n% = 0 TO 9\n    SETXY(9900, 4380 - n% * 400)\n    PRINT(STR$(n% * 20), 2, 16)\n  NEXT\n  SETXY(4000, 4900)\n  PRINT("Angle of elevation", 2, 24)\n  COLOUR(DISTANCECOL%)\n  SETXY(0, 100)\n  PRINT("Distance", 2, 24)\n  COLOUR(TIMECOL%)\n  SETXY(9600, 100)\n  PRINT("Time", 2, 24)\nENDPROC\n\nDEF PROCplot(x%, y%, col%)\n  SETXY(700 + x% * 100, 4500 - y% * 2 / 5)\n  COLOUR(col%)\n  BLOT(40)\nENDPROC\n\nDEF PROCaim\n  REPEAT\n    NOUPDATE\n    SETXY(0, 10000)\n    COLOUR(CREAM)\n    BLOT(1600)\n    COLOUR(YELLOWGREEN)\n    BLOT(1400)\n    COLOUR(MAROON)\n    SETXY(250, 9750)\n    BLOT(250)\n    FORWARD(GUNLENGTH%)\n    SETXY(250, 9750)\n    COLOUR(RED)\n    BLOT(100)\n    UPDATE\n    REPEAT\n    UNTIL (?LMOUSE > 0)\n    IF PIXCOL(?MOUSEX, ?MOUSEY) = CREAM THEN\n      TURNXY(?MOUSEX - 250, ?MOUSEY - 9750)\n    ENDIF\n  UNTIL PIXCOL(?MOUSEX, ?MOUSEY) = RED\nENDPROC\n\nDEF PROCfire(xvel%, yvel%, gravity%, floor%)\n  SETXY(250, 9750)\n  steps% = 0\n  REPEAT\n    INC(steps%)\n    IF PIXCOL(TURTX%, TURTY%) = BLACK THEN\n      COLOUR(WHITE)\n      BLOT(80)\n    ENDIF\n    MOVEXY(xvel%, yvel%)\n    yvel% = yvel% + gravity%\n    IF TURTY% > floor% THEN TURTY% = floor%\n    IF (PIXCOL(TURTX%, TURTY%) = WHITE) OR (TURTY% = floor%) THEN\n      COLOUR(BLACK)\n      BLOT(75)\n    ENDIF\n    UPDATE\n    PAUSE(10)\n    NOUPDATE\n  UNTIL TURTY% = floor%\nENDPROC\n'},function(e,n){e.exports='REM AskInput\n\nWRITELN("What is your name?")\ns$ = GETLINE$\nWRITELN("")\nWRITELN("Hello, " + s$ + ",")\nWRITELN("How are you?")\nEND\n'},function(e,n){e.exports='REM AutoCannon\n\nGUNLENGTH% = 1000\nDISTANCECOL% = GREEN\nTIMECOL% = RED\nCANVAS(0, 0, 10500, 10000)\nPROCgraphaxes\nTURTD% = 45\nTHICKNESS(20)\nFOR n% = 0 TO 90\n  PROCaim(n%)\n  WRITE("Elevation: " + STR$(90 - TURTD%))\n  PROCfire(COS(90 - TURTD%, 1, 96), SIN(90 - TURTD%, 1, -96), 1, 9950)\n  WRITE("  Distance: " + STR$(TURTX%))\n  WRITELN("  Time: " + STR$(steps%))\n  PROCplot(90 - TURTD%, TURTX%, DISTANCECOL%)\n  PROCplot(90 - TURTD%, steps% * 50, TIMECOL%)\nNEXT\nEND\n\nDEF PROCgraphaxes\n  THICKNESS(5)\n  SETXY(9700, 600)\n  DRAWXY(0, 3900)\n  DRAWXY(-9000, 0) REM x axis 700 to 9700\n  DRAWXY(0, -3900) REM y axis 4500 to 600\n  FOR n% = 0 TO 90\n    IF n% MOD 5 = 0 THEN\n      SETXY(650 + n% * 100, 4600)\n      PRINT(STR$(n%), 2, 16)\n    ENDIF\n  NEXT\n  FOR n% = 0 TO 9\n    SETXY(100, 4350 - n% * 400)\n    PRINT(STR$(n% * 1000), 2, 16)\n  NEXT\n  FOR n% = 0 TO 9\n    SETXY(9900, 4380 - n% * 400)\n    PRINT(STR$(n% * 20), 2, 16)\n  NEXT\n  SETXY(4000, 4900)\n  PRINT("Angle of elevation", 2, 24)\n  COLOUR(DISTANCECOL%)\n  SETXY(0, 100)\n  PRINT("Distance", 2, 24)\n  COLOUR(TIMECOL%)\n  SETXY(9600, 100)\n  PRINT("Time", 2, 24)\nENDPROC\n\nDEF PROCplot(x%, y%, col%)\n  SETXY(700 + x% * 100, 4500 - y% * 2 / 5)\n  COLOUR(col%)\n  BLOT(40)\nENDPROC\n\nDEF PROCaim(elevation%)\n  NOUPDATE\n  SETXY(0, 10000)\n  COLOUR(CREAM)\n  BLOT(1600)\n  COLOUR(YELLOWGREEN)\n  BLOT(1400)\n  COLOUR(MAROON)\n  SETXY(250, 9750)\n  BLOT(250)\n  DIRECTION(90 - elevation%)\n  FORWARD(GUNLENGTH%)\n  SETXY(250, 9750)\n  COLOUR(RED)\n  BLOT(100)\n  UPDATE\nENDPROC\n\nDEF PROCfire(xvel%, yvel%, gravity%, floor%)\n  SETXY(250, 9750)\n  steps% = 0\n  REPEAT\n    INC(steps%)\n    IF PIXCOL(TURTX%, TURTY%) = BLACK THEN\n      COLOUR(WHITE)\n      BLOT(80)\n    ENDIF\n    MOVEXY(xvel%, yvel%)\n    yvel% = yvel% + gravity%\n    IF TURTY% > floor% THEN TURTY% = floor%\n    IF (PIXCOL(TURTX%, TURTY%) = WHITE) OR (TURTY% = floor%) THEN\n      COLOUR(BLACK)\n      BLOT(75)\n    ENDIF\n    UPDATE\n    PAUSE(10)\n    NOUPDATE\n  UNTIL TURTY% = floor%\nENDPROC\n'},function(e,n){e.exports="REM Automata\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM Balls3D\n\nSETXY(250, 250)\nCOLOUR(&00FFFF)\nFOR count% = 240 TO 1 STEP -1\n  BLOT(count%)\n  TURTC% = TURTC% + &10000\nNEXT\nRIGHT(60)\nSETXY(750, 250)\nCOLOUR(&D2691E)\nFOR count% = 40 TO 1 STEP -1\n  BLOT(count% * 6)\n  FORWARD(3)\n  TURTC% = TURTC% + &10102\nNEXT\nSETXY(250, 750)\nCOLOUR(&D2691E)\nFOR count% = 40 TO 1 STEP -1\n  BLOT(count% * 6)\n  FORWARD(3)\n  TURTC% = TURTC% + &10102\nNEXT\nSETXY(750, 750)\nCOLOUR(&FFA500)\nFOR count% = 80 TO 1 STEP -1\n  BLOT(count% * 3)\n  FORWARD(2)\n  TURTC% = TURTC% + &101\nNEXT\nEND\n"},function(e,n){e.exports="REM BarnsleyColour\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM BarnsleyIFS\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM BouncingBall\n\nx% = 100\ny% = 700\nxvel% = 8\nyvel% = -4\nWHILE 0 < 1\n  NOUPDATE\n  COLOUR(WHITE)\n  BLOT(51)\n  x% = x% + xvel%\n  y% = y% + yvel%\n  SETXY(x%, y%)\n  COLOUR(RED)\n  BLOT(50)\n  UPDATE\n  PAUSE(5)\n  IF (x% < 50) OR (x% > 949) THEN\n    xvel% = -xvel%\n  ENDIF\n  IF (y% < 50) OR (y% > 949) THEN\n    yvel% = -yvel%\n  ENDIF\nENDWHILE\nEND\n"},function(e,n){e.exports="REM BrownianMotion\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM Cheetahs\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM Circles\n\nTHICKNESS(6)\nPENUP\nBLANK(BLACK)\nCOLOUR(ORANGE)\nFOR count% = 1 TO 36\n  FORWARD(200)\n  CIRCLE(200)\n  BACK(200)\n  RIGHT(10)\n  PAUSE(25)\nNEXT\nEND\n"},function(e,n){e.exports="REM Clock\n\nTHICKNESS(10)\nCIRCLE(400)\nHours% = 0\nMinutes% = 0\nREPEAT\n  REPEAT\n    PROCshowhands\n    PAUSE(600)\n    INC(Minutes%)\n  UNTIL Minutes% = 60\n  INC(Hours%)\n  Minutes% = 0\nUNTIL Hours% = 12\nPROCshowhands\nEND\n\nDEF PROCshowhands\n  COLOUR(WHITE)\n  BLOT(360)\n  COLOUR(RED)\n  DIRECTION(Hours% * 30)\n  THICKNESS(10)\n  FORWARD(250)\n  BACK(250)\n  DIRECTION(Minutes% * 6)\n  THICKNESS(6)\n  FORWARD(350)\n  BACK(350)\nENDPROC\n"},function(e,n){e.exports="REM ColourSpiral\n\nBLANK(BLACK)\nFORWARD(15)\nTHICKNESS(27)\nlength% = 20\nREPEAT\n  RNDCOL(40)\n  PROClineturn\n  length% = length% + 10\nUNTIL length% > 500\nEND\n\nDEF PROClineturn\n  FORWARD(length%)\n  RIGHT(60)\nENDPROC\n"},function(e,n){e.exports="REM CycleColours\n\nBLANK(BLACK)\ncolinc% = RND(5) - 1\ncolcode% = RND(20)\nCOLOUR(RGB(colcode%))\nlength% = 0\nTHICKNESS(16)\nREPEAT\n  colcode% = (colcode% + colinc%) MOD 20 + 1\n  COLOUR(RGB(colcode%))\n  length% = length% + 1\n  FORWARD(length%)\n  RIGHT(30)\nUNTIL length% > 250\nEND\n"},function(e,n){e.exports="REM Diffusion\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports='REM DigitalClock\n\nBLANK(LIGHTGREEN)\nSETXY(250, 390)\nCOLOUR(MAROON)\nTHICKNESS(10)\nBOX(500, 210, LIGHTBROWN, TRUE)\nCOLOUR(BLACK)\nHours% = 0\nMinutes% = 0\nWHILE Hours% < 12\n  PROCshowtime\n  PAUSE(600)\n  INC(Minutes%)\n  IF Minutes% = 60 THEN\n    INC(Hours%)\n    Minutes% = 0\n  ENDIF\nENDWHILE\nPROCshowtime\nEND\n\nDEF PROCshowtime\n  LOCAL hstring$, mstring$\n  SETXY(300, 430)\n  BOX(400, 130, WHITE, FALSE)\n  IF Hours% < 10 THEN\n    hstring$ = "0" + STR$(Hours%)\n  ELSE\n    hstring$ = STR$(Hours%)\n  ENDIF\n  IF Minutes% < 10 THEN\n    mstring$ = "0" + STR$(Minutes%)\n  ELSE\n    mstring$ = STR$(Minutes%)\n  ENDIF\n  PRINT(hstring$ + ":" + mstring$, 21, 100)\nENDPROC\n'},function(e,n){e.exports="REM Disease\n\nWIDTH% = 100\nHEIGHT% = 100\nSUSCEPTIBLE% = LIGHTGREEN\nINFECTED% = RED\nRECOVERED% = BLUE\nSTARTRADIUS% = 10\nINFECTPROB% = 1\nIMMUNEPROB% = 2\nRECOVERPROB% = 15\nCANVAS(0, 0, WIDTH%, HEIGHT%)\nRESOLUTION(WIDTH%, HEIGHT%)\nnuminfected% = 0\nNOUPDATE\nFOR x% = 0 TO WIDTH% - 1\n  FOR y% = 0 TO HEIGHT% - 1\n    IF (RND(100) - 1 < INFECTPROB%) AND (HYPOT(x% - WIDTH% / 2, y% - HEIGHT% / 2, 1) <= STARTRADIUS%) THEN\n      PROCinfect(x%, y%)\n    ELSE\n      IF RND(100) - 1 < IMMUNEPROB% THEN\n        PIXSET(x%, y%, RECOVERED%)\n      ELSE\n        PIXSET(x%, y%, SUSCEPTIBLE%)\n      ENDIF\n    ENDIF\n  NEXT\nNEXT\nUPDATE\nREPEAT\n  x% = RND(WIDTH%) - 1\n  y% = RND(HEIGHT%) - 1\n  IF PIXCOL(x%, y%) = INFECTED% THEN\n    IF RND(100) - 1 < RECOVERPROB% THEN\n      PIXSET(x%, y%, RECOVERED%)\n      DEC(numinfected%)\n    ELSE\n      n% = (RND(4) - 1) * 2 + 1\n      x% = x% + n% DIV 3 - 1\n      y% = y% + n% MOD 3 - 1\n      IF PIXCOL(x%, y%) = SUSCEPTIBLE% THEN PROCinfect(x%, y%)\n    ENDIF\n  ENDIF\nUNTIL numinfected% = 0\nEND\n\nDEF PROCinfect(x%, y%)\n  PIXSET(x%, y%, INFECTED%)\n  INC(numinfected%)\nENDPROC\n"},function(e,n){e.exports="REM DragonColour\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM DragonIFS\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM DrawPause\n\nCOLOUR(GREEN)\nBLOT(100)\nPAUSE(1000)\nCOLOUR(RED)\nFORWARD(450)\nPAUSE(1000)\nRIGHT(90)\nTHICKNESS(9)\nCOLOUR(BLUE)\nPAUSE(1000)\nFORWARD(300)\nEND\n"},function(e,n){e.exports="REM FiveTurtles\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM Flashlights\n\nBLOT(1000)\nTHICKNESS(8)\nREPEAT\n  SETX(RND(8) * 111)\n  SETY(RND(8) * 111)\n  PROCdrawit(RND(2) = 1)\nUNTIL FALSE\nEND\n\nDEF PROCdrawit(blot%)\n  IF blot% THEN\n    RNDCOL(10)\n    BLOT(25)\n  ELSE\n    COLOUR(BLACK)\n    BLOT(30)\n    RNDCOL(10)\n    CIRCLE(25)\n  ENDIF\nENDPROC\n"},function(e,n){e.exports="REM Flocking\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM ForLoop\n\nFOR count% = 1 TO 200\n  FORWARD(count% DIV 3)\n  RIGHT(5)\n  COLOUR(RED)\n  BLOT(200)\n  COLOUR(BLACK)\n  CIRCLE(200)\nNEXT\nEND\n"},function(e,n){e.exports="REM GameOfLife\n\nWIDTH% = 32\nHEIGHT% = 32\nCANVAS(0, 0, WIDTH%, HEIGHT%)\nRESOLUTION(WIDTH%, HEIGHT%)\nFOR x% = 0 TO WIDTH% - 1\n  FOR y% = 0 TO HEIGHT% - 1\n    IF RND(7) = 1 THEN PIXSET(x%, y%, BLACK)\n  NEXT\nNEXT\nWHILE ?KEY <> \\ESCAPE\n  FOR x% = 0 TO WIDTH% - 1\n    FOR y% = 0 TO HEIGHT% - 1\n      dn% = 0\n      FOR i% = -1 TO 1\n        FOR j% = -1 TO 1\n          dn% = dn% + PIXCOL((x% + i% + WIDTH%) MOD WIDTH%, (y% + j% + HEIGHT%) MOD HEIGHT%) AND 1\n        NEXT\n      NEXT\n      IF ((PIXCOL(x%, y%) AND 1 = 0) AND ((dn% < 5) OR (dn% > 6))) OR ((PIXCOL(x%, y%) AND 1 = 1) AND (dn% = 6)) THEN\n        PIXSET(x%, y%, PIXCOL(x%, y%) EOR 2)\n      ENDIF\n    NEXT\n  NEXT\n  FOR x% = 0 TO WIDTH%\n    FOR y% = 0 TO HEIGHT%\n      IF (PIXCOL(x%, y%) AND 3) MOD 3 <> 0 THEN\n        PIXSET(x%, y%, PIXCOL(x%, y%) EOR &FFFFFD)\n      ENDIF\n    NEXT\n  NEXT\nENDWHILE\nEND\n"},function(e,n){e.exports="REM GravitySteps\n\nPROCsteps(10)\nSETXY(950, 75)\nREPEAT\n  PROCthrowball(-2, -22, 1, TURTY% + 100)\nUNTIL TURTX% < 75\nFOR bounce% = 1 TO 10\n  PROCthrowball(0, bounce% * 2 - 20, 1, TURTY%)\nNEXT\nEND\n\nDEF PROCsteps(s%)\n  LOCAL size%, count%\n  size% = 1000 / s%\n  SETXY(0, 1000)\n  THICKNESS(1)\n  FOR count% = 1 TO s% * 2\n    IF count% MOD 2 = 0 THEN MOVEXY(0, -size%) ELSE MOVEXY(size%, 0)\n  NEXT\n  MOVEXY(0, s% * size%)\n  MOVEXY(-s% * size%, 0)\n  COLOUR(BLUE)\n  POLYGON(s% * 2 + 2)\nENDPROC\n\nDEF PROCthrowball(xvel%, yvel%, gravity%, floor%)\n  REPEAT\n    COLOUR(WHITE)\n    BLOT(25)\n    MOVEXY(xvel%, yvel%)\n    yvel% = yvel% + gravity%\n    IF TURTY% > floor% THEN TURTY% = floor%\n    COLOUR(RED)\n    BLOT(24)\n    UPDATE\n    PAUSE(10)\n    NOUPDATE\n  UNTIL TURTY% = floor%\nENDPROC\n"},function(e,n){e.exports="REM IFSBackground\n\nXLEFT% = 0\nXRIGHT% = 999\nYTOP% = 0\nYBOTTOM% = 999\nGRIDSCALE% = 5\nGRIDTHICK% = 64\nCANVAS(XLEFT%, YTOP%, XRIGHT% - XLEFT% + 1, YBOTTOM% - YTOP% + 1)\nRESOLUTION(XRIGHT% - XLEFT% + 1, YBOTTOM% - YTOP% + 1)\nPROCBackground(6)\nEND\n\nDEF PROCbackground(rad%)\n  LOCAL x%, y%, cx%, cy%, r%, g%, b%\n  THICKNESS(GRIDTHICK%)\n  COLOUR(DARKGREY)\n  FOR x% = 1 TO GRIDSCALE% - 1\n    SETXY(XLEFT% + DIVMULT(XRIGHT% - XLEFT%, GRIDSCALE%, x%), YTOP%)\n    DRAWXY(0, YBOTTOM% - YTOP%)\n  NEXT\n  FOR y% = 1 TO GRIDSCALE% - 1\n    SETXY(XLEFT% + GRIDTHICK% / 2, YTOP% + DIVMULT(YBOTTOM% - YTOP%, GRIDSCALE%, y%))\n    DRAWXY(XRIGHT% - XLEFT% - GRIDTHICK%, 0)\n  NEXT\n  COLOUR(BLACK)\n  SETXY(XLEFT%, YTOP%)\n  DRAWXY(XRIGHT% - XLEFT%, 0)\n  DRAWXY(0, YBOTTOM% - YTOP%)\n  DRAWXY(XLEFT% - XRIGHT%, 0)\n  DRAWXY(0, YTOP% - YBOTTOM%)\n  FOR x% = 0 TO GRIDSCALE% - 1\n    FOR y% = 0 TO GRIDSCALE% - 1\n      cx% = XLEFT% + DIVMULT(XRIGHT% - XLEFT%, GRIDSCALE%, x%) + GRIDTHICK%\n      cy% = YTOP% + DIVMULT(YBOTTOM% - YTOP%, GRIDSCALE%, y%) + GRIDTHICK%\n      r% = DIVMULT(255, GRIDSCALE% - 1, x%)\n      g% = DIVMULT(255, GRIDSCALE% - 1 , y%)\n      b% = DIVMULT(255, 2 * GRIDSCALE% - 2, 2 * GRIDSCALE% - 2 - x% - y%)\n      RECOLOUR(cx%, cy%, (r% * &10000) + (g% * &100) + (b% * &1))\n    NEXT\n  NEXT\nENDPROC\n"},function(e,n){e.exports="REM Interference\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM IteratedPD\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM KnightsTour\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports='REM Launch\n\nEARTHRADIUS% = 6371000 REM m\nEARTHGM% = 398600442 REM km3 / s2 * 1000\nINITDIRECTION% = 2000 REM seconds of arc\nINITTHRUST% = 20000 REM milliN per kg\nTHRUSTTIME% = 500\nANGLEPRECISION% = 1296000 REM seconds of arc\nCANVAS(-10000, -10000, 20000, 20000)\nANGLES(ANGLEPRECISION%)\nx% = 0\ny% = -EARTHRADIUS% REM metres\nxvel% = 0\nyvel% = 0\nd% = INITDIRECTION%\nt% = 0\nprevdiff% = 1 REM so first apogee will report\nthrust% = INITTHRUST%\nREPEAT\n  PROCdrawrocket\n  prevdist% = dist%\n  dist% = HYPOT(x%, y% ,1)\n  IF (dist% - prevdist%) * prevdiff% <= 0 THEN PROCreport\n  prevdiff% = dist% - prevdist%\n  gravity% = DIVMULT(EARTHGM%, DIVMULT(dist%, 1000000, dist%), 1000)\n  xgravity% = DIVMULT(gravity%, dist%, -x%)\n  ygravity% = DIVMULT(gravity%, dist%, -y%)\n  xthrust% = SIN(d%, 1, thrust%)\n  ythrust% = -COS(d%, 1, thrust%)\n  xvel% = xvel% + xgravity% + xthrust%\n  yvel% = yvel% + ygravity% + ythrust%\n  x% = x% + xvel% / 1000\n  y% = y% + yvel% / 1000\n  REM report\n  IF yvel% > 0 THEN\n    d% = ANGLEPRECISION% / 2 - ATN(xvel%, yvel%, 1)\n  ELSE\n    d% = ATN(xvel%, -yvel%, 1)\n  ENDIF\n  INC(t%)\n  IF t% = THRUSTTIME% THEN thrust% = 0\nUNTIL (0 = 1) OR (dist% < EARTHRADIUS%) OR (dist% > 40000000)\nIF dist% < EARTHRADIUS% THEN\n  COLOUR(YELLOW)\n  FOR explosion% = 100 TO 200\n    BLOT(explosion%)\n    PAUSE(3)\n  NEXT\n  COLOUR(BLACK)\n  BLOT(200)\nENDIF\nEND\n\nDEF PROCdrawrocket\n  NOUPDATE\n  BLANK(BLACK)\n  COLOUR(TEAL)\n  SETXY(0, 0)\n  BLOT(EARTHRADIUS% / 1000)\n  SETXY(x% / 1000, y% / 1000)\n  DIRECTION(d%)\n  THICKNESS(4)\n  COLOUR(SILVER)\n  FORWARD(200)\n  BACK(200)\n  IF thrust% > 0 THEN\n    THICKNESS(8)\n    COLOUR(YELLOW)\n    BACK(200)\n    FORWARD(200)\n  ENDIF\n  UPDATE\nENDPROC\n\nDEF PROCreport\n  WRITELN("")\n  WRITELN("TIME = " + STR$(t%))\n  WRITELN(" Xposition = " + STR$(x%) + " metres")\n  WRITELN(" Yposition = " + STR$(y%) + " metres")\n  WRITELN(" Height = " + QSTR$(dist% - EARTHRADIUS%, 1000, 2) + " km")\n  WRITELN(" Direction = " + QSTR$(d%, 3600, 1) + " degrees")\n  WRITELN(" Thrust = " + QSTR$(thrust%, 1000, 1) + " newtons per kg")\n  WRITELN("  Xthrust = " + QSTR$(xthrust%, 1000, 1) + " newtons per kg")\n  WRITELN("  Ythrust = " + QSTR$(ythrust%, 1000, 1) + " newtons per kg")\n  WRITELN(" Gravity = " + QSTR$(gravity%, 1000, 1) + " newtons per kg")\n  WRITELN("  Xgravity = " + QSTR$(xgravity%, 1000, 1) + " newtons per kg")\n  WRITELN("  Ygravity = " + QSTR$(ygravity%, 1000, 1) + " newtons per kg")\n  WRITELN(" Xvelocity = " + QSTR$(xvel%, 1000, 1) + " metres per s")\n  WRITELN(" Yvelocity = " + QSTR$(yvel%, 1000, 1) + " metres per s")\nENDPROC\n'},function(e,n){e.exports="REM LifeStart\n\nWIDTH% = 32\nHEIGHT% = 32\nCANVAS(0, 0, WIDTH%, HEIGHT%)\nRESOLUTION(WIDTH%, HEIGHT%)\nFOR x% = 0 TO WIDTH% - 1\n  FOR y% = 0 TO HEIGHT% - 1\n    IF RND(7) = 1 THEN\n      PIXSET(x%, y%, BLACK)\n    ELSE\n      PIXSET(x%, y%, WHITE)\n    ENDIF\n  NEXT\nNEXT\nEND\n"},function(e,n){e.exports='REM Logistic\n\nMAXPOP% = 100000\nMAXGEN% = 100\nLMARGIN% = 105\nRMARGIN% = 40\nTMARGIN% = 150\nBMARGIN% = 200\nOUTPUT% = FALSE\nCANVAS(-LMARGIN%, -TMARGIN%, 1000 + LMARGIN% + RMARGIN%, 1000 + TMARGIN% + BMARGIN%)\nRESOLUTION(1000 + LMARGIN% + RMARGIN%, 1000 + TMARGIN% + BMARGIN%)\nTHICKNESS(3)\nr% = 30\nREPEAT\n  NOUPDATE\n  BLANK(WHITE)\n  PROCaxes\n  PROCmenu\n  COLOUR(BLUE)\n  pop% = RND(MAXPOP% - 9) + 9\n  IF OUTPUT% THEN\n    WRITELN("")\n    WRITELN("r = " + QSTR$(r%, 10, 1) + " Initial population = " + STR$(pop%))\n  ENDIF\n  SETXY(0, 1000 - DIVMULT(pop%, MAXPOP%, 1000))\n  FOR gen% = 1 TO MAXGEN%\n    pop% = DIVMULT(pop%, 10 * MAXPOP%, r% * (MAXPOP% - pop%))\n    SETXY(DIVMULT(gen%, MAXGEN%, 1000), 1000 - DIVMULT(pop%, MAXPOP%, 1000))\n    POLYLINE(2)\n    IF OUTPUT% THEN\n      WRITE(STR$(pop%) + " ")\n      IF gen% MOD 10 = 0 THEN WRITELN("")\n    ENDIF\n  NEXT\n  HEAPRESET\n  UPDATE\n  REPEAT\n  UNTIL (?LMOUSE > 0) AND (?CLICKY < (100 - TMARGIN%)) AND (?CLICKX >= 130) AND (?CLICKX < 1030)\n  r% = ((?CLICKX - 130) DIV 90) + ((?CLICKY + TMARGIN% + 100) DIV 50) * 10 + 1\nUNTIL 0 = 1\nEND\n\nDEF PROCaxes\n  LOCAL i%\n  COLOUR(BLACK)\n  FOR i% = 0 TO 10\n    SETXY(i% * 100 - 25, 1000)\n    PRINT(STR$(i% * MAXGEN% / 10), 4, 20)\n  NEXT\n  FOR i% = 1 TO 10\n    SETXY(-LMARGIN% + 5, 1000 - i% * 100 - 20)\n    PRINT(STR$(i% * MAXPOP% / 10), 4, 20)\n  NEXT\n  SETXY(0, 0)\n  DRAWXY(0, 1000)\n  DRAWXY(1000, 0)\n  COLOUR(RED)\n  SETXY(0, 1060)\n  PRINT("Population over " + STR$(MAXGEN%) + " generations, where P (population/" + STR$(MAXPOP%) + ")", 4, 25)\n  SETXY(0, 1110)\n  PRINT("is determined by the logistic equation P\' = rP(1 - P), with r = " + QSTR$(r%, 10, 1), 4, 25)\nENDPROC\n\nDEF PROCmenu\n  LOCAL i%\n  COLOUR(BLACK)\n  SETXY(10, -TMARGIN% + 20)\n  PRINT("Set r:", 4, 25)\n  FOR i% = 21 TO 40\n    SETXY(((i% - 1) MOD 10) * 90 + 130,((i% - 1) DIV 10) * 50 - 100 - TMARGIN%)\n    IF i% = r% THEN\n      BOX(90, 50, RED, TRUE)\n    ELSE\n      BOX(90, 50, CREAM, TRUE)\n    ENDIF\n    PRINT("  " + QSTR$(i%, 10, 1), 4, 25)\n  NEXT\nENDPROC\n'},function(e,n){e.exports='REM LogisticSpider\n\nMAXPOP% = 100000\nMAXGEN% = 100\nLMARGIN% = 60\nRMARGIN% = 40\nTMARGIN% = 150\nBMARGIN% = 200\nOUTPUT% = TRUE\nCANVAS(-LMARGIN%, -TMARGIN%, 1000 + LMARGIN% + RMARGIN%, 1000 + TMARGIN% + BMARGIN%)\nRESOLUTION(1000 + LMARGIN% + RMARGIN%, 1000 + TMARGIN% + BMARGIN%)\nTHICKNESS(3)\nr% = 30\nREPEAT\n  NOUPDATE\n  BLANK(WHITE)\n  PROCaxes\n  PROCmenu\n  PROCcurve\n  pop% = RND(MAXPOP% - 9) + 9\n  IF OUTPUT% THEN\n    WRITELN("")\n    WRITELN("r = " + QSTR$(r%, 10, 1) + " Initial population = " + STR$(pop%))\n  ENDIF\n  SETXY(DIVMULT(pop%, MAXPOP%, 1000), 1000)\n  FOR gen% = 1 TO MAXGEN%\n    pop% = DIVMULT(pop%, 10 * MAXPOP%, r% * (MAXPOP% - pop%))\n    COLOUR(MIXCOLS(LIGHTGREEN, GREEN, MAXGEN% - gen%, gen%))\n    DRAWXY(0, 1000 - DIVMULT(pop%, MAXPOP%, 1000) - TURTY%)\n    DRAWXY(DIVMULT(pop%, MAXPOP%, 1000) - TURTX%, 0)\n    IF OUTPUT% THEN\n      WRITE(STR$(pop%) + " ")\n      IF gen% MOD 10 = 0 THEN WRITELN("")\n    ENDIF\n  NEXT\n  BLOT(3)\n  HEAPRESET\n  UPDATE\n  REPEAT\n  UNTIL (?LMOUSE > 0) AND (?CLICKY < (100 - TMARGIN%)) AND (?CLICKX >= 130) AND (?CLICKX < 1030)\n  r% = ((?CLICKX - 130) DIV 90) + ((?CLICKY + TMARGIN% + 100) DIV 50) * 10 + 1\nUNTIL 0 = 1\nEND\n\nDEF PROCaxes\n  LOCAL i%\n  COLOUR(BLACK)\n  FOR i% = 0 TO 10\n    SETXY(i% * 100 - 25, 1000)\n    PRINT(QSTR$(i%, 10, 1), 4, 20)\n  NEXT\n  FOR i% = 1 TO 10\n    SETXY(-LMARGIN% + 5, 1000 - i% * 100 - 20)\n    PRINT(QSTR$(i%, 10, 1), 4, 20)\n  NEXT\n  SETXY(0, 0)\n  DRAWXY(0, 1000)\n  DRAWXY(1000, 0)\n  COLOUR(RED)\n  SETXY(0, 1060)\n  PRINT("Population over " + STR$(MAXGEN%) + " generations, where P (population/" + STR$(MAXPOP%) + ")", 4, 25)\n  SETXY(0, 1110)\n  PRINT("is determined by the logistic equation P\' = rP(1 - P), with r = " + QSTR$(r%, 10, 1), 4, 25)\nENDPROC\n\nDEF PROCmenu\n  LOCAL i%\n  COLOUR(BLACK)\n  SETXY(10, -TMARGIN% + 20)\n  PRINT("Set k:", 4, 25)\n  FOR i% = 21 TO 40\n    SETXY(((i% - 1) MOD 10) * 90 + 130,((i% - 1) DIV 10) * 50 - 100 - TMARGIN%)\n    IF i% = r% THEN\n      BOX(90, 50, RED, TRUE)\n    ELSE\n      BOX(90, 50, CREAM, TRUE)\n    ENDIF\n    PRINT("  " + QSTR$(i%, 10, 1), 4, 25)\n  NEXT\nENDPROC\n\nDEF PROCcurve\n  LOCAL i%, pop%, nextpop%\n  NOUPDATE\n  COLOUR(BLACK)\n  SETXY(0, 1000)\n  DRAWXY(1000, -1000)\n  COLOUR(BLUE)\n  SETXY(0, 1000)\n  FOR i% = 1 TO 1000\n    pop% = DIVMULT(i%, 1000, MAXPOP%)\n    nextpop% = DIVMULT(pop%, 10 * MAXPOP%, r% * (MAXPOP% - pop%))\n    SETXY(DIVMULT(pop%, MAXPOP%, 1000), 1000 - DIVMULT(nextpop%, MAXPOP%, 1000))\n    POLYLINE(2)\n  NEXT\n  UPDATE\nENDPROC\n'},function(e,n){e.exports='REM Mandelbrot\n\nMAXCOL% = 40\nSCALE% = 250\nPIXELS% = 750\nXCENTRE% = -500000 REM millionths\nYCENTRE% = 0 REM millionths\nXSTART% = DIVMULT(XCENTRE%, 1000000, SCALE%) - PIXELS% / 2\nYSTART% = DIVMULT(YCENTRE%, 1000000, SCALE%) - PIXELS% / 2\nXFINISH% = XSTART% + PIXELS% - 1\nYFINISH% = YSTART% + PIXELS% - 1\nCANVAS(XSTART%, YSTART%, PIXELS%, PIXELS%)\nRESOLUTION(PIXELS%, PIXELS%)\nTIMESET(0)\nFOR a% = XSTART% TO XFINISH%\n  NOUPDATE\n  FOR b% = YSTART% TO YFINISH%\n    x% = a%\n    y% = b%\n    iterations% = 0\n    WHILE (HYPOT(x%, y%, 1) < 2 * SCALE%) AND (iterations% <= MAXCOL%)\n      temp% = DIVMULT(x% + y%, SCALE%, x% - y%)\n      y% = DIVMULT(2 * x%, SCALE%, y%) + b%\n      x% = temp% + a%\n      INC(iterations%)\n    ENDWHILE\n    IF iterations% > MAXCOL% THEN\n      PIXSET(a%, b%, BLACK)\n    ELSE\n      PIXSET(a%, b%, RGB(iterations% + 1))\n    ENDIF\n  NEXT\n  UPDATE\nNEXT\nWRITELN("Resolution: " + STR$(SCALE% * 3) + " Time taken: " + QSTR$(TIME, 1000, 1) + " seconds.")\nEND\n'},function(e,n){e.exports='REM MandelbrotMini\n\nMAXCOL% = 40\nSCALE% = 10000\nPIXELS% = 300\nXCENTRE% = -159200\nYCENTRE% = -1033000\nXSTART% = DIVMULT(XCENTRE%, 1000000, SCALE%) - PIXELS% / 2\nYSTART% = DIVMULT(YCENTRE%, 1000000, SCALE%) - PIXELS% / 2\nXFINISH% = XSTART% + PIXELS% - 1\nYFINISH% = YSTART% + PIXELS% - 1\nCANVAS(XSTART%, YSTART%, PIXELS%, PIXELS%)\nRESOLUTION(PIXELS%, PIXELS%)\nTIMESET(0)\nFOR a% = XSTART% TO XFINISH%\n  NOUPDATE\n  FOR b% = YSTART% TO YFINISH%\n    x% = a%\n    y% = b%\n    iterations% = 0\n    WHILE (HYPOT(x%, y%, 1) < 2 * SCALE%) AND (iterations% <= MAXCOL%)\n      temp% = DIVMULT(x% + y%, SCALE%, x% - y%)\n      y% = DIVMULT(2 * x%, SCALE%, y%) + b%\n      x% = temp% + a%\n      INC(iterations%)\n    ENDWHILE\n    IF iterations% > MAXCOL% THEN\n      PIXSET(a%, b%, BLACK)\n    ELSE\n      PIXSET(a%, b%, RGB(iterations% + 1))\n    ENDIF\n  NEXT\n  UPDATE\nNEXT\nWRITELN("Resolution: " + STR$(SCALE% * 3) + " Time taken: " + QSTR$(TIME, 1000, 1) + " seconds.")\nEND\n'},function(e,n){e.exports="REM MandelbrotMiniSpectrum\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM MandelbrotSpectrum\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports='REM MathFunctions\n\nDECIMALS% = 4\nDENOMINATOR% = 1000000\nOUTPUT(TRUE, WHITE, TRUE)\nWRITELN("This program selects two random numbers a and b, in the")\nWRITELN("range 100-999, and then outputs various mathematical")\nWRITELN("functions of the fraction a/b. The results are expressed")\nWRITELN("to " + STR$(DECIMALS%) + " decimal places, and a denominator of " + STR$(DENOMINATOR%) + " is")\nWRITELN("used in the calculations to provide precision, even")\nWRITELN("though the Turtle functions strictly operate only on")\nWRITELN("integers and produce integer results.")\nWRITELN("")\nPROCselectAB\nWRITELN("a = " + STR$(A%) + "; b = " + STR$(B%))\nWRITELN("a / b = " + STR$(A%) + " / " + STR$(B%) + " = " + QSTR$(A%, B%, DECIMALS%))\nWRITELN("")\nPROCshow("square", POWER(A%, B%, 2, DENOMINATOR%))\nPROCshow("square root", ROOT(A%, B%, 2, DENOMINATOR%))\nPROCshow("cube", POWER(A%, B%, 3, DENOMINATOR%))\nPROCshow("cube root", ROOT(A%, B%, 3, DENOMINATOR%))\nWRITELN("")\nPROCshow("hypot", HYPOT(A%, B%, DENOMINATOR%))\nPROCshow("calculated hypot", SQR(A% * A% + B% * B%, DENOMINATOR%))\nWRITELN("")\nPROCshow("sin", SIN(A%, B%, DENOMINATOR%))\nPROCshow("cos", COS(A%, B%, DENOMINATOR%))\nPROCshow("tan", TAN(A%, B%, DENOMINATOR%))\nWRITELN("")\nPROCshow("ln", LN(A%, B%, DENOMINATOR%))\nIF DIVMULT(A%, B%, 1000) + LN(DENOMINATOR%, 1, 1000) > LN(MAXINT, 1, 1000) THEN\n  WRITELN("EXP(" + STR$(A%) + " / " + STR$(B%) + ") would give numerical overflow, because")\n  WRITELN("the result * " + STR$(DENOMINATOR%) + " would be greater than " + STR$(MAXINT))\nELSE\n  PROCshow("exp", EXP(A%, B%, DENOMINATOR%))\nENDIF\nPROCshow("log10", LOG10(A%, B%, DENOMINATOR%))\nIF DIVMULT(A%, B%, 1000) + LOG10(DENOMINATOR%, 1, 1000) > LOG10(MAXINT, 1, 1000) THEN\n  WRITELN("ANTILOG(" + STR$(A%) + " / " + STR$(B%) + ") would give numerical overflow, because")\n  WRITELN("the result * " + STR$(DENOMINATOR%) + " would be greater than " + STR$(MAXINT))\nELSE\n  PROCshow("antilog", ANTILOG(A%, B%, DENOMINATOR%))\nENDIF\nWRITELN("")\nIF A% > B% THEN\n  WRITELN("ACS and ASN are not defined for " + STR$(A%) + " / " + STR$(B%) + " = " + QSTR$(A%, B%, DECIMALS%))\nELSE\n  PROCshow("arccos", ACS(A%, B%, DENOMINATOR%))\n  PROCshow("arcsin", ASN(A%, B%, DENOMINATOR%))\nENDIF\nPROCshow("arctan", ATN(A%, B%, DENOMINATOR%))\nEND\n\nDEF PROCshow(s$, n%)\n  WRITELN(s$ + "(" + STR$(A%) + " / " + STR$(B%) + ") = " + QSTR$(n%, DENOMINATOR%, DECIMALS%))\nENDPROC\n\nDEF PROCselectAB\n  A% = RND(900) + 99\n  B% = RND(900) + 99\nENDPROC\n'},function(e,n){e.exports="REM MovingBall\n\nx% = 100\ny% = 700\nFOR count% = 1 TO 100\n  NOUPDATE\n  COLOUR(WHITE)\n  BLOT(51)\n  x% = x% + 8\n  y% = y% - 4\n  SETXY(x%, y%)\n  COLOUR(RED)\n  BLOT(50)\n  UPDATE\n  PAUSE(5)\nNEXT\nEND\n"},function(e,n){e.exports="REM MultiBounce\n\nxpos1% = 20\nxvel1% = 2\nypos1% = 200\nyvel1% = -3\nxpos2% = 400\nxvel2% = -4\nypos2% = 800\nyvel2% = 1\nREPEAT\n  PROCball(20, BLUE, xpos1%, xvel1%, ypos1%, yvel1%)\n  PROCball(30, RED, xpos2%, xvel2%, ypos2%, yvel2%)\nUNTIL 1 = 0\nEND\n\nDEF PROCball(size%, col%, RETURN xp%, RETURN xv%, RETURN yp%, RETURN yv%)\n  SETXY(xp%, yp%)\n  COLOUR(WHITE)\n  BLOT(size% + 1)\n  xp% = xp% + xv%\n  yp% = yp% + yv%\n  SETXY(xp%, yp%)\n  COLOUR(col%)\n  BLOT(size%)\n  UPDATE\n  NOUPDATE\n  IF (xp% < size%) OR (xp% > 1000 - size%) THEN xv% = -xv%\n  IF (yp% < size%) OR (yp% > 1000 - size%) THEN yv% = -yv%\nENDPROC\n"},function(e,n){e.exports="REM NestedLoops\n\nPENUP\nFOR countblot% = 1 TO 10\n  FORWARD(260)\n  COLOUR(BLACK)\n  BLOT(150)\n  COLOUR(RGB(countblot%))\n  FOR countcirc% = 1 TO 25\n    CIRCLE(countcirc% * 8)\n  NEXT\n  BACK(260)\n  RIGHT(36)\nNEXT\nEND\n"},function(e,n){e.exports="REM Nim\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM NoughtsAndCrosses\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM OlympicRings1\n\nTHICKNESS(20)\nPENUP\nFORWARD(50)\nCIRCLE(130)\nLEFT(90)\nFORWARD(300)\nCOLOUR(BLUE)\nCIRCLE(130)\nBACK(600)\nCOLOUR(RED)\nCIRCLE(130)\nFORWARD(150)\nRIGHT(90)\nBACK(125)\nCOLOUR(LIME)\nCIRCLE(130)\nLEFT(90)\nFORWARD(300)\nCOLOUR(YELLOW)\nCIRCLE(130)\nEND\n"},function(e,n){e.exports="REM OlympicRings2\n\nringsize% = 130\nTHICKNESS(20)\nPENUP\nFORWARD(50)\nCIRCLE(ringsize%)\nLEFT(90)\nFORWARD(300)\nCOLOUR(BLUE)\nCIRCLE(ringsize%)\nBACK(600)\nCOLOUR(RED)\nCIRCLE(ringsize%)\nFORWARD(150)\nRIGHT(90)\nBACK(125)\nCOLOUR(LIME)\nCIRCLE(ringsize%)\nLEFT(90)\nFORWARD(300)\nCOLOUR(YELLOW)\nCIRCLE(ringsize%)\nEND\n"},function(e,n){e.exports='REM PaintApp\n\nPROCsetup\nREPEAT\n  IF ?LMOUSE > 0 THEN\n    IF ?MOUSEY > 900 THEN\n      PROCsetbrushcolour(PIXCOL(?MOUSEX, ?MOUSEY))\n    ELSE\n      IF (?MOUSEY > 850) AND ((?MOUSEX > 600) AND (?MOUSEX < 850)) THEN\n        PROCsetbrushwidth(((?MOUSEX DIV 50) * 2) - 16)\n      ELSE\n        IF ?MOUSEY < 850 - BrushWidth% THEN PROCpaintbrush(?MOUSEX, ?MOUSEY)\n      ENDIF\n    ENDIF\n  ENDIF\n  IF (?RMOUSE > 0) AND (?MOUSEY < 850) THEN PROCpaintcan(?MOUSEX, ?MOUSEY)\n  UPDATE\nUNTIL FALSE\nEND\n\nDEF PROCsetbrushwidth(wdth%)\n  LOCAL count%\n  BrushWidth% = wdth%\n  NOUPDATE\n  COLOUR(BLACK)\n  FOR count% = 0 TO 4\n    SETXY(625 + count% * 50, 875)\n    BLOT(8 + count% * 2)\n  NEXT\n  COLOUR(BrushColour%)\n  RECOLOUR(((BrushWidth% + 16) * 25) + 25, 875, LIGHTRED)\n  UPDATE\nENDPROC\n\nDEF PROCsetbrushcolour(clr%)\n  BrushColour% = clr%\n  COLOUR(clr%)\n  SETXY(975, 875)\n  BLOT(16)\nENDPROC\n\nDEF PROCpaintbrush(x%, y%)\n  SETXY(x%, y%)\n  BLOT(BrushWidth%)\nENDPROC\n\nDEF PROCpaintcan(x%, y%)\n  RECOLOUR(x%, y%, BrushColour%)\nENDPROC\n\nDEF PROCtext(input$)\n  COLOUR(BLACK)\n  PRINT(input$, 0, 20)\nENDPROC\n\nDEF PROCsquare(col%)\n  MOVEXY(50, 0)\n  MOVEXY(0, 50)\n  MOVEXY(-50, 0)\n  MOVEXY(0, -50)\n  COLOUR(col%)\n  POLYGON(4)\nENDPROC\n\nDEF PROCsetup\n  LOCAL count%\n  COLOUR(LIGHTRED)\n  SETXY(0, 850)\n  DRAWXY(1000, 0)\n  SETXY(0, 900)\n  DRAWXY(1000, 0)\n  SETXY(450, 850)\n  DRAWXY(0, 50)\n  SETXY(850, 850)\n  DRAWXY(0, 50)\n  SETXY(10, 858)\n  PROCtext("Left-click to draw, right-click to fill")\n  SETXY(450 + 10, 858)\n  PROCtext("Brush width:")\n  SETXY(850 + 10, 858)\n  PROCtext("Colour:")\n  SETXY(0, 900)\n  FOR count% = 1 TO 20\n    PROCsquare(RGB(count%))\n    MOVEXY(0, 50)\n    PROCsquare(RGB(count% + 30))\n    MOVEXY(50, -50)\n  NEXT\n  PROCsetbrushwidth(8)\n  PROCsetbrushcolour(BLACK)\nENDPROC\n'},function(e,n){e.exports="REM ParameterProcedure\n\nFOR count% = 360 TO 1 STEP -1\n  RNDCOL(10)\n  PROCprong(count% + 100)\n  RIGHT(61)\nNEXT\nEND\n\nDEF PROCprong(length%)\n  FORWARD(length%)\n  BLOT(length% DIV 20)\n  BACK(length%)\nENDPROC\n"},function(e,n){e.exports="REM PolygonRings\n\nPENUP\nBLOT(500)\nRNDCOL(6)\nPROCannulus(410, 80, 2)\nPROCannulus(310, 80, 3)\nPROCannulus(210, 80, 5)\nPROCannulus(110, 80, 7)\nPROCannulus(10, 80, 1)\nEND\n\nDEF PROCannulus(inner%, width%, angle%)\n  LOCAL count%\n  FOR count% = 0 TO 360 DIV angle%\n    FORWARD(inner% + width%)\n    BACK(width%)\n    BACK(inner%)\n    FORGET(1)\n    RIGHT(angle%)\n    FORWARD(inner%)\n    FORWARD(width%)\n    COLOUR(RGB(count% MOD 20 + 1))\n    POLYGON(4)\n    BACK(inner% + width%)\n  NEXT\nENDPROC\n"},function(e,n){e.exports="REM Polygons\n\nPENUP\nTHICKNESS(4)\nSETXY(100, 400)\nPROCpoly(3, BLUE)\nSETXY(400, 400)\nPROCpoly(4, RED)\nSETXY(700, 400)\nPROCpoly(5, YELLOW)\nSETXY(150, 750)\nPROCpoly(6, PINK)\nSETXY(440, 750)\nPROCpoly(7, GREEN)\nSETXY(740, 750)\nPROCpoly(8, TURQUOISE)\nEND\n\nDEF PROCpoly(points%, col%)\n  LOCAL count%\n  DIRECTION(90)\n  FOR count% = 1 TO points%\n    FORWARD(600 DIV points%)\n    LEFT(360 DIV points%)\n  NEXT\n  COLOUR(col%)\n  POLYGON(points%)\n  COLOUR(BLACK)\n  POLYLINE(points% + 1)\nENDPROC\n"},function(e,n){e.exports="REM Quine\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM RefParams\n\nSETXY(100, 900)\nPROClines(TURTT%, FALSE)\nPROClines(TURTC%, TRUE)\nPROCdots(TURTX%)\nPROCdots(TURTY%)\nEND\n\nDEF PROClines(RETURN style%, convert%)\n  LOCAL count%\n  FOR count% = 1 TO 8\n    IF convert% THEN\n      style% = RGB(count%)\n    ELSE\n      style% = count%\n    ENDIF\n    FORWARD(50)\n    PAUSE(100)\n  NEXT\nENDPROC\n\nDEF PROCdots(RETURN coord%)\n  LOCAL count%\n  FOR count% = 1 TO 8\n    coord% = coord% + 100\n    BLOT(40)\n    PAUSE(100)\n  NEXT\nENDPROC\n"},function(e,n){e.exports="REM Schelling\n\nWIDTH% = 50\nHEIGHT% = 50\nEMPTY% = GREEN\nCANVAS(-1, -1, WIDTH% + 2, HEIGHT% + 2)\nRESOLUTION(WIDTH% + 2, HEIGHT% + 2)\nNOUPDATE\nBLANK(EMPTY%)\nFOR i% = 0 TO WIDTH% - 1\n  FOR j% = 0 TO WIDTH% - 1\n    test% = RND(25)\n    IF test% = 1 THEN\n      PIXSET(i%, j%, EMPTY%)\n    ELSE\n      IF (i% + j%) MOD 2 = 0 THEN PIXSET(i%, j%, RED) ELSE PIXSET(i%, j%, BLUE)\n    ENDIF\n  NEXT\nNEXT\nPAUSE(2000)\nWHILE ?KEY <> \\ESCAPE\n  NOUPDATE\n  REPEAT\n    tryi% = RND(WIDTH%) - 1\n    tryj% = RND(HEIGHT%) - 1\n    this% = PIXCOL(tryi%, tryj%)\n  UNTIL (this% <> EMPTY%) AND (NOT(FNhappy(tryi%, tryj%, this%)))\n  PIXSET(tryi%, tryj%, EMPTY%)\n  REPEAT\n    tryi% = RND(WIDTH%) - 1\n    tryj% = RND(HEIGHT%) - 1\n  UNTIL (PIXCOL(tryi%, tryj%) = EMPTY%) AND FNhappy(tryi%, tryj%, this%)\n  PIXSET(tryi%, tryj%, this%)\n  UPDATE\nENDWHILE\nEND\n\nDEF FNhappy(x%, y%, c%)\n  LOCAL like%, unlike%, neighbour%, i%, j%\n  like% = 0\n  unlike% = 0\n  FOR i% = -1 TO 1\n    FOR j% = -1 TO 1\n      IF (i% <> 0) OR (j% <> 0) THEN\n        neighbour% = PIXCOL(x% + i%, y% + j%)\n        IF neighbour% <> EMPTY% THEN\n          IF neighbour% = c% THEN INC(like%) ELSE INC(unlike%)\n        ENDIF\n      ENDIF\n    NEXT\n  NEXT\n= (like% >= unlike% - 1)\n"},function(e,n){e.exports="REM SexRatio\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports='REM Shoot\n\nTARGETS% = 10\nFaceX% = -100\nFaceY% = 625\nfacexspeed% = 5\nfaceyspeed% = 0\nhits% = 0\nCURSOR(0)\nWHILE hits% < TARGETS%\n  NOUPDATE\n  PROCbackground\n  SETXY(FaceX%, FaceY%)\n  PROCface\n  FOR i% = 1 TO hits%\n    PROCbottle(50 * i% - 35, 740)\n  NEXT\n  COLOUR(BROWN)\n  THICKNESS(272)\n  SETXY(0, 863)\n  DRAWXY(1000, 0)\n  PROCgunsight\n  THICKNESS(2)\n  UPDATE\n  FaceX% = FaceX% + facexspeed%\n  FaceY% = FaceY% + faceyspeed%\n  IF FaceX% > 1100 THEN FaceX% = -100\n  IF FaceX% < -100 THEN FaceX% = 1100\n  IF (FaceY% < 100) OR (FaceY% > 625) THEN faceyspeed% = faceyspeed% * -1\n  IF ((?LMOUSE > 0) AND (((?MOUSEX - FaceX%) * (?MOUSEX - FaceX%)) + ((?MOUSEY - FaceY%) * (?MOUSEY - FaceY%)) < 10000)) THEN\n    FaceX% = -100\n    facexspeed% = RND(5) + 1\n    faceyspeed% = RND(9) - 5\n    FaceY% = RND(550) + 49\n    INC(hits%)\n  ENDIF\nENDWHILE\nBLANK(BLACK)\nSETXY(200, 450)\nCOLOUR(GREEN)\nPRINT("  Well done!  ", 4, 75)\nEND\n\nDEF PROCbottle(x%, y%)\n  SETXY(x%, y%)\n  COLOUR(CYAN)\n  MOVEXY(0, -15)\n  THICKNESS(40)\n  DRAWXY(0, -50)\n  THICKNESS(10)\n  DRAWXY(0, -40)\n  THICKNESS(2)\n  MOVEXY(-20, 90)\n  MOVEXY(40, 0)\n  MOVEXY(0, -20)\n  MOVEXY(-40, 0)\n  COLOUR(PURPLE)\n  POLYGON(4)\n  MOVEXY(20, 35)\nENDPROC\n\nDEF PROCaddhat\n  SETXY(FaceX%, FaceY% - 80)\n  COLOUR(DARKGREY)\n  ELLBLOT(90, 30)\n  THICKNESS(2)\n  COLOUR(BLACK)\n  ELLIPSE(90, 30)\n  MOVEXY(-70, 0)\n  THICKNESS(4)\n  DRAWXY(35, -70)\n  DRAWXY(70, 0)\n  DRAWXY(35, 70)\n  COLOUR(DARKGREY)\n  THICKNESS(1)\n  POLYGON(4)\nENDPROC\n\nDEF PROCface\n  THICKNESS(1)\n  COLOUR(&FF8899)\n  BLOT(100)\n  COLOUR(WHITE)\n  SETXY(FaceX% - 20, FaceY% - 20)\n  BLOT(10)\n  COLOUR(BLACK)\n  BLOT(4)\n  THICKNESS(4)\n  MOVEXY(0, -22)\n  COLOUR(&663300)\n  DRAWXY(15, 15)\n  THICKNESS(1)\n  COLOUR(WHITE)\n  SETXY(FaceX% + 20, FaceY% - 20)\n  BLOT(10)\n  COLOUR(BLACK)\n  BLOT(4)\n  THICKNESS(4)\n  MOVEXY(0, -22)\n  COLOUR(&663300)\n  DRAWXY(-15, 15)\n  PROCaddhat\n  SETXY(FaceX%, FaceY% + 13)\n  COLOUR(RED)\n  BLOT(10)\n  MOVEXY(0, 32)\n  ELLBLOT(30, 6)\n  COLOUR(WHITE)\n  ELLBLOT(20, 4)\nENDPROC\n\nDEF PROCbackground\n  BLANK(COFFEE)\n  PROCbottle(100, 500)\n  PROCbottle(200, 500)\n  PROCbottle(450, 500)\n  PROCbottle(500, 500)\n  PROCbottle(565, 500)\n  PROCbottle(865, 500)\n  COLOUR(DARKBROWN)\n  THICKNESS(20)\n  SETXY(0, 125)\n  DRAWXY(1000, 0)\n  SETXY(0, 325)\n  DRAWXY(1000, 0)\n  SETXY(0, 525)\n  DRAWXY(1000, 0)\n  COLOUR(BROWN)\n  THICKNESS(30)\n  SETXY(0, 100)\n  DRAWXY(1000, 0)\n  SETXY(0, 300)\n  DRAWXY(1000, 0)\n  SETXY(0, 500)\n  DRAWXY(1000, 0)\nENDPROC\n\nDEF PROCgunsight\n  COLOUR(BLACK)\n  THICKNESS(6)\n  SETXY(?MOUSEX - 50, ?MOUSEY)\n  DRAWXY(100, 0)\n  SETXY(?MOUSEX, ?MOUSEY - 50)\n  DRAWXY(0, 100)\nENDPROC\n'},function(e,n){e.exports="REM Sierpinski\n\nBLANK(CREAM)\nTHICKNESS(1)\nPROCtriangle(400, 138, 843, 650, 179, 778)\nEND\n\nDEF PROCtriangle(x1%, y1%, x2%, y2%, x3%, y3%)\n  LOCAL x12%, y12%, x23%, y23%, x31%, y31%\n  SETXY(x1%, y1%)\n  SETXY(x2%, y2%)\n  SETXY(x3%, y3%)\n  SETXY(x1%, y1%)\n  COLOUR(BLACK)\n  POLYLINE(4)\n  IF HYPOT(x2% - x1%, y2% - y1%, 1) > 3 THEN\n    x12% = (x1% + x2%) / 2\n    y12% = (y1% + y2%) / 2\n    x23% = (x2% + x3%) / 2\n    y23% = (y2% + y3%) / 2\n    x31% = (x3% + x1%) / 2\n    y31% = (y3% + y1%) / 2\n    SETXY(x12%, y12%)\n    SETXY(x23%, y23%)\n    SETXY(x31%, y31%)\n    COLOUR(WHITE)\n    POLYGON(3)\n    PROCtriangle(x1%, y1%, x12%, y12%, x31%, y31%)\n    PROCtriangle(x2%, y2%, x23%, y23%, x12%, y12%)\n    PROCtriangle(x3%, y3%, x31%, y31%, x23%, y23%)\n  ENDIF\nENDPROC\n"},function(e,n){e.exports="REM SierpinskiColour\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM SierpinskiDots\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM SierpinskiIFS\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM SimpleDraw\n\nPROCpalette\nHOME\nTHICKNESS(10)\nBLOT(2)\nREPEAT\n  REPEAT\n    UPDATE\n  UNTIL (?LMOUSE > 0) OR (?RMOUSE > 0)\n  IF ?MOUSEY > 900 THEN\n    COLOUR(RGB(?MOUSEX DIV 100 + 1))\n  ELSE\n    IF ?LMOUSE > 0 THEN\n      DRAWXY(?MOUSEX - TURTX%, ?MOUSEY - TURTY%)\n    ELSE\n      SETXY(?MOUSEX, ?MOUSEY)\n    ENDIF\n  ENDIF\nUNTIL FALSE\nEND\n\nDEF PROCpalette\n  LOCAL col%\n  FOR col% = 1 TO 10\n    SETXY(col% * 100 - 50, 950)\n    COLOUR(RGB(col%))\n    BLOT(50)\n  NEXT\nENDPROC\n"},function(e,n){e.exports="REM SimpleProcedure\n\nREPEAT\n  RNDCOL(10)\n  PROCprong\n  RIGHT(61)\nUNTIL TURTD% = 0\nEND\n\nDEF PROCprong\n  FORWARD(400)\n  BLOT(20)\n  BACK(400)\nENDPROC\n"},function(e,n){e.exports='REM SnakeGame\n\nBOARDSIZE% = 30\nSNAKECOLOUR% = PURPLE\nAPPLECOLOUR% = GREEN\nCANVAS(0, 0, BOARDSIZE%, BOARDSIZE%)\nRESOLUTION(BOARDSIZE%, BOARDSIZE%)\nANGLES(4)\nBLANK(LIGHTBLUE)\nCURSOR(0)\nCOLOUR(SNAKECOLOUR%)\nTHICKNESS(1)\nPENUP\nFORWARD(1)\nsnakelength% = 2\nPROCnewapple\ncrash% = FALSE\nREPEAT\n  NOUPDATE\n  IF (ABS(?KEY) = \\UP) AND (TURTD% <> 2) THEN DIRECTION(0)\n  IF (ABS(?KEY) = \\RIGHT) AND (TURTD% <> 3) THEN DIRECTION(1)\n  IF (ABS(?KEY) = \\DOWN) AND (TURTD% <> 0) THEN DIRECTION(2)\n  IF (ABS(?KEY) = \\LEFT) AND (TURTD% <> 1) THEN DIRECTION(3)\n  FORWARD(1)\n  IF (TURTX% < 0) OR (TURTX% >= BOARDSIZE%) OR (TURTY% < 0) OR (TURTY% >= BOARDSIZE%) THEN crash% = TRUE\n  IF PIXCOL(TURTX%, TURTY%) = SNAKECOLOUR% THEN crash% = TRUE\n  IF PIXCOL(TURTX%, TURTY%) = APPLECOLOUR% THEN\n    INC(snakelength%)\n    PIXSET(TURTX%, TURTY%, SNAKECOLOUR%)\n    PROCnewapple\n  ENDIF\n  COLOUR(LIGHTBLUE)\n  POLYLINE(snakelength% + 2)\n  COLOUR(SNAKECOLOUR%)\n  POLYLINE(snakelength%)\n  UPDATE\n  PAUSE(250 - (snakelength% * 3))\nUNTIL crash%\nRESOLUTION(1000, 1000)\nBLANK(LILAC)\nSETXY(BOARDSIZE% / 4, 2 * BOARDSIZE% / 5)\nPRINT("Score " + STR$(snakelength% - 2), 20, 100)\nEND\n\nDEF PROCnewapple\n  LOCAL x%, y%\n  REPEAT\n    x% = RND(BOARDSIZE%) - 1\n    y% = RND(BOARDSIZE%) - 1\n  UNTIL (PIXCOL(x%, y%) <> SNAKECOLOUR%)\n  PIXSET(x%, y%, APPLECOLOUR%)\nENDPROC\n'},function(e,n){e.exports="REM SolarSystem\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM Stars\n\nPENUP\nFOR n% = 3 TO 12\n  PROCstar(n%, RGB(n% - 2))\n  PAUSE(500)\nNEXT\nEND\n\nDEF PROCstar(points%, col%)\n  LOCAL count%\n  ANGLES(points% * 2)\n  FOR count% = 1 TO points%\n    FORWARD(450)\n    BACK(450)\n    FORGET(1)\n    RIGHT(1)\n    FORWARD(200)\n    BACK(200)\n    FORGET(1)\n    RIGHT(1)\n  NEXT\n  COLOUR(col%)\n  POLYGON(points% * 2)\nENDPROC\n"},function(e,n){e.exports='REM StringFunctions\n\nDELAY% = 500\nOUTPUT(TRUE, CREAM, TRUE)\ns1$ = "Turtle BASIC"\ns2$ = MID$(s1$, 1, 6)\nWRITELN(s2$ + " is the name of a small animal.")\nPAUSE(DELAY%)\ns3$ = MID$(s1$, 8, 5)\nWRITELN(s3$ + " was invented in the 1960s.")\nPAUSE(DELAY%)\ns4$ = INS$(s3$, 2, "BC B")\nWRITELN("\\"" + s4$ + "\\"" is the name of a 1980s variant.")\nPAUSE(DELAY%)\nWRITELN("\'" + s1$ + "\' has " + STR$(LEN(s1$)) + " characters.")\nPAUSE(DELAY%)\nWRITELN("In lower case it is \'" + LCASE$(s1$) + "\'.")\nWRITELN("In upper case it is \'" + UCASE$(s1$) + "\'.")\nPAUSE(DELAY%)\nposn% = INSTR(s1$, s3$)\nIF posn% > 0 THEN\n  WRITELN("\'" + s3$ + "\' occurs within \'" + s1$ + "\' at position " + STR$(posn%) + ".")\nENDIF\nPAUSE(DELAY%)\ns5$ = "3.14159"\nWRITELN(s5$ + " times 100000 = " + STR$(QVAL(s5$, 100000, -1)) + ".")\nn% = QVAL(s5$, 100000, -1)\nPAUSE(DELAY%)\nWRITELN(STR$(n%) + " divided by 100000 = " + QSTR$(n%, 100000, 5) + ".")\nWRITELN("")\nPAUSE(DELAY% * 5)\nWRITELN("Now back to the Canvas and Console ...")\nOUTPUT(FALSE, PEACH, TRUE)\nPAUSE(DELAY% * 5)\nOUTPUT(FALSE, LIGHTRED, FALSE)\nPAUSE(DELAY% * 5)\nCONSOLE(TRUE, LIGHTBLUE)\nWRITELN("You will see this on a clear light blue Console")\nEND\n'},function(e,n){e.exports="REM ThePlough\n\nBLANK(BLACK)\nCOLOUR(LIGHTBLUE)\nSETXY(100, 200)\nBLOT(10)\nSETXY(300, 250)\nBLOT(10)\nSETXY(420, 350)\nBLOT(10)\nSETXY(570, 490)\nBLOT(10)\nSETXY(900, 560)\nBLOT(10)\nSETXY(840, 720)\nBLOT(10)\nSETXY(590, 660)\nBLOT(10)\nSETXY(570, 490)\nCOLOUR(SILVER)\nPOLYLINE(8)\nEND\n"},function(e,n){e.exports="REM TreeIFS\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM Triangles\n\nMOVEXY(-100, 150)\nPROCtriangle(256)\nEND\n\nDEF PROCtriangle(size%)\n  IF size% >= 2 THEN\n    FORWARD(size%)\n    PROCtriangle(size% / 2)\n    RIGHT(120)\n    FORWARD(size%)\n    PROCtriangle(size% / 2)\n    RIGHT(120)\n    FORWARD(size%)\n    PROCtriangle(size% / 2)\n    RIGHT(120)\n  ENDIF\nENDPROC\n"},function(e,n){e.exports='REM TrigonometricGraphs\n\nXORIGIN% = 500\nYORIGIN% = 500\nHALFWIDTH% = 400\nYSCALE% = 200\nPROCaxes\nNOUPDATE\nTHICKNESS(4)\nCOLOUR(GREEN)\nSETXY(20, 800)\nPRINT("sine", 16, 40)\nPROCsinecurve\nCOLOUR(RED)\nSETXY(20, 860)\nPRINT("cosine", 16, 40)\nPROCcosinecurve\nCOLOUR(BLUE)\nSETXY(20, 920)\nPRINT("tangent", 16, 40)\nPROCtancurve\nEND\n\nDEF PROCaxes\n  THICKNESS(3)\n  SETXY(XORIGIN% - HALFWIDTH%, YORIGIN%)\n  DRAWXY(HALFWIDTH% * 2, 0)\n  SETXY(XORIGIN%, 0)\n  DRAWXY(0, 1000)\n  SETXY(XORIGIN%, YORIGIN%)\n  CIRCLE(15)\n  THICKNESS(2)\n  SETXY(XORIGIN% - HALFWIDTH%, YORIGIN% - YSCALE%)\n  DRAWXY(HALFWIDTH% * 2, 0)\n  SETXY(XORIGIN% - HALFWIDTH%, YORIGIN% + YSCALE%)\n  DRAWXY(HALFWIDTH% * 2, 0)\n  SETXY(XORIGIN% + HALFWIDTH% + 10, YORIGIN% - YSCALE% - 18)\n  PRINT("+1", 0, 20)\n  SETXY(XORIGIN% + HALFWIDTH% + 10, YORIGIN% + YSCALE% - 18)\n  PRINT("-1", 0, 20)\n  SETXY(XORIGIN% - HALFWIDTH% - 60, YORIGIN%)\n  PRINT("-180", 0, 20)\n  SETXY(XORIGIN% - HALFWIDTH% / 2, YORIGIN%)\n  PRINT("-90", 0, 20)\n  SETXY(XORIGIN% + HALFWIDTH% / 2 - 30, YORIGIN%)\n  PRINT("90", 0, 20)\n  SETXY(XORIGIN% + HALFWIDTH%, YORIGIN%)\n  PRINT("180", 0, 20)\nENDPROC\n\nDEF PROCsinecurve\n  LOCAL degrees%, x%, y%\n  FOR degrees% = -180 TO 180\n    x% = XORIGIN% + DIVMULT(degrees%, 180, HALFWIDTH%)\n    y% = YORIGIN% - SIN(degrees%, 1, YSCALE%)\n    SETXY(x%, y%)\n  NEXT\n  POLYLINE(361)\nENDPROC\n\nDEF PROCcosinecurve\n  LOCAL degrees%, x%, y%\n  FOR degrees% = -180 TO 180\n    x% = XORIGIN% + DIVMULT(degrees%, 180, HALFWIDTH%)\n    y% = YORIGIN% - COS(degrees%, 1, YSCALE%)\n    SETXY(x%, y%)\n  NEXT\n  POLYLINE(361)\nENDPROC\n\nDEF PROCtancurve\n  LOCAL degrees%, x%, y%\n  FOR degrees% = -180 TO 180\n    IF degrees% = -90 THEN\n      POLYLINE(90)\n    ELSE\n      IF degrees% = 90 THEN\n        POLYLINE(179)\n      ELSE\n        x% = XORIGIN% + DIVMULT(degrees%, 180, HALFWIDTH%)\n        y% = YORIGIN% - TAN(degrees%, 1, YSCALE%)\n        SETXY(x%, y%)\n      ENDIF\n    ENDIF\n  NEXT\n  POLYLINE(90)\nENDPROC\n'},function(e,n){e.exports="REM TurtleBounce\n\nSETXY(100, 700)\nxvel% = 8\nyvel% = -4\nWHILE 0 < 1\n  NOUPDATE\n  COLOUR(WHITE)\n  BLOT(51)\n  MOVEXY(xvel%, yvel%)\n  COLOUR(RED)\n  BLOT(50)\n  UPDATE\n  PAUSE(5)\n  IF (TURTX% < 50) OR (TURTX% > 949) THEN\n    xvel% = -xvel%\n  ENDIF\n  IF (TURTY% < 50) OR (TURTY% > 949) THEN\n    yvel% = -yvel%\n  ENDIF\nENDWHILE\nEND\n"},function(e,n){e.exports="REM TurtleMove\n\nSETXY(100, 700)\nFOR count% = 1 TO 100\n  NOUPDATE\n  COLOUR(WHITE)\n  BLOT(51)\n  MOVEXY(8, -4)\n  COLOUR(RED)\n  BLOT(50)\n  UPDATE\n  PAUSE(5)\nNEXT\nEND\n"},function(e,n){e.exports="REM TwoSlits\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports="REM WaveSuperposer\n\nREM this program is not available in Turtle BASIC\nREM because arrays are not yet implemented\n"},function(e,n){e.exports='REM YouAreHere\n\nCOLOUR(RED)\nBLOT(20)\nCOLOUR(VIOLET)\nPRINT("You are here", 2, 36)\nSETXY(790, 540)\nCOLOUR(BLUE)\nDRAWXY(40, 0)\nDRAWXY(28, -28)\nDRAWXY(0, -40)\nDRAWXY(-28, -28)\nDRAWXY(-40, 0)\nSETXY(500, 500)\nSETXY(530, 480)\nSETXY(535, 505)\nSETXY(500, 500)\nPOLYLINE(5)\nPOLYGON(3)\nEND\n'},function(e,n,t){e.exports={AimCannon:t(121),AskInput:t(122),AutoCannon:t(123),Automata:t(124),Balls3D:t(125),BarnsleyColour:t(126),BarnsleyIFS:t(127),BouncingBall:t(128),BrownianMotion:t(129),Cheetahs:t(130),Circles:t(131),Clock:t(132),ColourSpiral:t(133),CycleColours:t(134),Diffusion:t(135),DigitalClock:t(136),Disease:t(137),DragonColour:t(138),DragonIFS:t(139),DrawPause:t(140),FiveTurtles:t(141),Flashlights:t(142),Flocking:t(143),ForLoop:t(144),GameOfLife:t(145),GravitySteps:t(146),IFSBackground:t(147),Interference:t(148),IteratedPD:t(149),KnightsTour:t(150),Launch:t(151),LifeStart:t(152),Logistic:t(153),LogisticSpider:t(154),Mandelbrot:t(155),MandelbrotMini:t(156),MandelbrotMiniSpectrum:t(157),MandelbrotSpectrum:t(158),MathFunctions:t(159),MovingBall:t(160),MultiBounce:t(161),NestedLoops:t(162),Nim:t(163),NoughtsAndCrosses:t(164),OlympicRings1:t(165),OlympicRings2:t(166),PaintApp:t(167),ParameterProcedure:t(168),PolygonRings:t(169),Polygons:t(170),Quine:t(171),RefParams:t(172),Schelling:t(173),SexRatio:t(174),Shoot:t(175),Sierpinski:t(176),SierpinskiColour:t(177),SierpinskiDots:t(178),SierpinskiIFS:t(179),SimpleDraw:t(180),SimpleProcedure:t(181),SnakeGame:t(182),SolarSystem:t(183),Stars:t(184),StringFunctions:t(185),ThePlough:t(186),TreeIFS:t(187),Triangles:t(188),TrigonometricGraphs:t(189),TurtleBounce:t(190),TurtleMove:t(191),TwoSlits:t(192),WaveSuperposer:t(193),YouAreHere:t(194)}},function(e,n){e.exports="PROGRAM AimCannon;\nCONST gunlength = 1000;\n      distancecol = green;\n      timecol = red;\nVAR n: integer;\n    steps: integer;\n\n  Procedure graphaxes;\n  Var n: integer;\n  Begin\n    thickness(5);\n    setxy(9700, 600);\n    drawxy(0, 3900);\n    drawxy(-9000, 0); {x axis 700 to 9700}\n    drawxy(0, -3900); {y axis 4500 to 600}\n    for n := 0 to 90 do\n      if n mod 5 = 0 then\n        begin\n          setxy(650 + n * 100, 4600);\n          print(str(n), 2, 16)\n        end;\n    for n := 0 to 9 do\n      begin\n        setxy(100, 4350 - n * 400);\n        print(str(n * 1000), 2, 16)\n      end;\n    for n := 0 to 9 do\n      begin\n        setxy(9900, 4380 - n * 400);\n        print(str(n * 20), 2, 16)\n      end;\n    setxy(4000, 4900);\n    print('Angle of elevation', 2, 24);\n    colour(distancecol);\n    setxy(0, 100);\n    print('Distance', 2, 24);\n    colour(timecol);\n    setxy(9600, 100);\n    print('Time', 2, 24)\n  End;\n\n  Procedure plot(x, y, col: integer);\n  Begin\n    setxy(700 + x * 100, 4500 - y * 2 / 5);\n    colour(col);\n    blot(40)\n  End;\n\n  Procedure aim;\n  Begin\n    repeat\n      noupdate;\n      setxy(0, 10000);\n      colour(cream);\n      blot(1600);\n      colour(yellowgreen);\n      blot(1400);\n      colour(maroon);\n      setxy(250, 9750);\n      blot(250);\n      forward(gunlength);\n      setxy(250, 9750);\n      colour(red);\n      blot(100);\n      update;\n      repeat\n      until (?lmouse > 0);\n      if pixcol(?mousex, ?mousey) = cream then\n        turnxy(?mousex - 250, ?mousey - 9750)\n    until pixcol(?mousex, ?mousey) = red\n  End;\n\n  Procedure fire(xvel, yvel, gravity, floor: integer);\n  Begin\n    setxy(250, 9750);\n    steps := 0;\n    repeat\n      inc(steps);\n      if pixcol(turtx, turty) = black then\n        begin\n          colour(white);\n          blot(80)\n        end;\n      movexy(xvel, yvel);\n      yvel := yvel + gravity;\n      if turty > floor then\n        turty := floor;\n      if (pixcol(turtx, turty) = white) or (turty = floor) then\n        begin\n          colour(black);\n          blot(75)\n        end;\n      update;\n      pause(10);\n      noupdate\n    until turty = floor\n  End;\n\nBEGIN\n  canvas(0, 0, 10500, 10000);\n  graphaxes;\n  turtd := 45;\n  thickness(20);\n  repeat\n    aim;\n    write('Elevation: ' + str(90 - turtd));\n    fire(cos(90 - turtd, 1, 96), sin(90 - turtd, 1, -96), 1, 9950);\n    write('  Distance: ' + str(turtx));\n    writeln('  Time: ' + str(steps));\n    plot(90 - turtd, turtx, distancecol);\n    plot(90 - turtd, steps * 50, timecol)\n  until 0 = 1\nEND.\n"},function(e,n){e.exports="PROGRAM AskInput;\nVAR s: string;\nBEGIN\n  writeln('What is your name?');\n  s := readln;\n  writeln('');\n  writeln('Hello, ' + s + ',');\n  writeln('How are you?')\nEND.\n"},function(e,n){e.exports="PROGRAM AutoCannon;\nCONST gunlength = 1000;\n      distancecol = green;\n      timecol = red;\nVAR n: integer;\n    steps: integer;\n\n  Procedure graphaxes;\n  Var n: integer;\n  Begin\n    thickness(5);\n    setxy(9700, 600);\n    drawxy(0, 3900);\n    drawxy(-9000, 0); {x axis 700 to 9700}\n    drawxy(0, -3900); {y axis 4500 to 600}\n    for n := 0 to 90 do\n      if n mod 5 = 0 then\n        begin\n          setxy(650 + n * 100, 4600);\n          print(str(n), 2, 16)\n        end;\n    for n := 0 to 9 do\n      begin\n        setxy(100, 4350 - n * 400);\n        print(str(n * 1000), 2, 16)\n      end;\n    for n := 0 to 9 do\n      begin\n        setxy(9900, 4380 - n * 400);\n        print(str(n * 20), 2, 16)\n      end;\n    setxy(4000, 4900);\n    print('Angle of elevation', 2, 24);\n    colour(distancecol);\n    setxy(0, 100);\n    print('Distance', 2, 24);\n    colour(timecol);\n    setxy(9600, 100);\n    print('Time', 2, 24)\n  End;\n\n  Procedure plot(x, y, col: integer);\n  Begin\n    setxy(700 + x * 100, 4500 - y * 2 / 5);\n    colour(col);\n    blot(40)\n  End;\n\n  Procedure aim(elevation: integer);\n  Begin\n    noupdate;\n    setxy(0, 10000);\n    colour(cream);\n    blot(1600);\n    colour(yellowgreen);\n    blot(1400);\n    colour(maroon);\n    setxy(250, 9750);\n    blot(250);\n    direction(90 - elevation);\n    forward(gunlength);\n    setxy(250, 9750);\n    colour(red);\n    blot(100);\n    update\n  End;\n\n  Procedure fire(xvel, yvel, gravity, floor: integer);\n  Begin\n    setxy(250, 9750);\n    steps := 0;\n    repeat\n      inc(steps);\n      if pixcol(turtx, turty) = black then\n        begin\n          colour(white);\n          blot(80)\n        end;\n      movexy(xvel, yvel);\n      yvel := yvel + gravity;\n      if turty > floor then\n        turty := floor;\n      if (pixcol(turtx, turty) = white) or (turty = floor) then\n        begin\n          colour(black);\n          blot(75)\n        end;\n      update;\n      pause(10);\n      noupdate\n    until turty = floor\n  End;\n\nBEGIN\n  canvas(0, 0, 10500, 10000);\n  graphaxes;\n  turtd := 45;\n  thickness(20);\n  for n := 0 to 90 do\n    begin\n      aim(n);\n      write('Elevation: ' + str(90 - turtd));\n      fire(cos(90 - turtd, 1, 96), sin(90 - turtd, 1, -96), 1, 9950);\n      write('  Distance: ' + str(turtx));\n      writeln('  Time: ' + str(steps));\n      plot(90 - turtd, turtx, distancecol);\n      plot(90 - turtd, steps * 50, timecol)\n    end\nEND.\n"},function(e,n){e.exports="PROGRAM Automata;\nCONST width = 100;\n      height = 100;\nVAR n, rule: integer;\n    x, generation: integer;\n    cellcol: array[0..1] of integer;\n    nextstate: array[0..7] of integer;\n\n  Procedure setup(rulecode: integer);\n  Var nhood: integer;\n  Begin\n    for nhood := 0 to 7 do\n      begin\n        nextstate[nhood] := rulecode mod 2;\n        rulecode := rulecode div 2\n      end\n  End;\n\n  Procedure nextgen(g: integer);\n  Var x, xmod, thispix: integer;\n      n1, n2, n3: integer;\n  Begin\n    for x := -1 to width do\n      begin\n        xmod := (x + width) mod width;\n        thispix := pixcol(xmod, g - 1) and 1;\n        n3 := n2 * 2 + thispix;\n        n2 := n1 * 2 + thispix;\n        n1 := thispix;\n        if x > 0 then\n          pixset(x - 1, g, cellcol[nextstate[n3]])\n      end\n  End;\n\nBEGIN\n  canvas(0, 0, width, height);\n  resolution(width, height);\n  cellcol[0] := $FFFFFE;\n  cellcol[1] := $000001;\n  for n := 4 to 45 do\n    begin\n      rule := n * 4 + 2;\n      setup(rule);\n      noupdate;\n      blank(white);\n      for x := 0 to width - 1 do\n        pixset(x, 0, cellcol[random(2)]);\n      for generation := 1 to height - 1 do\n        nextgen(generation);\n      setxy(0, height - 15);\n      box(25 + length(str(rule)) * 7, 14, cream, false);\n      print('Rule ' + str(rule), 4, 8);\n      update;\n      pause(500)\n    end\nEND.\n"},function(e,n){e.exports="PROGRAM Balls3D;\nVAR count: integer;\nBEGIN\n  setxy(250, 250);\n  colour($00ffff);\n  for count := 240 downto 1 do\n    begin\n      blot(count);\n      turtc := turtc + $10000\n    end;\n  right(60);\n  setxy(750, 250);\n  colour($d2691e);\n  for count := 40 downto 1 do\n    begin\n      blot(count * 6);\n      forward(3);\n      turtc := turtc + $10102\n    end;\n  setxy(250, 750);\n  colour($d2691e);\n  for count := 40 downto 1 do\n    begin\n      blot(count * 6);\n      forward(3);\n      turtc := turtc + $10102\n    end;\n  setxy(750, 750);\n  colour($ffa500);\n  for count := 80 downto 1 do\n    begin\n      blot(count * 3);\n      forward(2);\n      turtc := turtc + $101\n    end\nEND.\n"},function(e,n){e.exports="PROGRAM BarnsleyColour;\nCONST xleft = -236;\n      xright = 263;\n      ytop = 1;\n      ybottom = 1000;\n      scaledown = 3;\n      mappings = 4;\n      title = 'Barnsley fern';\n      gridlines = 5;\n      gridthick = 32;\nVAR xl, xr, yt, yb, gt: integer;\n    coeffdiv: integer;\n    mapxx, mapxy, mapxc: array[1..mappings] of integer;\n    mapyx, mapyy, mapyc: array[1..mappings] of integer;\n    count: integer;\n\n  Procedure setmaps;\n  Begin\n    coeffdiv := 100;\n    mapxx[1] := 0;\n    mapyx[1] := 0;\n    mapxy[1] := 0;\n    mapyy[1] := 16;\n    mapxc[1] := 0;\n    mapyc[1] := 0;\n    mapxx[2] := 85;\n    mapyx[2] := -4;\n    mapxy[2] := 4;\n    mapyy[2] := 85;\n    mapxc[2] := 0;\n    mapyc[2] := 160;\n    mapxx[3] := 20;\n    mapyx[3] := 23;\n    mapxy[3] := -26;\n    mapyy[3] := 22;\n    mapxc[3] := 0;\n    mapyc[3] := 160;\n    mapxx[4] := -15;\n    mapyx[4] := 26;\n    mapxy[4] := 28;\n    mapyy[4] := 24;\n    mapxc[4] := 0;\n    mapyc[4] := 44\n  End;\n\n  Procedure setscale;\n  Var i: integer;\n  Begin\n    xl := xleft / scaledown;\n    xr := xright / scaledown;\n    yt := ytop / scaledown;\n    yb := ybottom / scaledown;\n    for i := 1 to mappings do\n      begin\n        mapxc[i] := mapxc[i] / scaledown;\n        mapyc[i] : =mapyc[i] / scaledown\n      end;\n    gt := gridthick / scaledown\n  End;\n\n  Procedure background(rad: integer);\n  Var x, y: integer;\n  Begin\n    thickness(gt);\n    colour(darkgrey);\n    for x := 1 to gridlines - 1 do\n      begin\n        setxy(xl + divmult(xr - xl, gridlines, x), yt);\n        drawxy(0, yb - yt)\n      end;\n    for y := 1 to gridlines - 1 do\n      begin\n        setxy(xl + gt / 2, yt + divmult(yb - yt, gridlines, y));\n        drawxy(xr - xl - gt, 0)\n      end;\n    colour(black);\n    setxy(xl, yt);\n    drawxy(xr - xl, 0);\n    drawxy(0, yb - yt);\n    drawxy(xl - xr, 0);\n    drawxy(0, yt- yb);\n    for x := 0 to gridlines - 1 do\n      for y := 0 to gridlines - 1 do\n        recolour(xl + divmult(xr - xl, gridlines, x) + gt,\n                 yt + divmult(yb - yt, gridlines, y) + gt,\n                 divmult(255, gridlines - 1, x) * $10000\n                 + divmult(255, gridlines - 1, y) * $100\n                 + divmult(255, 2 * gridlines - 2, 2 * gridlines - 2 - x - y) * $1)\n  End;\n\n  Procedure map(a, x, y: integer; var newx, newy: integer);\n  Begin\n    newx := divmult(x, coeffdiv, mapxx[a]) + divmult(y, coeffdiv, mapxy[a]) + mapxc[a];\n    newy := divmult(x, coeffdiv, mapyx[a]) + divmult(y, coeffdiv, mapyy[a]) + mapyc[a]\n  End;\n\n  Procedure domap(mapnum: integer);\n  Var x, y, newx, newy: integer;\n  Begin\n    noupdate;\n    for y := yt to yb do\n      for x := xl to xr do\n        begin\n          map(mapnum, x, y, newx, newy);\n          pixset(newx, newy, pixcol(x, y))\n        end;\n    update\n  End;\n\nBEGIN\n  setmaps;\n  setscale;\n  canvas(xl, yt, xr - xl + 1, yb - yt + 1);\n  resolution(xr - xl + 1, yb - yt + 1);\n  background(6);\n  writeln(title + ' mappings in colour');\n  for count := 1 to mappings do\n    domap(count)\nEND.\n"},function(e,n){e.exports="PROGRAM BarnsleyIFS;\nCONST xleft = -236;\n      xright = 263;\n      ytop = 1;\n      ybottom = 1000;\n      scaledown = 3;\n      mappings = 4;\n      title = 'Barnsley fern';\n      live = green;\n      copied = emerald;\n      pauseval = 2000;\nVAR xl, xr, yt, yb: integer;\n    coeffdiv: integer;\n    mapxx, mapxy, mapxc: array[1..mappings] of integer;\n    mapyx, mapyy, mapyc: array[1..mappings] of integer;\n    iteration, starttime: integer;\n    count, numborn, numkilled: integer;\n\n  Procedure setmaps;\n  Begin\n    coeffdiv := 100;\n    mapxx[1] := 0;\n    mapyx[1] := 0;\n    mapxy[1] := 0;\n    mapyy[1] := 16;\n    mapxc[1] := 0;\n    mapyc[1] := 0;\n    mapxx[2] := 85;\n    mapyx[2] := -4;\n    mapxy[2] := 4;\n    mapyy[2] := 85;\n    mapxc[2] := 0;\n    mapyc[2] := 160;\n    mapxx[3] := 20;\n    mapyx[3] := 23;\n    mapxy[3] := -26;\n    mapyy[3] := 22;\n    mapxc[3] := 0;\n    mapyc[3] := 160;\n    mapxx[4] := -15;\n    mapyx[4] := 26;\n    mapxy[4] := 28;\n    mapyy[4] := 24;\n    mapxc[4] := 0;\n    mapyc[4] := 44\n  End;\n\n  Procedure setscale;\n  Var i: integer;\n  Begin\n    xl := xleft / scaledown;\n    xr := xright / scaledown;\n    yt := ytop / scaledown;\n    yb := ybottom / scaledown;\n    for i := 1 to mappings do\n      begin\n        mapxc[i] := mapxc[i] / scaledown;\n        mapyc[i] := mapyc[i] / scaledown\n      end\n  End;\n\n  Procedure map(a, x, y: integer; var newx, newy: integer);\n  Begin\n    newx := divmult(x, coeffdiv, mapxx[a]) + divmult(y, coeffdiv, mapxy[a]) + mapxc[a];\n    newy := divmult(x, coeffdiv, mapyx[a]) + divmult(y, coeffdiv, mapyy[a]) + mapyc[a]\n  End;\n\n  Procedure domap(mapnum: integer);\n  Var x, y, newx, newy: integer;\n  Begin\n    noupdate;\n    for y := yt to yb do\n      for x := xl to xr do\n        if pixcol(x, y) <> white then\n          begin\n            map(mapnum, x, y, newx, newy);\n            if pixcol(newx, newy) = white then\n              inc(numborn);\n            pixset(newx, newy, copied)\n          end;\n    update\n  End;\n\n  Procedure cleanup;\n  Var x, y: integer;\n  Begin\n    noupdate;\n    for y := yt to yb do\n      for x := xl to xr do\n        if pixcol(x, y) = live then\n          begin\n            pixset(x, y, white);\n            inc(numkilled)\n          end\n        else\n        if pixcol(x, y) = copied then\n          pixset(x, y, live);\n    update\n  End;\n\nBEGIN\n  setmaps;\n  setscale;\n  canvas(xl, yt, xr - xl + 1, yb - yt + 1);\n  resolution(xr - xl + 1, yb - yt + 1);\n  pixset(1, 1, live);\n  iteration := 0;\n  writeln(title + ' by iterative mapping');\n  timeset(0);\n  repeat\n    starttime := time;\n    inc(iteration);\n    writeln('');\n    writeln('Iteration ' + str(iteration) + ':');\n    numborn := 0;\n    for count := 1 to mappings do\n      domap(count);\n    numkilled := 0;\n    cleanup;\n    writeln('  ' + str(numborn) + ' pixels born; ' + str(numkilled) + ' pixels killed');\n    writeln('  (took ' + str((time - starttime) / 1000) + ' seconds - total ' + str(time / 1000) + ' seconds so far)');\n    if (numborn + numkilled > 0) and (pauseval >= 1000) then\n      begin\n        write('  (now pausing ' + qstr(pauseval, 1000, 1) + ' seconds to allow halting if desired ...)');\n        pause(pauseval);\n        writeln('')\n      end\n  until numborn + numkilled = 0;\n  writeln('FINISH - fixed point of iterative mapping has been reached')\nEND.\n"},function(e,n){e.exports="PROGRAM BouncingBall;\nVAR x, y: integer;\n    xvel, yvel: integer;\nBEGIN\n  x := 100;\n  y := 700;\n  xvel := 8;\n  yvel := -4;\n  while 0 < 1 do\n    begin\n      noupdate;\n      colour(white);\n      blot(51);\n      x := x + xvel;\n      y := y + yvel;\n      setxy(x, y);\n      colour(red);\n      blot(50);\n      update;\n      pause(10);\n      if (x < 50) or (x > 949) then\n        xvel := -xvel;\n      if (y < 50) or (y > 949) then\n        yvel := -yvel;\n    end\nEND.\n"},function(e,n){e.exports="PROGRAM BrownianMotion;\nCONST polradius = 80; {pollen}\n      molradius = 10;\n      hitradius = 90; {polradius+molradius}\n      molecules = 400;\n      slowspeed = 30;\n      highspeed = 50;\n      speedratio = 10;\n      polcolour = blue;\n      molcolour = red;\n      halocolour = $FFFFFE;\n      delay = 50;\nVAR px, py: integer;\n    pxvel, pyvel: integer;\n    mx, my, ms, md: array[1..molecules] of integer;\n    n: integer;\n\n  Procedure setup;\n  Var n: integer;\n  Begin\n    penup;\n    px := 500;\n    py := 500;\n    pxvel := 0;\n    pyvel := 0;\n    setxy(px, py);\n    colour(halocolour);\n    blot(hitradius);\n    for n := 1 to molecules do\n      begin\n        repeat\n          mx[n] := random(1000 - 2 * molradius) + molradius;\n          my[n] := random(1000 - 2 * molradius) + molradius\n        until pixcol(mx[n], my[n]) = white;\n        ms[n] := random(highspeed - slowspeed + 1) + slowspeed;\n        md[n] := random(360);\n        setxy(mx[n], my[n]);\n        blot(2 * molradius)\n      end\n  End;\n\n  Procedure draw(positive: boolean);\n  Var n: integer;\n      radius: integer;\n  Begin\n    if positive then\n      begin\n        colour(molcolour);\n        radius := molradius\n      end\n    else\n      begin\n        colour(white);\n        radius := molradius + 1\n      end;\n    for n := 1 to molecules do\n      begin\n        setxy(mx[n], my[n]);\n        blot(radius)\n      end;\n    setxy(px, py);\n    if positive then\n      begin\n        colour(polcolour);\n        blot(polradius)\n      end\n    else\n      blot(polradius + 1)\n  End;\n\n  Procedure move(m: integer);\n  Var degturn: integer;\n      impact: integer;\n  Begin\n    setxy(mx[m], my[m]);\n    direction(md[m]);\n    forward(ms[m]);\n    if hypot(turtx - px, turty - py, 1) <= hitradius then\n      begin\n        while hypot(turtx - px, turty - py, 1) < hitradius do\n          back(1);\n        turnxy(px - turtx, py - turty);\n        degturn := turtd - md[m];\n        md[m] := (180 + (turtd + degturn)) mod 360;\n        impact := cos(degturn, 1, ms[m]);\n        pxvel := pxvel + sin(turtd, 1, impact);\n        pyvel := pyvel - cos(turtd, 1, impact)\n      end;\n    mx[m] := (turtx + 1000) mod 1000;\n    my[m] := (turty + 1000) mod 1000\n  End;\n\nBEGIN\n  noupdate;\n  setup;\n  blank(white);\n  draw(true);\n  repeat\n    noupdate;\n    draw(false);\n    for n := 1 to molecules do\n      move(n);\n    px := px + pxvel / speedratio;\n    py := py + pyvel / speedratio;\n    draw(true);\n    update;\n    pause(delay)\n  until (abs(px - 500) > 490) or (abs(py - 500) > 480)\nEND.\n"},function(e,n){e.exports="PROGRAM Cheetahs;\nCONST maxanimals = 500;\n      mingazelles = 10;\n      startcheetahs = 50;\n      startgazelles = 50;\n      maxspeed = 1000;\n      startslow = 30;\n      startfast = 70;\n      randmarginc = 10;\n      randmarging = 10;\n      huntingtries = 100;\n      catchmargin = 5;\n      cfoodadd = 40;\n      cbreedfood = 10;\n      cmatingratio = 2;\n      gmatingratio = 1;\n      chuntingratio = 1;\n      slowage = 100; {speed starts declining}\n      agefactor = 0;\n      graphleft = 60;\n      graphwidth = 900;\n      graphheight = 400;\n      cgraphbase = 450;\n      ggraphbase = 950;\n      ymax = 20;\nVAR gen, cnum, gnum: integer;\n    cspeed, gspeed, cgenspeed, ggenspeed, cage, gage, cfood: array[1..maxanimals] of integer;\n    cspeednum, gspeednum: array[0..maxspeed] of integer;\n\n  Procedure setup;\n  Var n: integer;\n  Begin\n    for n := 0 to maxspeed do\n      begin\n        cspeednum[n] := 0;\n        gspeednum[n] := 0\n      end;\n    cnum := startcheetahs;\n    gnum := startgazelles;\n    for n := 1 to cnum do\n      begin\n        cgenspeed[n] := random(startfast + 1 - startslow) + startslow;\n        cspeed[n] := cgenspeed[n];\n        cage[n] := random(slowage);\n        cfood[n] := random(cfoodadd) + 1;\n        inc(cspeednum[cspeed[n]])\n      end;\n    for n := cnum + 1 to maxanimals do\n      cspeed[n] := 0; {i.e. not alive}\n    for n := 1 to gnum do\n      begin\n        ggenspeed[n] := random(startfast + 1 - startslow) + startslow;\n        gspeed[n] := ggenspeed[n];\n        gage[n] := random(slowage);\n        inc(gspeednum[gspeed[n]])\n      end;\n    for n := gnum + 1 to maxanimals do\n      gspeed[n] := 0 {i.e. not alive}\n  End;\n\n  Procedure axes(graphbase: integer);\n  Var n: integer;\n      scale: integer;\n  Begin\n    colour(black);\n    setxy(graphleft, graphbase - graphheight);\n    drawxy(0, graphheight);\n    drawxy(graphwidth, 0);\n    for n := 0 to 10 do\n      begin\n        setxy(20, graphbase - n * graphheight / 10 - 19);\n        print(str(n * ymax / 10), 0, 20)\n      end;\n    for n := 1 to 10 do\n      begin\n        setxy(graphleft + n * graphwidth / 10 - 20, graphbase);\n        print(str(n * maxspeed / 10), 0, 20)\n      end\n  End;\n\n  Procedure graph;\n  Var n, ctotal, gtotal: integer;\n  Begin\n    noupdate;\n    blank(white);\n    axes(450);\n    axes(950);\n    setxy(200, 20);\n    colour(red);\n    print('Speed Distribution of Cheetahs', 4, 25);\n    setxy(750, 20);\n    print(str(cnum), 4, 25);\n    ctotal := 0;\n    for n := 1 to maxspeed do\n      begin\n        setxy(graphleft + n * graphwidth / maxspeed, 450);\n        drawxy(0, -graphheight * cspeednum[n] / ymax);\n        ctotal := ctotal + n * cspeednum[n]\n      end;\n    setxy(200, 520);\n    colour(green);\n    print('Speed Distribution of Gazelles', 4, 25);\n    setxy(750, 520);\n    print(str(gnum), 4, 25);\n    gtotal := 0;\n    for n := 1 to maxspeed do\n      begin\n        setxy(graphleft + n * graphwidth / maxspeed, 950);\n        drawxy(0, -graphheight * gspeednum[n] / ymax);\n        gtotal := gtotal + n * gspeednum[n]\n      end;\n    setxy(850, 20);\n    if cnum < 1 then\n      begin\n        setxy(150, 200);\n        colour(magenta);\n        print('All Cheetahs Have Died', 4, 50);\n        halt\n      end;\n    print(qstr(ctotal, cnum, 2), 4, 25);\n    setxy(850, 520);\n    print(qstr(gtotal, gnum, 2), 4, 25);\n    update;\n    write(str(gen));\n    write(' - c=');\n    write(str(cnum));\n    write(' (av=');\n    write(qstr(ctotal, cnum, 2));\n    writeln(')');\n    update;\n    noupdate;\n    write('     g=');\n    write(str(gnum));\n    write(' (av=');\n    write(qstr(gtotal, gnum, 2));\n    writeln(')')\n  End;\n\n  Procedure deadcheetah(c: integer);\n  Begin\n    dec(cspeednum[cspeed[c]]);\n    cspeed[c] := 0;\n    dec(cnum)\n  End;\n\n  Procedure deadgazelle(g: integer);\n  Begin\n    dec(gspeednum[gspeed[g]]);\n    gspeed[g] := 0;\n    dec(gnum)\n  End;\n\n  Procedure babycheetah(speed: integer);\n  Var b: integer;\n  Begin\n    b := 0;\n    repeat\n      inc(b)\n    until (cspeed[b] = 0) or (b = maxanimals); {find empty space}\n    if cspeed[b] = 0 then\n      begin\n        inc(cnum);\n        cgenspeed[b] := speed + random(2 * randmarginc + 1) - randmarginc;\n        cgenspeed[b] := max(1, min(maxspeed, cgenspeed[b]));\n        cspeed[b] := cgenspeed[b];\n        cage[b] := 0;\n        cfood[b] := cfoodadd;\n        inc(cspeednum[cspeed[b]])\n      end\n  End;\n\n  Procedure babygazelle(speed: integer);\n  Var b: integer;\n  Begin\n    b := 0;\n    repeat\n      inc(b)\n    until (gspeed[b] = 0) or (b = maxanimals); {find empty space}\n    if gspeed[b] = 0 then\n      begin\n        inc(gnum);\n        ggenspeed[b] := speed + random(2 * randmarging + 1) - randmarging;\n        ggenspeed[b] := max(1, min(maxspeed, ggenspeed[b]));\n        gspeed[b] := ggenspeed[b];\n        gage[b] := 0;\n        inc(gspeednum[gspeed[b]])\n      end\n  End;\n\n  Procedure generation;\n  Var n: integer;\n      c, g, s, b: integer;\n      tries: integer;\n  Begin\n    for c := 1 to cnum / chuntingratio do {cheetahs hunt gazelles}\n      begin\n        c := random(maxanimals) + 1;\n        if (cspeed[c] > 0) and (gnum > mingazelles) then\n          begin\n            tries := 0;\n            repeat\n              inc(tries);\n              g := random(maxanimals) + 1\n            until (gspeed[g] > 0) or (tries = huntingtries);\n            if (gspeed[g] > 0) and (cspeed[c] >= gspeed[g] + catchmargin) then\n              begin\n                deadgazelle(g);\n                cfood[c] := cfood[c] + cfoodadd\n              end\n          end\n      end;\n    for n := 1 to cnum / cmatingratio do {cheetahs try mating}\n      begin\n        c := random(maxanimals) + 1;\n        if (cnum < maxanimals) and (cspeed[c] > 0) and (cfood[c] >= cbreedfood) then\n          begin\n            babycheetah(cgenspeed[c]);\n            cfood[c] := cfood[c] - cbreedfood\n          end\n      end;\n    for n := 1 to gnum / gmatingratio do {gazelles try mating}\n      begin\n        g := random(maxanimals) + 1;\n        if (gnum < maxanimals) and (gspeed[g] > 0) then\n          babygazelle(ggenspeed[g])\n      end;\n    for n := 1 to maxanimals do\n      begin\n        if cspeed[n] > 0 then {live cheetah}\n          begin\n            inc(cage[n]);\n            if cage[n] > slowage then\n              begin\n                dec(cspeednum[cspeed[n]]);\n                cspeed[n] := cspeed[n] * agefactor / 100;\n                inc(cspeednum[cspeed[n]]);\n                if cspeed[n] = 0 then\n                  deadcheetah(n)\n              end;\n            dec(cfood[n]);\n            if cfood[n] < 0 then\n              deadcheetah(n)\n          end;\n        if gspeed[n] > 0 then {live gazelle}\n          begin\n            inc(gage[n]);\n            if gage[n] > slowage then\n              begin\n               dec(gspeednum[gspeed[n]]);\n               gspeed[n] := gspeed[n] * agefactor / 100;\n               inc(gspeednum[gspeed[n]]);\n               if gspeed[n] = 0 then\n                 deadgazelle(n)\n              end\n          end\n      end\n  End;\n\nBEGIN\n  setup;\n  graph;\n  gen := 0;\n  repeat\n    inc(gen);\n    generation;\n    graph\n  until 0 = 1\nEND.\n"},function(e,n){e.exports="PROGRAM Circles;\nVAR count: integer;\nBEGIN\n  thickness(6);\n  penup;\n  blank(black);\n  colour(orange);\n  for count := 1 to 36 do\n    begin\n      forward(200);\n      circle(200);\n      back(200);\n      right(10);\n      pause(25)\n    end\nEND.\n"},function(e,n){e.exports="PROGRAM Clock;\nVAR hours: integer;\n    minutes: integer;\n\n  Procedure showhands;\n  Begin\n    colour(white);\n    blot(360);\n    colour(red);\n    direction(hours * 30);\n    thickness(10);\n    forward(250);\n    back(250);\n    direction(minutes * 6);\n    thickness(6);\n    forward(350);\n    back(350)\n  End;\n\nBEGIN\n  thickness(10);\n  circle(400);\n  hours := 0;\n  minutes := 0;\n  repeat\n    repeat\n      showhands;\n      pause(600);\n      inc(minutes)\n    until minutes = 60;\n    inc(hours);\n    minutes := 0\n  until hours = 12;\n  showhands\nEND.\n"},function(e,n){e.exports="PROGRAM ColourSpiral;\nVAR len: integer;\n\n  Procedure lineturn;\n  Begin\n    forward(len);\n    right(60)\n  End;\n\nBEGIN\n  blank(black);\n  forward(15);\n  thickness(27);\n  len := 20;\n  repeat\n    randcol(40);\n    lineturn;\n    len := len + 10\n  until len > 500\nEND.\n"},function(e,n){e.exports="PROGRAM CycleColours;\nVAR len: integer;\n    colinc, colcode: integer;\nBEGIN\n  blank(black);\n  colinc := random(5);\n  colcode := random(20) + 1;\n  colour(rgb(colcode));\n  len := 0;\n  thickness(16);\n  repeat\n    colcode := (colcode + colinc) mod 20 + 1;\n    colour(rgb(colcode));\n    len := len + 1;\n    forward(len);\n    right(30)\n  until len > 250\nEND.\n"},function(e,n){e.exports="PROGRAM Diffusion;\nCONST width = 100;\n      leftaxis = 21;\n      rightaxis = 15;\n      topmargin = 20;\n      gap = 10;\n      concbottom = 80;\n      concwidth = 50;\n      colour1 = red;\n      colour2 = blue;\n      edgecol = black;\n      molcol = red;\n      conccol = seagreen;\nVAR xorval: integer;\n    bottom: integer;\n    boundary: integer;\n    x1, y1: integer;\n    x2, y2: integer;\n    temp: integer;\n    num1: array[0..width] of integer;\n\n  Procedure setup;\n  Begin\n    canvas(0, 0, width + leftaxis + rightaxis, width * 2 + topmargin + gap);\n    resolution(width + leftaxis + rightaxis, width * 2 + topmargin + gap);\n    bottom := width * 2 + topmargin + gap - 1;\n    boundary := divmult(width, 1000, 707);\n    xorval := colour1 xor colour2;\n    thickness(1);\n    colour(colour2);\n    setxy(boundary + leftaxis, bottom - boundary);\n    drawxy(0, boundary);\n    setxy(boundary + leftaxis, bottom - boundary - 10);\n    drawxy(0, 5);\n    setxy(boundary + leftaxis, topmargin);\n    drawxy(0, 5);\n    colour(colour1);\n    setxy(boundary + leftaxis - 1, bottom - boundary - 10);\n    drawxy(0, 5);\n    setxy(boundary + leftaxis - 1, topmargin);\n    drawxy(0, 5);\n    colour(edgecol);\n    setxy(leftaxis - 1, bottom);\n    drawxy(width + 1, -width - 1);\n    colour(edgecol);\n    drawxy(0, width + 1);\n    recolour(leftaxis + 2, bottom, colour1);\n    recolour(width + leftaxis - 4, bottom, colour2);\n    for x1 := 0 to boundary - 1 do\n      num1[x1] := x1 + 1;\n    for x1 := boundary to width - 1 do\n      num1[x1] := 0;\n    colour(black);\n    setxy(0, 0);\n    print('Diffusion in a Tapering Tube', 2, width / 10)\n  End;\n\n  Procedure drawaxes;\n  Var n: integer;\n  Begin\n    for n := -1 to concwidth do\n      pixset(leftaxis - 1, concbottom - n, black);\n    for n := 0 to width do\n      pixset(leftaxis + 100, topmargin + n, black);\n    for n := 0 to 100 do\n      begin\n        if (n < 31) or (n mod 5 = 0) then\n          pixset(leftaxis + n, concbottom + 1, black);\n        pixset(leftaxis + n, topmargin + 101, black)\n      end;\n    drawxy(0, -concwidth);\n    colour(conccol);\n    setxy(0, concbottom - concwidth - width / 15);\n    print('100%', 2, width / 15);\n    setxy(0, concbottom - width / 15);\n    print('  0%', 2, width / 15);\n    setxy(0, topmargin + width * 11 / 10);\n    print('Red concentration', 2, width / 12);\n    colour(molcol);\n    setxy(width + leftaxis + 2, topmargin + width - boundary + 1 - width / 15);\n    print(str(boundary - 1), 2, width / 15);\n    setxy(width + leftaxis + 2, topmargin + width - width / 15);\n    print('  0', 2, width / 15);\n    setxy(0, topmargin + width * 12 / 10);\n    print('Red molecule count', 2, width / 12);\n    colour(black);\n    setxy(0, topmargin + width * 13 / 10 + 5);\n    print('(at horizontal position', 2, width / 15);\n    setxy(0, topmargin + width * 14 / 10 + 5);\n    print('in tapering tube)', 2, width / 15);\n  End;\n\n  Procedure graphit(x: integer; show: boolean);\n  Begin\n    if show then\n      begin\n        pixset(x + leftaxis, topmargin + width - num1[x], molcol);\n        pixset(x + leftaxis, concbottom - divmult(num1[x], x + 1, concwidth), conccol)\n      end\n    else\n      begin\n        pixset(x + leftaxis, topmargin + width - num1[x], white);\n        pixset(x + leftaxis, concbottom - divmult(num1[x], x + 1, concwidth), white)\n      end\n  End;\n\n  Procedure showswap(x, origcol: integer);\n  Begin\n    graphit(x1, false);\n    graphit(x1 + 1, false);\n    if origcol = colour1 then\n      begin\n        dec(num1[x1]);\n        inc(num1[x1 + 1])\n      end\n    else\n      begin\n        inc(num1[x1]);\n        dec(num1[x1 + 1])\n      end;\n    graphit(x1, true);\n    graphit(x1 + 1, true)\n  End;\n\nBEGIN\n  setup;\n  drawaxes;\n  for x1 := 0 to width - 1 do\n    graphit(x1, true);\n  pause(2500);\n  repeat\n    x1 := random(width);\n    y1 := random(width);\n    if y1 <= x1 then\n      begin\n        y1 := bottom - y1;\n        x2 := x1;\n        y2 := y1;\n        if random(2) = 0 then\n          inc(x2)\n        else\n          dec(y2);\n        temp := pixcol(x1 + leftaxis, y1);\n        if (pixcol(x2 + leftaxis, y2) xor temp) = xorval then\n          begin\n            noupdate;\n            pixset(x1 + leftaxis, y1, pixcol(x2 + leftaxis, y2));\n            pixset(x2 + leftaxis, y2, temp);\n            if (x2 <> x1) then\n              showswap(x1, temp);\n            update\n          end\n      end\n  until 0 = 1\nEND.\n"},function(e,n){e.exports="PROGRAM DigitalClock;\nVAR hours: integer;\n    minutes: integer;\n\n  Procedure showtime;\n  Var hstring, mstring: string;\n  Begin\n    setxy(300, 430);\n    box(400, 130, white, false);\n    if hours < 10 then\n      hstring := '0' + str(hours)\n    else\n      hstring := str(hours);\n    if minutes < 10 then\n      mstring := '0' + str(minutes)\n    else\n      mstring := str(minutes);\n    print(hstring + ':' + mstring, 21, 100)\n  End;\n\nBEGIN\n  blank(lightgreen);\n  setxy(250, 390);\n  colour(maroon);\n  thickness(10);\n  box(500, 210, lightbrown, true);\n  colour(black);\n  hours := 0;\n  minutes := 0;\n  while hours < 12 do\n    begin\n      showtime;\n      pause(600);\n      inc(minutes);\n      if minutes = 60 then\n        begin\n          inc(hours);\n          minutes := 0\n        end\n    end;\n  showtime\nEND.\n"},function(e,n){e.exports="PROGRAM Disease;\nCONST width = 100;\n      height = 100;\n      susceptible = lightgreen;\n      infected = red;\n      recovered = blue;\n      startradius = 10;\n      infectprob = 1;\n      immuneprob = 2;\n      recoverprob = 15;\nVAR x, y, n: integer;\n    numinfected: integer;\n\n  Procedure infect(x, y: integer);\n  Begin\n    pixset(x, y, infected);\n    inc(numinfected)\n  End;\n\nBEGIN\n  canvas(0, 0, width, height);\n  resolution(width, height);\n  numinfected := 0;\n  noupdate;\n  for x := 0 to width - 1 do\n    for y := 0 to height - 1 do\n      if (random(100) < infectprob) and (hypot(x - width / 2, y - height / 2, 1) <= startradius) then\n        infect(x, y)\n      else\n      if random(100) < immuneprob then\n        pixset(x, y, recovered)\n      else\n        pixset(x, y, susceptible);\n  update;\n  repeat\n    x := random(width);\n    y := random(height);\n    if pixcol(x, y) = infected then\n      begin\n        if random(100) < recoverprob then\n          begin\n            pixset(x, y, recovered);\n            dec(numinfected)\n          end\n        else\n          begin\n            n := random(4) * 2 + 1;\n            x := x + n div 3 - 1;\n            y := y + n mod 3 - 1;\n            if pixcol(x, y) = susceptible then\n              infect(x, y)\n          end\n      end\n  until numinfected = 0\nEND.\n"},function(e,n){e.exports="PROGRAM DragonColour;\nCONST xleft = 0;\n      xright = 999;\n      ytop = 0;\n      ybottom = 999;\n      scaledown = 4;\n      mappings = 3;\n      title = 'Dragon curve';\n      gridlines = 5;\n      gridthick = 64;\nVAR xl, xr, yt, yb, gt: integer;\n    coeffdiv: integer;\n    mapxx, mapxy, mapxc: array[1..mappings] of integer;\n    mapyx, mapyy, mapyc: array[1..mappings] of integer;\n    count: integer;\n\n  Procedure setmaps;\n  Begin\n    coeffdiv := 1000;\n    mapxx[1] := 0;\n    mapyx[1] := -577;\n    mapxy[1] := 577;\n    mapyy[1] := 0;\n    mapxc[1] := 95;\n    mapyc[1] := 589;\n    mapxx[2] := 0;\n    mapyx[2] := -577;\n    mapxy[2] := 577;\n    mapyy[2] := 0;\n    mapxc[2] := 441;\n    mapyc[2] := 789;\n    mapxx[3] := 0;\n    mapyx[3] := -577;\n    mapxy[3] := 577;\n    mapyy[3] := 0;\n    mapxc[3] := 95;\n    mapyc[3] := 989;\n  End;\n\n  Procedure setscale;\n  Var i: integer;\n  Begin\n    xl := xleft / scaledown;\n    xr := xright / scaledown;\n    yt := ytop / scaledown;\n    yb := ybottom / scaledown;\n    for i := 1 to mappings do\n      begin\n        mapxc[i] := mapxc[i] / scaledown;\n        mapyc[i] := mapyc[i] / scaledown\n      end;\n    gt := gridthick / scaledown\n  End;\n\n  Procedure background(rad: integer);\n  Var x, y: integer;\n  Begin\n    thickness(gt);\n    colour(darkgrey);\n    for x := 1 to gridlines - 1 do\n      begin\n        setxy(xl + divmult(xr - xl, gridlines, x), yt);\n        drawxy(0, yb - yt)\n      end;\n    for y := 1 to gridlines - 1 do\n      begin\n        setxy(xl + gt / 2, yt + divmult(yb - yt, gridlines, y));\n        drawxy(xr - xl - gt, 0)\n      end;\n    colour(black);\n    setxy(xl, yt);\n    drawxy(xr - xl, 0);\n    drawxy(0, yb - yt);\n    drawxy(xl - xr, 0);\n    drawxy(0, yt - yb);\n    for x := 0 to gridlines - 1 do\n      for y := 0 to gridlines - 1 do\n        recolour(xl + divmult(xr - xl, gridlines, x) + gt,\n                 yt + divmult(yb - yt, gridlines, y) + gt,\n                 divmult(255, gridlines - 1, x) * $10000\n                 + divmult(255, gridlines - 1, y) * $100\n                 + divmult(255, 2 * gridlines - 2, 2 * gridlines - 2 - x - y) * $1)\n  End;\n\n  Procedure map(a, x, y: integer; var newx, newy: integer);\n  Begin\n    newx := divmult(x, coeffdiv, mapxx[a]) + divmult(y, coeffdiv, mapxy[a]) + mapxc[a];\n    newy := divmult(x, coeffdiv, mapyx[a]) + divmult(y, coeffdiv, mapyy[a]) + mapyc[a]\n  End;\n\n  Procedure domap(mapnum: integer);\n  Var x, y, newx, newy: integer;\n  Begin\n    noupdate;\n    for y := yt to yb do\n      for x := xl to xr do\n        begin\n          map(mapnum, x, y, newx, newy);\n          pixset(newx, newy, pixcol(x, y))\n        end;\n    update\n  End;\n\nBEGIN\n  setmaps;\n  setscale;\n  canvas(xl, yt, xr - xl + 1, yb - yt + 1);\n  resolution(xr - xl + 1, yb - yt + 1);\n  background(6);\n  writeln(title + ' mappings in colour');\n  for count := 1 to mappings do\n    domap(count)\nEND.\n"},function(e,n){e.exports="PROGRAM DragonIFS;\nCONST xleft = 0;\n      xright = 999;\n      ytop = 0;\n      ybottom = 999;\n      scaledown = 4;\n      mappings = 3;\n      title = 'Dragon curve';\n      live = black;\n      copied = silver;\n      pauseval = 2000;\nVAR xl, xr, yt, yb: integer;\n    coeffdiv: integer;\n    mapxx, mapxy, mapxc: array[1..mappings] of integer;\n    mapyx, mapyy, mapyc: array[1..mappings] of integer;\n    iteration, starttime: integer;\n    count, numborn, numkilled: integer;\n\n  Procedure setmaps;\n  Begin\n    coeffdiv := 1000;\n    mapxx[1] := 0;\n    mapyx[1] := -577;\n    mapxy[1] := 577;\n    mapyy[1] := 0;\n    mapxc[1] := 95;\n    mapyc[1] := 589;\n    mapxx[2] := 0;\n    mapyx[2] := -577;\n    mapxy[2] := 577;\n    mapyy[2] := 0;\n    mapxc[2] := 441;\n    mapyc[2] := 789;\n    mapxx[3] := 0;\n    mapyx[3] := -577;\n    mapxy[3] := 577;\n    mapyy[3] := 0;\n    mapxc[3] := 95;\n    mapyc[3] := 989;\n  End;\n\n  Procedure setscale;\n  Var i: integer;\n  Begin\n    xl := xleft / scaledown;\n    xr := xright / scaledown;\n    yt := ytop / scaledown;\n    yb := ybottom / scaledown;\n    for i := 1 to mappings do\n      begin\n        mapxc[i] := mapxc[i] / scaledown;\n        mapyc[i] := mapyc[i] / scaledown\n      end\n  End;\n\n  Procedure map(a, x, y: integer; var newx, newy: integer);\n  Begin\n    newx := divmult(x, coeffdiv, mapxx[a]) + divmult(y, coeffdiv, mapxy[a]) + mapxc[a];\n    newy := divmult(x, coeffdiv, mapyx[a]) + divmult(y, coeffdiv, mapyy[a]) + mapyc[a]\n  End;\n\n  Procedure domap(mapnum: integer);\n  Var x, y, newx, newy: integer;\n  Begin\n    noupdate;\n    for y := yt to yb do\n      for x := xl to xr do\n        if pixcol(x, y) <> white then\n          begin\n            map(mapnum, x, y, newx, newy);\n            if pixcol(newx, newy) = white then\n              inc(numborn);\n            pixset(newx, newy, rgb(mapnum))\n          end;\n    update\n  End;\n\n  Procedure cleanup;\n  Var x, y: integer;\n  Begin\n    noupdate;\n    for y := yt to yb do\n      for x := xl to xr do\n        if pixcol(x, y) = live then\n          begin\n            pixset(x, y, white);\n            inc(numkilled)\n          end\n        else\n        if pixcol(x, y) <> white then\n          pixset(x, y, live);\n    update\n  End;\n\nBEGIN\n  setmaps;\n  setscale;\n  canvas(xl, yt, xr - xl + 1, yb - yt + 1);\n  resolution(xr - xl + 1, yb - yt + 1);\n  blank(live);\n  iteration := 0;\n  writeln(title + ' by iterative mapping');\n  timeset(0);\n  repeat\n    starttime := time;\n    inc(iteration);\n    writeln('');\n    writeln('Iteration ' + str(iteration) + ':');\n    numborn := 0;\n    for count := 1 to mappings do\n      domap(count);\n    numkilled := 0;\n    cleanup;\n    writeln('  ' + str(numborn) + ' pixels born; ' + str(numkilled) + ' pixels killed');\n    writeln('  (took ' + str((time - starttime) / 1000) + ' seconds - total ' + str(time / 1000) + ' seconds so far)');\n    if (numborn + numkilled > 0) and (pauseval >= 1000) then\n      begin\n        write('  (now pausing ' + qstr(pauseval, 1000, 1) + ' seconds to allow halting if desired ...)');\n        pause(pauseval);\n        writeln('')\n      end\n  until numborn + numkilled = 0;\n  writeln('FINISH - fixed point of iterative mapping has been reached');\n  for count := 1 to mappings do\n    domap(count)\nEND.\n"},function(e,n){e.exports="PROGRAM DrawPause;\nBEGIN\n  colour(green);\n  blot(100);\n  pause(1000);\n  colour(red);\n  forward(450);\n  pause(1000);\n  right(90);\n  thickness(9);\n  colour(blue);\n  pause(1000);\n  forward(300)\nEND.\n"},function(e,n){e.exports="PROGRAM FiveTurtles;\nVAR a, b, c, d, e: array[1..5] of integer;\n    i: integer;\nBEGIN\n  for i := 1 to 3 do\n    begin\n      a[i] := random(601) + 200;\n      b[i] := random(601) + 200;\n      c[i] := random(601) + 200;\n      d[i] := random(601) + 200;\n      e[i] := random(601) + 200\n    end;\n  a[4] := 2;\n  b[4] := 4;\n  c[4] := 6;\n  d[4] := 8;\n  e[4] := 10;\n  a[5] := purple;\n  b[5] := red;\n  c[5] := skyblue;\n  d[5] := emerald;\n  e[5] := gold;\n  repeat\n    newturtle(a);\n    drawxy(random(11) - 5, random(11) - 5);\n    newturtle(b);\n    drawxy(random(21) - 10, random(21) - 10);\n    newturtle(c);\n    drawxy(random(31) - 15, random(31) - 15);\n    newturtle(d);\n    drawxy(random(41) - 20, random(41) - 20);\n    newturtle(e);\n    drawxy(random(51) - 25, random(51) - 25);\n    if ?click > 128 then\n      begin\n        i := random(5);\n        if i = 0 then\n          begin\n            a[1] := ?mousex;\n            a[2] := ?mousey\n          end\n        else\n          if i = 1 then\n          begin\n            b[1] := ?mousex;\n            b[2] := ?mousey\n          end\n        else\n          if i = 2 then\n          begin\n            c[1] := ?mousex;\n            c[2] := ?mousey\n          end\n        else\n          if i = 3 then\n          begin\n            d[1] := ?mousex;\n            d[2] := ?mousey\n          end\n        else\n          if i = 4 then\n          begin\n            e[1] := ?mousex;\n            e[2] := ?mousey\n          end;\n        pause(200)\n      end\n  until ?key = \\escape\nEND.\n"},function(e,n){e.exports="PROGRAM Flashlights;\n\n  Procedure drawit(doblot: boolean);\n  Begin\n    if doblot then\n      begin\n        randcol(10);\n        blot(25)\n      end\n    else\n      begin\n        colour(black);\n        blot(30);\n        randcol(10);\n        circle(25)\n      end\n  End;\n\nBEGIN\n  blot(1000);\n  thickness(8);\n  repeat\n    setx((random(8) + 1) * 111);\n    sety((random(8) + 1) * 111);\n    drawit(random(2) = 1)\n  until false\nEND.\n"},function(e,n){e.exports="PROGRAM Flocking;\nCONST numboids = 30;\n      boidradius = 20;\n      maxspeed = 50;\n      boidcolour = lightbrown;\n      halocolour = $FFFFFE;\n      delay = 50;\n      posfactor = 50;\n      velfactor = 50;\n      neard = 200;\n      nearfactor = 10;\n      tgtradius = 2000;\nVAR boidx, boidy, boidvx, boidvy: array[1..numboids] of integer;\n    avgx, avgy, avgvx, avgvy: integer;\n    tgtx, tgty, tgtangvel: integer;\n    n: integer;\n    cycle: integer;\n\n  Procedure setup;\n  Var n: integer;\n  Begin\n    penup;\n    colour(halocolour);\n    for n := 1 to numboids do\n      begin\n        repeat\n          boidx[n] := random(5000 - 2 * boidradius) + boidradius;\n          boidy[n] := random(5000 - 2 * boidradius) + boidradius\n        until pixcol(boidx[n], boidy[n]) = white;\n        boidvx[n] := random(maxspeed * 2 + 1) - maxspeed;\n        boidvy[n] := random(maxspeed * 2 + 1) - maxspeed;\n        setxy(boidx[n], boidy[n]);\n        blot(2 * boidradius)\n      end\n  End;\n\n  Procedure draw(positive: boolean);\n  Var n, radius: integer;\n  Begin\n    if positive then\n      begin\n        colour(boidcolour);\n        radius := boidradius\n      end\n    else\n      begin\n        colour(white);\n        radius := boidradius + 10\n      end;\n    for n := 1 to numboids do\n      begin\n        setxy(boidx[n], boidy[n]);\n        blot(radius)\n      end\n  End;\n\n  Procedure averages;\n  Var totalx, totaly, totalvx, totalvy: integer;\n      n: integer;\n  Begin\n    totalx := 0;\n    totaly := 0;\n    totalvx := 0;\n    totalvy := 0;\n    for n := 1 to numboids do\n      begin\n        totalx := totalx + boidx[n];\n        totaly := totaly + boidy[n];\n        totalvx := totalvx + boidvx[n];\n        totalvy := totalvy + boidvy[n]\n      end;\n    avgx := totalx / numboids;\n    avgy := totaly / numboids;\n    avgvx := totalvx / numboids;\n    avgvy := totalvy / numboids\n  End;\n\n  Procedure settarget;\n  Begin\n    if cycle mod 100 = 0 then\n      tgtangvel := random(7) - 3;\n    tgtx := divmult(sin(cycle * tgtangvel, 1, 1000), 1000, tgtradius);\n    tgty := -divmult(cos(cycle * tgtangvel, 1, 1000), 1000, tgtradius);\n    inc(cycle)\n  End;\n\n  Procedure move(b: integer);\n  Var n: integer;\n      distx, disty, speed: integer;\n  Begin\n    boidvx[b] := boidvx[b] + (avgx - boidx[b]) / posfactor + (avgvx - boidvx[b]) / velfactor;\n    boidvy[b] := boidvy[b] + (avgy - boidy[b]) / posfactor + (avgvy - boidvy[b]) / velfactor;\n    for n := 1 to numboids do\n      if n <> b then\n        begin\n          distx := boidx[n] - boidx[b];\n          disty := boidy[n] - boidy[b];\n          if hypot(distx, disty, 1) < neard then\n            begin\n              boidvx[b] := boidvx[b] - sign(distx) * (neard - abs(distx)) / nearfactor;\n              boidvy[b] := boidvy[b] - sign(disty) * (neard - abs(disty)) / nearfactor\n            end\n        end;\n    if random(10) = 0 then\n      begin\n        boidvx[b] := tgtx - boidx[b];\n        boidvy[b] := tgty - boidy[b]\n      end;\n    speed := hypot(boidvx[b], boidvy[b], 1);\n    if speed > maxspeed then\n      begin\n        boidvx[b] := divmult(boidvx[b], speed, maxspeed);\n        boidvy[b] := divmult(boidvy[b], speed, maxspeed)\n      end;\n    boidx[b] := boidx[b] + boidvx[b];\n    boidy[b] := boidy[b] + boidvy[b]\n  End;\n\nBEGIN\n  canvas(-2500, -2500, 5000, 5000);\n  noupdate;\n  setup;\n  blank(white);\n  draw(true);\n  cycle := 0;\n  repeat\n    averages;\n    settarget;\n    noupdate;\n    draw(false);\n    for n := 1 to numboids do\n      move(n);\n    draw(true);\n    update;\n    pause(delay)\n  until 0 = 1\nEND.\n"},function(e,n){e.exports="PROGRAM ForLoop;\nVAR count: integer;\nBEGIN\n  for count := 1 to 200 do\n    begin\n      forward(count div 3);\n      right(5);\n      colour(red);\n      blot(200);\n      colour(black);\n      circle(200)\n    end\nEND.\n"},function(e,n){e.exports="PROGRAM GameOfLife;\nCONST width = 32;\n      height = 32;\nVAR x, y, i, j, dn: integer;\nBEGIN\n  canvas(0, 0, width, height);\n  resolution(width, height);\n  for x := 0 to width - 1 do\n    for y := 0 to height - 1 do\n      if random(7) = 0 then\n        pixset(x, y, black);\n  while ?key <> \\escape do\n    begin\n      for x := 0 to width - 1 do\n        for y := 0 to height - 1 do\n          begin\n            dn := 0;\n            for i := -1 to 1 do\n              for j := -1 to 1 do\n                dn := dn + pixcol((x + i + width) mod width, (y + j + height) mod height) and 1;\n            if ((pixcol(x, y) and 1 = 0) and ((dn < 5) or (dn > 6)))\n                or ((pixcol(x, y) and 1 = 1) and (dn = 6)) then\n              pixset(x, y, pixcol(x, y) xor 2)\n          end;\n      for x := 0 to width do\n        for y := 0 to height do\n          if (pixcol(x, y) and 3) mod 3 <> 0 then\n            pixset(x, y, pixcol(x, y) xor $FFFFFD)\n    end\nEND.\n"},function(e,n){e.exports="PROGRAM GravitySteps;\nVAR bounce: integer;\n\n  Procedure steps(s: integer);\n  Var size, count: integer;\n  Begin\n    size := 1000 / s;\n    setxy(0, 1000);\n    thickness(1);\n    for count := 1 to s * 2 do\n      if count mod 2 = 0 then\n        movexy(0, -size)\n      else\n        movexy(size, 0);\n    movexy(0, s * size);\n    movexy(-s * size, 0);\n    colour(blue);\n    polygon(s * 2 + 2)\n  End;\n\n  Procedure throwball(xvel, yvel, gravity, floor: integer);\n  Begin\n    repeat\n      colour(white);\n      blot(25);\n      movexy(xvel, yvel);\n      yvel := yvel + gravity;\n      if turty > floor then\n        turty := floor;\n      colour(red);\n      blot(24);\n      update;\n      pause(10);\n      noupdate\n    until turty = floor\n  End;\n\nBEGIN\n  steps(10);\n  setxy(950, 75);\n  repeat\n    throwball(-2, -22, 1, turty + 100)\n  until turtx < 75;\n  for bounce := 1 to 10 do\n    throwball(0, bounce * 2 - 20, 1, turty)\nEND.\n"},function(e,n){e.exports="PROGRAM IFSBackground;\nCONST xleft = 0;\n      xright = 999;\n      ytop = 0;\n      ybottom = 999;\n      gridscale = 5;\n      gridthick = 64;\n\n  Procedure background(rad: integer);\n  Var x, y, cx, cy, r, g, b: integer;\n  Begin\n    thickness(gridthick);\n    colour(darkgrey);\n    for x := 1 to gridscale - 1 do\n      begin\n        setxy(xleft + divmult(xright - xleft, gridscale, x), ytop);\n        drawxy(0, ybottom - ytop)\n      end;\n    for y := 1 to gridscale - 1 do\n      begin\n        setxy(xleft + gridthick / 2, ytop + divmult(ybottom - ytop, gridscale, y));\n        drawxy(xright - xleft - gridthick, 0)\n      end;\n    colour(black);\n    setxy(xleft, ytop);\n    drawxy(xright - xleft, 0);\n    drawxy(0, ybottom - ytop);\n    drawxy(xleft - xright, 0);\n    drawxy(0, ytop - ybottom);\n    for x := 0 to gridscale - 1 do\n      for y := 0 to gridscale - 1 do\n        begin\n          cx := xleft + divmult(xright - xleft, gridscale, x) + gridthick;\n          cy := ytop + divmult(ybottom - ytop, gridscale, y) + gridthick;\n          r := divmult(255, gridscale - 1, x);\n          g := divmult(255, gridscale - 1 , y);\n          b := divmult(255, 2 * gridscale - 2, 2 * gridscale - 2 - x - y);\n          recolour(cx, cy, (r * $10000) + (g * $100) + (b * $1));\n        end\n  End;\n\nBEGIN\n  canvas(xleft, ytop, xright - xleft + 1, ybottom - ytop + 1);\n  resolution(xright - xleft + 1, ybottom - ytop + 1);\n  background(6)\nEND.\n"},function(e,n){e.exports="PROGRAM Interference;\nCONST sectors = 7;\n      wavecol1 = red;\n      wavecol2 = skyblue;\n      waveaddcol = indigo;\n      clocks = 16;\n      report = false;\nVAR x, y: integer;\n    sectcol: array[0..sectors] of integer;\n    boundary: array[0..sectors] of integer;\n    clockx: array[1..clocks] of integer;\n    cradius, hand: integer;\n    leftx, rightx: integer;\n    dimensions: integer;\n    wavelength1, wavelength2: integer;\n\n  Procedure colsetup;\n  Var n: integer;\n  Begin\n    sectcol[0] := violet;\n    sectcol[1] := blue;\n    sectcol[2] := cyan;\n    sectcol[3] := lime;\n    sectcol[4] := yellow;\n    sectcol[5] := orange;\n    sectcol[6] := red;\n    sectcol[7] := violet;\n    for n := 0 to sectors do\n      boundary[n] := divmult(360, sectors, n)\n  End;\n\n  Function wavecolour(n: integer): integer;\n  Var col1, col2: integer;\n      mix1, mix2: integer;\n  Begin\n    col2 := 0;\n    repeat\n      inc(col2)\n    until boundary[col2] >= n;\n    col1 := col2 - 1;\n    result:=mixcols(sectcol[col1], sectcol[col2], boundary[col2] - n, n - boundary[col1])\n  End;\n\n  Procedure clocksetup;\n  Var n: integer;\n  Begin\n    for n := 1 to clocks do\n      clockx[n] := divmult(1000, clocks * 2 + 2, n * 2);\n    leftx := clockx[1];\n    rightx := clockx[clocks];\n    cradius := (rightx - leftx) / clocks / 2;\n    hand := cradius * 6 / 7\n  End;\n\n  Procedure drawwave(s: string; top, wavelength, wavecol: integer);\n  Var n, turn: integer;\n  Begin\n    if dimensions = 1 then\n      begin\n        setxy(leftx, top + 25);\n        colour(black);\n        drawxy(rightx - leftx, 0);\n        setxy(leftx, top);\n        colour(wavecol)\n      end;\n    for n := 0 to rightx - leftx do\n      if dimensions = 1 then\n        begin\n          setxy(leftx + n, top + 25 - cos(divmult(n mod wavelength, wavelength, 360), 1, 25));\n          polyline(2)\n        end\n      else\n        begin\n          setxy(leftx + n, top);\n          colour(wavecolour(divmult(n mod wavelength, wavelength,360)));\n          drawxy(0, 50)\n        end;\n    for n := 1 to clocks do\n      begin\n        setxy(clockx[n], top + 70 + cradius);\n        colour(black);\n        circle(cradius);\n        blot(5);\n        turn := divmult((clockx[n] - leftx) mod wavelength, wavelength, 360);\n        if report then\n          writeln(s + ', clock ' + str(n) + ': dist=' + str(clockx[n]) + '; turn=' + str(turn));\n        turnxy(sin(turn, 1, 1000), -cos(turn, 1, 1000));\n        colour(wavecol);\n        forward(hand)\n      end\n  End;\n\n  Procedure drawresult(top: integer);\n  Var n: integer;\n      turn1, turn2: integer;\n      waveaddi, waveaddj, waveadd: integer;\n  Begin\n    if dimensions = 1 then\n      begin\n        setxy(leftx, top + 50);\n        colour(black);\n        drawxy(rightx - leftx, 0);\n        setxy(leftx, top);\n        colour(waveaddcol)\n      end;\n    for n := 0 to rightx - leftx do\n      begin\n        turn1 := divmult(n mod wavelength1, wavelength1, 360);\n        turn2 := divmult(n mod wavelength2, wavelength2, 360);\n        waveaddi := sin(turn1, 1, 500) + sin(turn2, 1, 500);\n        waveaddj := cos(turn1, 1, 500) + cos(turn2, 1, 500);\n        waveadd := hypot(waveaddi, waveaddj, 1);\n        if dimensions = 1 then\n          begin\n            setxy(leftx + n, top + 50 - divmult(waveaddj, 1000, 50));\n            polyline(2)\n          end\n        else\n          begin\n            setxy(leftx + n, top);\n            turnxy(waveaddi, -waveaddj);\n            colour(mixcols(wavecolour(turtd), black, waveadd, 1000 - waveadd));\n            if mixcols(wavecolour(turtd), black, waveadd, 1000 - waveadd) < 51 then\n              colour(black); {to avoid colour code problems}\n            drawxy(0, 100)\n          end\n      end;\n    for n := 1 to clocks do\n      begin\n        setxy(clockx[n], top + 280 + 2 * cradius - (150 * (n mod 2)));\n        colour(black);\n        circle(cradius * 2);\n        blot(5);\n        turn1 := divmult((clockx[n] - leftx) mod wavelength1, wavelength1, 360);\n        turn2 := divmult((clockx[n] - leftx) mod wavelength2, wavelength2, 360);\n        waveaddi := sin(turn1, 1, 500) + sin(turn2, 1, 500);\n        waveaddj := cos(turn1, 1, 500) + cos(turn2, 1, 500);\n        waveadd := hypot(waveaddi, waveaddj, 1);\n        turnxy(waveaddi, -waveaddj);\n        thickness(6);\n        colour(waveaddcol);\n        forward(divmult(waveadd, 1000, hand * 2));\n        setxy(clockx[n], top + 280 + 2 * cradius - (150 * (n mod 2)));\n        thickness(4);\n        direction(turn1);\n        colour(wavecol1);\n        forward(hand);\n        direction(turn2);\n        colour(wavecol2);\n        forward(hand);\n        thickness(2)\n      end\n  End;\n\n  Procedure randomwaves;\n  Begin\n    wavelength1 := random(30) * 10 + 200;\n    wavelength2 := random(30) * 10 + 200\n  End;\n\n  Procedure changeprompt;\n  Begin\n    console(true, white);\n    writeln('Press \"1\" or \"2\" for the dimensionality required,');\n    write('or press \"R\" to pick random new wavelengths: ');\n    repeat\n    until (abs(?key) = \\1) or (abs(?key) = \\2) or (abs(?key) = \\r);\n    if abs(?key) = \\1 then\n      dimensions := 1\n    else\n    if abs(?key) = \\2 then\n      dimensions := 2\n    else\n      randomwaves;\n    reset(?key);\n    reset(\\keybuffer)\n  End;\n\nBEGIN\n  colsetup;\n  clocksetup;\n  dimensions := 1;\n  wavelength1 := 300;\n  wavelength2 := 420;\n  repeat\n    blank(white);\n    noupdate;\n    setxy(leftx, 25);\n    colour(black);\n    print('Component waves (wavelengths ' + str(wavelength1) + ', ' + str(wavelength2) + ')', 4, 30);\n    drawwave('Wave 1', 100, wavelength1, wavecol1);\n    drawwave('Wave 2', 300, wavelength2, wavecol2);\n    setxy(leftx, 505);\n    colour(black);\n    print('Resultant wave', 4, 30);\n    drawresult(580);\n    changeprompt\n  until 0 = 1\nEND.\n"},function(e,n){e.exports="PROGRAM iteratedpd;\nCONST width = 32;\n      height = 32;\n      n = 10;\nVAR i, j: integer;\n    util: array[1..14] of integer;\n\n  Procedure utility(x, y: integer);\n  Var this, utot, i, j, flag: integer;\n  Begin\n    this := pixcol(x, y) and $7;\n    utot := 0;\n    for i := -1 to 1 do\n      for j := -1 to 1 do\n        if (i <> 0) or (j <> 0) then\n          begin\n            flag := this or (pixcol((x + width + i) mod width, (y + height + j) mod height)) and $f;\n            utot := utot + util[flag]\n          end;\n    pixset(x, y, utot * $100 + pixcol(x, y) and $f)\n  End;\n\n  Procedure pickbest(x, y: integer);\n  Var i, j, bestsofar: integer;\n  Begin\n    bestsofar := pixcol(x, y);\n    if random(5) > 0 then\n      for i := -1 to 1 do\n        for j := -1 to 1 do\n          if (pixcol((x + width + i) mod width, (y + height + j) mod height) and $ffff00) > (bestsofar and $ffff00) then\n            bestsofar := pixcol((x + width + i) mod width, (y + height + j) mod height);\n    pixset(x, y, (pixcol(x, y) and $ffff0f) + (bestsofar and $f) * $10)\n  End;\n\n  Procedure fixbest(x, y: integer);\n  Begin\n    if (pixcol(x, y) and $10) > 0 then\n      pixset(x, y, $ff0001)\n    else if (pixcol(x, y) and $20) > 0 then\n      pixset(x, y, $00ff02)\n    else\n     pixset(x, y, $0000fc)\n  End;\n\n  Procedure setutilities;\n  Begin\n    util[1] := 3 * n;\n    util[2] := 3 * n;\n    util[3] := 3 * n;\n    util[5] := 5 * n;\n    util[6] := n + 4;\n    util[12] := n;\n    util[13] := 0;\n    util[14] := n - 1\n  End;\n\nBEGIN\n  canvas(0, 0, width, height);\n  resolution(width, height);\n  setutilities;\n  noupdate;\n  for i := 0 to width - 1 do\n    for j := 0 to height - 1 do\n      if random(50) = 0 then\n        pixset(i, j, $0000fc)\n      else if random(7) = 0 then\n        pixset(i, j, $00ff02)\n      else\n        pixset(i, j, $ff0001);\n  pause(1000);\n  while ?key <> \\escape do\n    begin\n      timeset(0);\n      noupdate;\n      for i := 0 to width - 1 do\n        for j := 0 to height - 1 do\n          utility(i, j);\n      for i := 0 to width - 1 do\n        for j := 0 to height - 1 do\n          pickbest(i, j);\n      for i := 0 to width - 1 do\n        for j := 0 to height - 1 do\n          fixbest(i, j);\n      update;\n      noupdate\n    end\nEND.\n"},function(e,n){e.exports="PROGRAM KnightsTour;\n\nCONST width = 10;  {width of board}\n      height = 10; {height of board}\n      maxlast = 255; {must be at least width*height-1}\n      delay = 0;\n      margin = 20;\n      timelimit = 500;\n      pauseonbest = 1000;\n      drawall = false;\n\nVAR vectorx, vectory: array[0..8] of integer; {vectors for 8 directions}\n    squarestatus, cleverrank: array[0..maxlast] of integer;\n    lastsquare: integer;\n    xgap, ygap, radius: integer;\n    countsquares, attempts, total, best: integer;\n    clever, pausenow: boolean;\n\n  Procedure setup;\n  Begin\n    vectorx[0] := 1;\n    vectory[0] := -2;\n    vectorx[1] := 2;\n    vectory[1] := -1;\n    vectorx[2] := 2;\n    vectory[2] := 1;\n    vectorx[3] := 1;\n    vectory[3] := 2;\n    vectorx[4] := -1;\n    vectory[4] := 2;\n    vectorx[5] := -2;\n    vectory[5] := 1;\n    vectorx[6] := -2;\n    vectory[6] := -1;\n    vectorx[7] := -1;\n    vectory[7] := -2;\n    xgap := (1000 - 2 * margin) / width;\n    ygap := (1000 - 2 * margin) / height;\n    if xgap <= ygap then\n      radius := xgap * 2 / 5\n    else\n      radius := ygap * 2 / 5;\n    lastsquare := width * height - 1\n  End;\n\n  Function findx(s: integer): integer;\n  Begin\n    result := s mod width\n  End;\n\n  Function findy(s: integer): integer;\n  Begin\n    result := s div width\n  End;\n\n  Function findsquare(x, y: integer): integer;\n  Begin\n    result := y * width + x\n  End;\n\n  Procedure drawsquare(s: integer);\n  Begin\n    setxy(margin + xgap * findx(s) + xgap / 2, margin + ygap * findy(s) + ygap / 2);\n    if squarestatus[s] = 0 then\n      begin\n        colour(salmon);\n        blot(radius)\n      end\n    else\n      begin\n        colour(white);\n        blot(radius);\n        if width > 10 then\n          begin\n            if squarestatus[s] < 10 then\n              movexy(-8, -20) {only one digit}\n            else if squarestatus[s] < 100 then\n              movexy(-15, -20) {two digits}\n            else\n              movexy(-22, -20); {three digits}\n            colour(black);\n            print(str(squarestatus[s]), 4, 20)\n          end\n        else\n          begin\n            if squarestatus[s] < 10 then\n              movexy(-10, -24) {only one digit}\n            else if squarestatus[s]<100 then\n              movexy(-20,-24) {two digits}\n            else\n              movexy(-30,-24); {three digits}\n            colour(black);\n            print(str(squarestatus[s]), 4, 25)\n          end\n      end\n  End;\n\n  Procedure drawboard;\n  Var s: integer;\n  Begin\n    blank(darkgreen);\n    for s := 0 to lastsquare do\n      drawsquare(s)\n  End;\n\n  Function goodmove(s, direction: integer): integer;\n  Var newx, newy: integer;\n  Begin\n    newx := findx(s) + vectorx[direction];\n    newy := findy(s) + vectory[direction];\n    if (newx >= 0) and (newx < width) and (newy >= 0) and (newy < height) then\n      begin\n        result := findsquare(newx, newy);\n        if squarestatus[result] > 0 then\n          result := -1\n      end\n    else\n      result := -1\n  End;\n\n  Function moveto(s, direction: integer): integer;\n  Var newx, newy: integer;\n      newn: integer; {neighbours of moveto square}\n      d: integer;\n  Begin\n    newx := findx(s) + vectorx[direction];\n    newy := findy(s) + vectory[direction];\n    result := findsquare(newx, newy); {will give error if off the board!}\n    if clever then\n      for d := 0 to 7 do\n        begin\n          newn := goodmove(result, d);\n          if newn > -1 then\n            dec(cleverrank[newn])\n        end\n  End;\n\n  Procedure clearboard;\n  Var s, d: integer;\n  Begin\n    for s := 0 to lastsquare do\n      squarestatus[s] := 0;\n    if clever then\n      for s := 0 to lastsquare do\n        begin\n          cleverrank[s] := 0;\n          for d := 0 to 7 do\n            if goodmove(s, d) > -1 then\n              inc(cleverrank[s])\n        end\n  End;\n\n  Function randommove(s: integer): integer;\n  Var d: integer;\n  Begin\n    repeat\n      d := random(8) {find legal move}\n    until (goodmove(s, d) > -1) or (time >= timelimit);\n    result := d\n  End;\n\n  Function clevermove(s: integer): integer;\n  Var chosen, d, news: integer;\n      bestrank, numbest: integer;\n  Begin\n    chosen := -1;\n    bestrank := 9;\n    for d := 0 to 8 do\n      begin\n       news := goodmove(s, d);\n        if news > -1 then\n          if cleverrank[news] < bestrank then\n            begin\n              chosen := d;\n              bestrank := cleverrank[news];\n              numbest := 1\n            end\n          else\n          if cleverrank[news] = bestrank then\n            begin\n              inc(numbest);\n              if random(numbest) = 0 then\n                chosen := d\n            end\n      end;\n    result := chosen\n  End;\n\n  Procedure findroute;\n  Var thiss, s, d: integer;\n  Begin\n    countsquares := 1;\n    thiss := random(lastsquare+1);\n    squarestatus[thiss] := countsquares;\n    timeset(0);\n    while time < timelimit do\n      begin\n        if clever then\n          d := clevermove(thiss)\n        else\n          d := randommove(thiss);\n        if (time < timelimit) and (d > -1) then\n          begin\n           thiss := moveto(thiss, d);\n           inc(countsquares);\n           squarestatus[thiss] := countsquares;\n           if drawall then\n             drawsquare(thiss)\n          end\n      end\n  End;\n\nBEGIN\n  write('Random search or Clever search? (R/C) ');\n  repeat\n  until (abs(?key) = \\r) or (abs(?key) = \\c);\n  clever := (abs(?key) = \\c);\n  if clever then\n    writeln('  Clever ...')\n  else\n    writeln('  Random ...');\n  setup;\n  if lastsquare > maxlast then\n    writeln('Error: maximum board size is ' + str(maxlast + 1) + ' squares')\n  else\n    begin\n      attempts := 0;\n      total := 0;\n      best := 0;\n      repeat\n        inc(attempts);\n        clearboard;\n        if drawall then\n          drawboard;\n        findroute;\n        total := total + countsquares;\n        pausenow := (countsquares > best);\n        if countsquares > best then\n          begin\n            drawboard;\n            best := countsquares;\n            write('Attempt ' + str(attempts) + ', score: ' + str(countsquares));\n            if attempts > 1 then\n              writeln('   (average of all attempts: ' + qstr(total, attempts, 2) + ')')\n            else\n              writeln('');\n            update\n          end;\n        if pausenow then\n          pause(pauseonbest);\n        noupdate\n      until best = width * height\n    end\nEND.\n"},function(e,n){e.exports="PROGRAM Launch;\nCONST earthradius = 6371000; {m}\n      earthGM = 398600442; {km3 / s2 * 1000}\n      initdirection = 2000; {seconds of arc}\n      initthrust = 20000; {milliN per kg}\n      thrusttime = 500;\n      angleprecision = 1296000; {seconds of arc}\nVAR x, y, d, xvel, yvel: integer;\n    thrust, xthrust, ythrust: integer;\n    gravity, xgravity, ygravity: integer;\n    xacc, yacc: integer;\n    dist, prevdist, prevdiff, t: integer;\n    explosion: integer;\n\n  Procedure drawrocket;\n  Begin\n    noupdate;\n    blank(black);\n    colour(teal);\n    setxy(0, 0);\n    blot(earthradius / 1000);\n    setxy(x / 1000, y / 1000);\n    direction(d);\n    thickness(4);\n    colour(silver);\n    forward(200);\n    back(200);\n    if thrust > 0 then\n      begin\n        thickness(8);\n        colour(yellow);\n        back(200);\n        forward(200)\n      end;\n    update\n  End;\n\n  Procedure report;\n  Begin\n    writeln('');\n    writeln('TIME = ' + str(t));\n    writeln(' Xposition = ' + str(x) + ' metres');\n    writeln(' Yposition = ' + str(y) + ' metres');\n    writeln(' Height = ' + qstr(dist - earthradius, 1000, 2) + ' km');\n    writeln(' Direction = ' + qstr(d, 3600, 1) + ' degrees');\n    writeln(' Thrust = ' + qstr(thrust, 1000, 1) + ' newtons per kg');\n    writeln('  Xthrust = ' + qstr(xthrust, 1000, 1) + ' newtons per kg');\n    writeln('  Ythrust = ' + qstr(ythrust, 1000, 1) + ' newtons per kg');\n    writeln(' Gravity = ' + qstr(gravity, 1000, 1) + ' newtons per kg');\n    writeln('  Xgravity = ' + qstr(xgravity, 1000, 1) + ' newtons per kg');\n    writeln('  Ygravity = ' + qstr(ygravity, 1000, 1) + ' newtons per kg');\n    writeln(' Xvelocity = ' + qstr(xvel, 1000, 1) + ' metres per s');\n    writeln(' Yvelocity = ' + qstr(yvel, 1000, 1) + ' metres per s')\n  End;\n\nBEGIN\n  canvas(-10000, -10000, 20000, 20000);\n  angles(angleprecision);\n  x := 0;\n  y := -earthradius; {metres}\n  xvel := 0;\n  yvel := 0;\n  d := initdirection;\n  t := 0;\n  prevdiff := 1; {so first apogee will report}\n  thrust := initthrust;\n  repeat\n    drawrocket;\n    prevdist := dist;\n    dist := hypot(x, y ,1);\n    if (dist - prevdist) * prevdiff <= 0 then\n      report;\n    prevdiff := dist - prevdist;\n    gravity := divmult(earthGM, divmult(dist, 1000000, dist), 1000);\n    xgravity := divmult(gravity, dist, -x);\n    ygravity := divmult(gravity, dist, -y);\n    xthrust := sin(d, 1, thrust);\n    ythrust := -cos(d, 1, thrust);\n    xvel := xvel + xgravity + xthrust;\n    yvel := yvel + ygravity + ythrust;\n    x := x + xvel / 1000;\n    y := y + yvel / 1000;\n    {report;}\n    if yvel > 0 then\n      d := angleprecision / 2 - arctan(xvel, yvel, 1)\n    else\n      d := arctan(xvel, -yvel, 1);\n    inc(t);\n    if t = thrusttime then\n      thrust := 0\n  until (0 = 1) or (dist < earthradius) or (dist > 40000000);\n  if dist < earthradius then\n    begin\n      colour(yellow);\n      for explosion := 100 to 200 do\n        begin\n          blot(explosion);\n          pause(3)\n        end;\n      colour(black);\n      blot(200)\n    end\nEND.\n"},function(e,n){e.exports="PROGRAM LifeStart;\nCONST width = 32;\n      height = 32;\nVAR x, y: integer;\nBEGIN\n  canvas(0, 0, width, height);\n  resolution(width, height);\n  for x := 0 to width - 1 do\n    for y := 0 to height - 1 do\n      if random(7) = 0 then\n        pixset(x, y, black)\n      else\n        pixset(x, y, white)\nEND.\n"},function(e,n){e.exports="PROGRAM Logistic;\nCONST maxpop = 100000;\n      maxgen = 100;\n      lmargin = 105;\n      rmargin = 40;\n      tmargin = 150;\n      bmargin = 200;\n      output = false;\n\nVAR gen, pop: integer;\n    r: integer;\n\n  Procedure axes;\n  Var i: integer;\n  Begin\n    colour(black);\n    for i := 0 to 10 do\n      begin\n        setxy(i * 100 - 25, 1000);\n        print(str(i * maxgen / 10), 4, 20)\n      end;\n    for i := 1 to 10 do\n      begin\n        setxy(-lmargin + 5, 1000 - i * 100 - 20);\n        print(str(i * maxpop / 10), 4, 20)\n      end;\n    setxy(0, 0);\n    drawxy(0, 1000);\n    drawxy(1000, 0);\n    colour(red);\n    setxy(0, 1060);\n    print('Population over ' + str(maxgen) + ' generations, where P (population/' + str(maxpop) + ')', 4, 25);\n    setxy(0, 1110);\n    print('is determined by the logistic equation P'' = rP(1 - P), with r = ' + qstr(r, 10, 1), 4, 25)\n  End;\n\n  Procedure menu;\n  Var i: integer;\n  Begin\n    colour(black);\n    setxy(10, -tmargin + 20);\n    print('Set r:', 4, 25);\n    for i := 21 to 40 do\n      begin\n        setxy(((i - 1) mod 10) * 90 + 130,((i - 1) div 10) * 50 - 100 - tmargin);\n        if i = r then\n          box(90, 50, red, true)\n        else\n          box(90, 50, cream, true);\n        print('  ' + qstr(i, 10, 1), 4, 25)\n      end\n  End;\n\nBEGIN\n  canvas(-lmargin, -tmargin, 1000 + lmargin + rmargin, 1000 + tmargin + bmargin);\n  resolution(1000 + lmargin + rmargin, 1000 + tmargin + bmargin);\n  thickness(3);\n  r := 30;\n  repeat\n    noupdate;\n    blank(white);\n    axes;\n    menu;\n    colour(blue);\n    pop := random(maxpop - 9) + 10;\n    if output then\n      begin\n        writeln('');\n        writeln('r = ' + qstr(r, 10, 1) + '; Initial population = ' + str(pop))\n      end;\n    setxy(0, 1000 - divmult(pop, maxpop, 1000));\n    for gen := 1 to maxgen do\n      begin\n        pop := divmult(pop, 10 * maxpop, r * (maxpop - pop));\n        setxy(divmult(gen, maxgen, 1000), 1000 - divmult(pop, maxpop, 1000));\n        polyline(2);\n        if output then\n          begin\n            write(str(pop) + ' ');\n            if gen mod 10 = 0 then\n              writeln('')\n          end\n      end;\n    heapreset;\n    update;\n    repeat\n    until (?lmouse > 0) and (?clicky < (100 - tmargin)) and (?clickx >= 130) and (?clickx < 1030);\n    r := ((?clickx - 130) div 90) + ((?clicky + tmargin + 100) div 50) * 10 + 1\n  until 0 = 1\nEND.\n"},function(e,n){e.exports="PROGRAM LogisticSpider;\nCONST maxpop = 100000;\n      maxgen = 100;\n      lmargin = 60;\n      rmargin = 40;\n      tmargin = 150;\n      bmargin = 200;\n      output = true;\n\nVAR gen, pop: integer;\n    r: integer;\n\n  Procedure axes;\n  Var i: integer;\n  Begin\n    colour(black);\n    for i := 0 to 10 do\n      begin\n        setxy(i * 100 - 25, 1000);\n        print(qstr(i, 10, 1), 4, 20)\n      end;\n    for i := 1 to 10 do\n      begin\n        setxy(-lmargin + 5, 1000 - i * 100 - 20);\n        print(qstr(i, 10, 1), 4, 20)\n      end;\n    setxy(0, 0);\n    drawxy(0, 1000);\n    drawxy(1000, 0);\n    colour(red);\n    setxy(0, 1060);\n    print('Population over ' + str(maxgen) + ' generations, where P (population/' + str(maxpop) + ')', 4, 25);\n    setxy(0, 1110);\n    print('is determined by the logistic equation P'' = rP(1 - P), with r = ' + qstr(r, 10, 1), 4, 25)\n  End;\n\n  Procedure menu;\n  Var i: integer;\n  Begin\n    colour(black);\n    setxy(10, -tmargin + 20);\n    print('Set k:', 4, 25);\n    for i := 21 to 40 do\n      begin\n        setxy(((i - 1) mod 10) * 90 + 130,((i - 1) div 10) * 50 - 100 - tmargin);\n        if i = r then\n          box(90, 50, red, true)\n        else\n          box(90, 50, cream, true);\n        print('  ' + qstr(i, 10, 1), 4, 25)\n      end\n  End;\n\n  Procedure curve;\n  Var i, pop, nextpop: integer;\n  Begin\n    noupdate;\n    colour(black);\n    setxy(0, 1000);\n    drawxy(1000, -1000);\n    colour(blue);\n    setxy(0, 1000);\n    for i := 1 to 1000 do\n      begin\n        pop := divmult(i, 1000, maxpop);\n        nextpop := divmult(pop, 10 * maxpop, r * (maxpop - pop));\n        setxy(divmult(pop, maxpop, 1000), 1000 - divmult(nextpop, maxpop, 1000));\n        polyline(2);\n      end;\n    update\n  End;\n\nBEGIN\n  canvas(-lmargin, -tmargin, 1000 + lmargin + rmargin, 1000 + tmargin + bmargin);\n  resolution(1000 + lmargin + rmargin, 1000 + tmargin + bmargin);\n  thickness(3);\n  r := 30;\n  repeat\n    noupdate;\n    blank(white);\n    axes;\n    menu;\n    curve;\n    pop := random(maxpop - 9) + 10;\n    if output then\n      begin\n        writeln('');\n        writeln('r = ' + qstr(r, 10, 1) + '; Initial population = ' + str(pop))\n      end;\n    setxy(divmult(pop, maxpop, 1000), 1000);\n    for gen := 1 to maxgen do\n      begin\n        pop := divmult(pop, 10 * maxpop, r * (maxpop - pop));\n        colour(mixcols(lightgreen, green, maxgen - gen, gen));\n        drawxy(0, 1000 - divmult(pop, maxpop, 1000) - turty);\n        drawxy(divmult(pop, maxpop, 1000) - turtx, 0);\n        if output then\n          begin\n            write(str(pop) + ' ');\n            if gen mod 10 = 0 then\n              writeln('')\n          end\n      end;\n    blot(3);\n    heapreset;\n    update;\n    repeat\n    until (?lmouse > 0) and (?clicky < (100 - tmargin)) and (?clickx >= 130) and (?clickx < 1030);\n    r := ((?clickx - 130) div 90) + ((?clicky + tmargin + 100) div 50) * 10 + 1\n  until 0 = 1\nEND.\n"},function(e,n){e.exports="PROGRAM Mandelbrot;\nCONST maxcol = 40;\n      scale = 250;\n      pixels = 750;\n      xcentre = -500000; {millionths}\n      ycentre = 0; {millionths}\nVAR xstart, xfinish, ystart, yfinish: integer;\n    a, b, x, y: integer;\n    iterations, temp: integer;\n\nBEGIN\n  xstart := divmult(xcentre, 1000000, scale) - pixels / 2;\n  ystart := divmult(ycentre, 1000000, scale) - pixels / 2;\n  xfinish := xstart + pixels - 1;\n  yfinish := ystart + pixels - 1;\n  canvas(xstart, ystart, pixels, pixels);\n  resolution(pixels, pixels);\n  timeset(0);\n  for a := xstart to xfinish do\n    begin\n      noupdate;\n      for b := ystart to yfinish do\n        begin\n          x := a;\n          y := b;\n          iterations := 0;\n          while (hypot(x, y, 1) < 2 * scale) and (iterations <= maxcol) do\n            begin\n              temp := divmult(x + y, scale, x - y);\n              y := divmult(2 * x, scale, y) + b;\n              x := temp + a;\n              inc(iterations)\n            end;\n          if iterations > maxcol then\n            pixset(a, b, black)\n          else\n            pixset(a, b, rgb(iterations + 1))\n        end;\n      update\n    end;\n  writeln('Resolution: ' + str(scale * 3) + '; Time taken: ' + qstr(time, 1000, 1) + ' seconds.')\nEND.\n"},function(e,n){e.exports="PROGRAM MandelbrotMini;\nCONST maxcol = 40;\n      scale = 10000;\n      pixels = 300;\n      xcentre = -159200;\n      ycentre = -1033000;\nVAR xstart, xfinish, ystart, yfinish: integer;\n    a, b, x, y: integer;\n    iterations, temp: integer;\n\nBEGIN\n  xstart := divmult(xcentre, 1000000, scale) - pixels / 2;\n  ystart := divmult(ycentre, 1000000, scale) - pixels / 2;\n  xfinish := xstart + pixels - 1;\n  yfinish := ystart + pixels - 1;\n  canvas(xstart, ystart, pixels, pixels);\n  resolution(pixels, pixels);\n  timeset(0);\n  for a := xstart to xfinish do\n    begin\n      noupdate;\n      for b := ystart to yfinish do\n        begin\n          x := a;\n          y := b;\n          iterations := 0;\n          while (hypot(x, y, 1) < 2 * scale) and (iterations <= maxcol) do\n            begin\n              temp := divmult(x + y, scale, x - y);\n              y := divmult(2 * x, scale, y) + b;\n              x := temp + a;\n              inc(iterations)\n            end;\n          if iterations > maxcol then\n            pixset(a, b, black)\n          else\n            pixset(a, b, rgb(iterations + 1))\n        end;\n      update\n    end;\n  writeln('Resolution: ' + str(scale * 3) + '; Time taken: ' + qstr(time, 1000, 1) + ' seconds.')\nEND.\n"},function(e,n){e.exports="PROGRAM MandelbrotMiniSpectrum;\nCONST maxcol = 100;\n      scale = 10000;\n      pixels = 300;\n      xcentre = -159200;\n      ycentre = -1033000;\n      spectrum = 7;\nVAR xstart, xfinish, ystart, yfinish: integer;\n    a, b, x, y: integer;\n    iterations, temp: integer;\n    spectcol: array[0..spectrum] of integer;\n    boundary: array[0..spectrum] of integer;\n\n  Procedure colsetup;\n  Var n: integer;\n  Begin\n    spectcol[0] := violet;\n    spectcol[1] := blue;\n    spectcol[2] := cyan;\n    spectcol[3] := lime;\n    spectcol[4] := yellow;\n    spectcol[5] := orange;\n    spectcol[6] := red;\n    spectcol[7] := violet;\n    for n := 0 to spectrum do\n      boundary[n] := divmult(maxcol, spectrum, n)\n  End;\n\n  Function mixcolour(n: integer): integer;\n  Var col1, col2: integer;\n      mix1, mix2: integer;\n  Begin\n    col2 := 0;\n    repeat\n      inc(col2)\n    until (boundary[col2] >= n) or (col2 = spectrum);\n    col1 := col2 - 1;\n    result := mixcols(spectcol[col1], spectcol[col2], boundary[col2] - n, n - boundary[col1])\n  End;\n\nBEGIN\n  colsetup;\n  xstart := divmult(xcentre, 1000000, scale) - pixels / 2;\n  ystart := divmult(ycentre, 1000000, scale) - pixels / 2;\n  xfinish := xstart + pixels - 1;\n  yfinish := ystart + pixels - 1;\n  canvas(xstart, ystart, pixels, pixels);\n  resolution(pixels, pixels);\n  timeset(0);\n  for a := xstart to xfinish do\n    begin\n      noupdate;\n      for b := ystart to yfinish do\n        begin\n          x := a;\n          y := b;\n          iterations := 0;\n          while (hypot(x, y, 1) < 2 * scale) and (iterations <= maxcol) do\n            begin\n              temp := divmult(x + y, scale, x - y);\n              y := divmult(2 * x, scale, y) + b;\n              x := temp + a;\n              inc(iterations)\n            end;\n          if iterations > maxcol then\n            pixset(a, b, black)\n          else\n            pixset(a, b, mixcolour(iterations))\n        end;\n      update\n    end;\n  writeln('Resolution: ' + str(scale * 3) + '; Time taken: ' + qstr(time, 1000, 1) + ' seconds.')\nEND.\n"},function(e,n){e.exports="PROGRAM MandelbrotSpectrum;\nCONST maxcol = 40;\n      scale = 250;\n      pixels = 750;\n      xcentre = -500000; {millionths}\n      ycentre = 0; {millionths}\n      spectrum = 7;\nVAR xstart, xfinish, ystart, yfinish: integer;\n    a, b, x, y: integer;\n    iterations, temp: integer;\n    spectcol: array[0..spectrum] of integer;\n    boundary: array[0..spectrum] of integer;\n\n  Procedure colsetup;\n  Var n: integer;\n  Begin\n    spectcol[0] := violet;\n    spectcol[1] := blue;\n    spectcol[2] := cyan;\n    spectcol[3] := lime;\n    spectcol[4] := yellow;\n    spectcol[5] := orange;\n    spectcol[6] := red;\n    spectcol[7] := violet;\n    for n := 0 to spectrum do\n      boundary[n] := divmult(maxcol, spectrum, n)\n  End;\n\n  Function mixcolour(n: integer): integer;\n  Var col1, col2: integer;\n      mix1, mix2: integer;\n  Begin\n    col2 := 0;\n    repeat\n      inc(col2)\n    until (boundary[col2] >= n) or (col2 = spectrum);\n    col1 := col2 - 1;\n    result := mixcols(spectcol[col1], spectcol[col2], boundary[col2] - n, n - boundary[col1])\n  End;\n\nBEGIN\n  colsetup;\n  xstart := divmult(xcentre, 1000000, scale) - pixels / 2;\n  ystart := divmult(ycentre, 1000000, scale) - pixels / 2;\n  xfinish := xstart + pixels - 1;\n  yfinish := ystart + pixels - 1;\n  canvas(xstart, ystart, pixels, pixels);\n  resolution(pixels, pixels);\n  timeset(0);\n  for a := xstart to xfinish do\n    begin\n      noupdate;\n      for b := ystart to yfinish do\n        begin\n          x := a;\n          y := b;\n          iterations := 0;\n          while (hypot(x, y, 1) < 2 * scale) and (iterations <= maxcol) do\n            begin\n              temp := divmult(x + y, scale, x - y);\n              y := divmult(2 * x, scale, y) + b;\n              x := temp + a;\n              inc(iterations)\n            end;\n          if iterations > maxcol then\n            pixset(a, b, black)\n          else\n            pixset(a, b, mixcolour(iterations))\n        end;\n      update\n    end;\n  writeln('Resolution: ' + str(scale * 3) + '; Time taken: ' + qstr(time, 1000, 1) + ' seconds.')\nEND.\n"},function(e,n){e.exports="PROGRAM MathFunctions;\nCONST decimals = 4;\n      denominator = 1000000;\nVAR count: integer;\n    a, b, c: integer;\n\n  Procedure show(s: string; n: integer);\n  Begin\n    writeln(s + '(' + str(a) + '/' + str(b) + ') = ' + qstr(n, denominator, decimals))\n  End;\n\n  Procedure selectab;\n  Begin\n    a := random(900) + 100;\n    b := random(900) + 100\n  End;\n\nBEGIN\n  output(true, white, true);\n  writeln('This program selects two random numbers a and b, in the');\n  writeln('range 100-999, and then outputs various mathematical');\n  writeln('functions of the fraction a/b. The results are expressed');\n  writeln('to ' + str(decimals) + ' decimal places, and a denominator of ' + str(denominator) + ' is');\n  writeln('used in the calculations to provide precision, even');\n  writeln('though the Turtle functions strictly operate only on');\n  writeln('integers and produce integer results.');\n  writeln('');\n  selectab;\n  writeln('a=' + str(a) + '; b=' + str(b));\n  writeln('a/b = ' + str(a) + '/'+str(b) + ' = ' + qstr(a, b, decimals));\n  writeln('');\n  show('square', power(a, b, 2, denominator));\n  show('square root', root(a, b, 2, denominator));\n  show('cube', power(a, b, 3, denominator));\n  show('cube root', root(a, b, 3, denominator));\n  writeln('');\n  show('hypot', hypot(a, b, denominator));\n  show('calculated hypot', sqrt(a * a + b * b, denominator));\n  writeln('');\n  show('sin', sin(a, b, denominator));\n  show('cos', cos(a, b, denominator));\n  show('tan', tan(a, b, denominator));\n  writeln('');\n  show('ln', ln(a, b, denominator));\n  if divmult(a, b, 1000) + ln(denominator, 1, 1000) > ln(maxint, 1, 1000) then\n    begin\n      writeln('EXP(' + str(a) + '/' + str(b) + ') would give numerical overflow, because');\n      writeln('the result*' + str(denominator) + ' would be greater than ' + str(maxint))\n    end\n  else\n    show('exp', exp(a, b, denominator));\n  show('log10', log10(a, b, denominator));\n  if divmult(a, b, 1000) + log10(denominator, 1, 1000) > log10(maxint, 1, 1000) then\n    begin\n      writeln('ANTILOG(' + str(a) + '/' + str(b) + ') would give numerical overflow, because');\n      writeln('the result*' + str(denominator) + ' would be greater than ' + str(maxint))\n    end\n  else\n    show('antilog', antilog(a, b, denominator));\n  writeln('');\n  if a > b then\n    writeln('ARCCOS and ARCSIN are not defined for ' + str(a) + '/' + str(b) + ' = ' + qstr(a, b, decimals))\n  else\n    begin\n      show('arccos', arccos(a, b, denominator));\n      show('arcsin', arcsin(a, b, denominator))\n    end;\n  show('arctan', arctan(a, b, denominator))\nEND.\n"},function(e,n){e.exports="PROGRAM MovingBall;\nVAR x, y, count: integer;\nBEGIN\n  x := 100;\n  y := 700;\n  for count := 1 to 100 do\n    begin\n      noupdate;\n      colour(white);\n      blot(51);\n      x := x + 8;\n      y := y - 4;\n      setxy(x, y);\n      colour(red);\n      blot(50);\n      update;\n      pause(10)\n    end\nEND.\n"},function(e,n){e.exports="PROGRAM MultiBounce;\nVAR xpos1, xvel1: integer;\n    ypos1, yvel1: integer;\n    xpos2, xvel2: integer;\n    ypos2, yvel2: integer;\n\n  Procedure doball(size, col: integer; var xp, xv, yp, yv: integer);\n  Begin\n    setxy(xp, yp);\n    colour(white);\n    blot(size + 1);\n    xp := xp + xv;\n    yp := yp + yv;\n    setxy(xp, yp);\n    colour(col);\n    blot(size);\n    update;\n    noupdate;\n    if (xp < size) or (xp > 1000 - size) then\n      xv := -xv;\n    if (yp < size) or (yp > 1000 - size) then\n      yv := -yv\n  End;\n\nBEGIN\n  xpos1 := 20;\n  xvel1 := 2;\n  ypos1 := 200;\n  yvel1 := -3;\n  xpos2 := 400;\n  xvel2 := -4;\n  ypos2 := 800;\n  yvel2 := 1;\n  repeat\n    doball(20, blue, xpos1, xvel1, ypos1, yvel1);\n    doball(30, red, xpos2, xvel2, ypos2, yvel2)\n  until 1 = 0\nEND.\n"},function(e,n){e.exports="PROGRAM NestedLoops;\nVAR countblot: integer;\n    countcirc: integer;\nBEGIN\n  penup;\n  for countblot := 1 to 10 do\n    begin\n      forward(260);\n      colour(black);\n      blot(150);\n      colour(rgb(countblot));\n      for countcirc := 1 to 25 do\n        circle(countcirc * 8);\n      back(260);\n      right(36)\n    end\nEND.\n"},function(e,n){e.exports="PROGRAM Nim;\nCONST piles = 5;\n      maxheight = 8;\n      margin = 20;\nVAR pile: array[1..piles] of integer;\n    xgap, ygap, left, bottom, radius: integer;\n    totalcoins: integer;\n    xorscore: integer;\n    showmaths: boolean;\n    thiscolour, thispile, thiscoin: integer;\n    autopile, autocoin: integer;\n\n  Procedure setup;\n  Begin\n    xgap := (1000 - 2 * margin) div piles;\n    ygap := (800 - margin) div maxheight;\n    if ygap * maxheight > 800 then\n      ygap := 800 div maxheight;\n    radius := (ygap - margin) div 2;\n    left := margin + radius - xgap;\n    bottom := 800 - radius + ygap;\n    showmaths := false\n  End;\n\n  Procedure fixpiles;\n  Var p: integer;\n  Begin\n    for p := 1 to piles do\n      pile[p] := random(maxheight) + 1\n  End;\n\n  Procedure domaths;\n  Var p: integer;\n  Begin\n    totalcoins := 0;\n    xorscore := 0;\n    for p := 1 to piles do\n      begin\n        totalcoins := totalcoins + pile[p];\n        xorscore := xorscore xor pile[p]\n      end\n  End;\n\n  Procedure drawpiles;\n  Var p, c, autocount: integer;\n  Begin\n    blank(white);\n    autocount := random(totalcoins) + 1;\n    for p := 1 to piles do\n      begin\n        c := pile[p];\n        while c > 0 do\n          begin\n            dec(autocount);\n            if autocount = 0 then\n              begin\n                autopile := p;\n                autocoin := c\n              end;\n            setxy(left + xgap * p, bottom - ygap * c);\n            colour(rgb(p));\n            blot(radius);\n            if xorscore xor pile[p] xor (c - 1) = 0 then\n              begin\n                autopile := p;\n                autocoin := c;\n                autocount := 0\n              end;\n            if showmaths then\n              begin\n                movexy(radius + margin, -radius + 15);\n                colour(black);\n                print(str(xorscore xor pile[p] xor (c - 1)), 4, 20)\n              end;\n            dec(c)\n          end\n      end;\n    colour(black);\n    setxy(margin, 900);\n    print('Total Coins:  ' + str(totalcoins), 4, 30);\n    if showmaths then\n      begin\n        colour(black);\n        setxy(450, 900);\n        print('XOR score:  ' + str(xorscore), 4, 30);\n        setxy(850, 890);\n        colour(maroon);\n        box(140, 100, red, true);\n        print(' HIDE', 4, 25);\n        setxy(850, 940);\n        print(' MATHS', 4, 25)\n      end\n    else\n      begin\n        colour(maroon);\n        setxy(850, 890);\n        box(140, 100, red, true);\n        print(' SHOW', 4, 25);\n        setxy(850, 940);\n        print(' MATHS', 4, 25)\n      end\n  End;\n\n  Procedure blackout(p, c: integer);\n  Begin\n    setxy(left + xgap * p, bottom - ygap * c);\n    colour(black);\n    blot(radius)\n  End;\n\nBEGIN\n  setup;\n  repeat {start new game}\n    fixpiles;\n    repeat {present current position}\n      domaths;\n      drawpiles;\n      repeat\n        cursor(2); {handpoint}\n        repeat\n          repeat\n          until ?lmouse > 0; {wait for mouse click}\n          pause(200);\n          thiscolour := pixcol(?clickx, ?clicky);\n        until (thiscolour <> rgb(white)) and (thiscolour <> rgb(black));\n        cursor(11); {waiting cursor}\n        if ?clicky >= 800 then\n          begin\n            thiscoin := maxheight + 1; {choose illegal move}\n            showmaths := not(showmaths);\n            domaths;\n            drawpiles\n          end\n        else\n          begin\n            thispile := (?clickx - margin + radius) div xgap + 1;\n            thiscoin := (bottom - radius - ?clicky) div ygap + 1\n          end\n      until (?clicky < 800);\n      pile[thispile] := thiscoin - 1;\n      domaths;\n      if totalcoins = 0 then\n        begin\n          blank(white);\n          setxy(330, 850);\n          colour(blue);\n          print('You Win!', 4, 60);\n          pause(5000)\n        end\n      else\n        begin\n          drawpiles;\n          pause(1000);\n          blackout(autopile, autocoin);\n          pile[autopile] := autocoin - 1;\n          domaths;\n          if (xorscore = 0) and not(showmaths) then\n            begin\n              colour(pink);\n              setxy(400, 900);\n              print('I''m going to win!', 4, 30)\n            end;\n          pause(2500);\n          if totalcoins = 0 then\n            begin\n              blank(white);\n              setxy(330, 850);\n              colour(red);\n              print('I Win!', 4, 60);\n              pause(5000)\n            end\n        end;\n    until totalcoins = 0\n  until 0 = 1\nEND.\n"},function(e,n){e.exports="PROGRAM NoughtsAndCrosses;\nCONST cross = royal;\n      nought = red;\nVAR board: array[0..11] of integer;\n    numgames: integer;\n    randfirst: boolean;\n    i, column, row: integer;\n\n  Procedure doblot(x, y, col: integer);\n  Begin\n    setxy(x * 250 + 250, y * 250 + 175);\n    colour(col);\n    blot(70)\n  End;\n\n  Procedure copy(var fromarray, toarray: array of integer);\n  Var i: integer;\n  Begin\n    for i := 0 to fromarray.length - 1 do\n      toarray[i] := fromarray[i]\n  End;\n\n  Procedure evaluate(var b1: array of integer; jm, depth: integer);\n  Var mover: integer;\n      replyscore: integer;\n      b2: array[0..11] of integer;\n      m: integer;\n  Begin\n    mover := cross + nought - jm;\n    replyscore := -2;\n    b1[9] := 0;\n    b1[10] := -1;\n    b1[11] := depth;\n    if (((b1[0] = jm) and (b1[1] = jm) and (b1[2] = jm)) or ((b1[3] = jm) and (b1[4] = jm) and (b1[5] = jm)) or ((b1[6] = jm)\n       and (b1[7] = jm) and (b1[8] = jm)) or ((b1[0] = jm) and (b1[3] = jm) and (b1[6] = jm)) or ((b1[1] = jm) and (b1[4] = jm)\n       and (b1[7] = jm)) or ((b1[2] = jm) and (b1[5] = jm) and (b1[8] = jm)) or ((b1[0] = jm) and (b1[4] = jm) and (b1[8] = jm))\n       or ((b1[2] = jm) and (b1[4] = jm) and (b1[6] = jm))) then\n      b1[9] := 1\n    else\n      begin\n        m := 0;\n        repeat\n          if (b1[m] = 0) then\n            begin\n              copy(b1, b2);\n              b2[m] := mover;\n              evaluate(b2, mover, depth + 1);\n              if (b2[9] > replyscore) then\n                begin\n                  replyscore := b2[9];\n                  b1[10] := m;\n                  b1[11] := b2[11]\n                end\n            end;\n          m := m + 1\n        until (m > 8) or (replyscore > 0);\n        if (replyscore <> -2) then\n          b1[9] := -replyscore\n      end\n  End;\n\nBEGIN\n  numgames := 0;\n  repeat\n    numgames := numgames + 1;\n    randfirst := (numgames mod 2 = 1);\n    blank(lightgreen);\n    thickness(10);\n    colour(black);\n    setxy(375, 50);\n    drawxy(0, 750);\n    setxy(625, 50);\n    drawxy(0, 750);\n    setxy(125, 300);\n    drawxy(750, 0);\n    setxy(125, 550);\n    drawxy(750, 0);\n    for i := 0 to 10 do\n      board[i] := 0;\n    board[11] := 8;\n    repeat\n      if (randfirst) then\n        begin\n          randcol(9);\n          board[10] := turtc - 1;\n          randfirst := false\n        end\n      else\n        begin\n          cursor(2);\n          repeat\n            repeat\n              repeat\n              until ?lmouse > 0;\n              pause(200)\n            until ((?clickx >= 125) and (?clickx <= 875) and (?clicky >= 50) and (?clicky <= 800));\n            column := (?clickx - 125) div 250;\n            row := (?clicky - 50) div 250\n          until board[column + row * 3] = 0;\n          doblot(column, row, cross);\n          board[column + row * 3] := cross;\n          cursor(11);\n          evaluate(board, cross, 0)\n        end;\n      if (board[10] <> -1) then\n        begin\n          doblot(board[10] mod 3, board[10] div 3, nought);\n          board[board[10]] := nought\n        end\n    until (board[11] <= 1);\n    setxy(350, 850);\n    colour(black);\n    if (board[9] = 0) then\n      print('  Draw!  ', 4, 60)\n    else\n      print('  I win!  ', 4, 60);\n    pause(2500)\n  until (1 <> 1)\nEND.\n"},function(e,n){e.exports="PROGRAM OlympicRings1;\nBEGIN\n  thickness(20);\n  penup;\n  forward(50);\n  circle(130);\n  left(90);\n  forward(300);\n  colour(blue);\n  circle(130);\n  back(600);\n  colour(red);\n  circle(130);\n  forward(150);\n  right(90);\n  back(125);\n  colour(lime);\n  circle(130);\n  left(90);\n  forward(300);\n  colour(yellow);\n  circle(130)\nEND.\n"},function(e,n){e.exports="PROGRAM OlympicRings2;\nVAR ringsize: integer;\nBEGIN\n  ringsize := 130;\n  thickness(20);\n  penup;\n  forward(50);\n  circle(ringsize);\n  left(90);\n  forward(300);\n  colour(blue);\n  circle(ringsize);\n  back(600);\n  colour(red);\n  circle(ringsize);\n  forward(150);\n  right(90);\n  back(125);\n  colour(lime);\n  circle(ringsize);\n  left(90);\n  forward(300);\n  colour(yellow);\n  circle(ringsize)\nEND.\n"},function(e,n){e.exports="PROGRAM PaintApp;\nVAR brushwidth: integer;\n    brushcolour: integer;\n\n  Procedure setbrushwidth(wdth: integer);\n  Var count: integer;\n  Begin\n    brushwidth := wdth;\n    noupdate;\n    colour(black);\n    for count := 0 to 4 do\n      begin\n        setxy(625 + count * 50, 875);\n        blot(8 + count * 2)\n      end;\n    colour(brushcolour);\n    recolour(((brushwidth + 16) * 25) + 25, 875, lightred);\n    update\n  End;\n\n  Procedure setbrushcolour(clr: integer);\n  Begin\n    brushcolour := clr;\n    colour(clr);\n    setxy(975, 875);\n    blot(16)\n  End;\n\n  Procedure paintbrush(x: integer; y: integer);\n  Begin\n    setxy(x, y);\n    blot(brushwidth)\n  End;\n\n  Procedure paintcan(x: integer; y: integer);\n  Begin\n    recolour(x, y, brushcolour)\n  End;\n\n  Procedure setup;\n  Var count: integer;\n\n    procedure square(col: integer);\n    begin\n      movexy(50, 0);\n      movexy(0, 50);\n      movexy(-50, 0);\n      movexy(0, -50);\n      colour(col);\n      polygon(4)\n    end;\n\n    procedure text(input: string);\n    begin\n      colour(black);\n      print(input, 0, 20)\n    end;\n\n  Begin\n    colour(lightred);\n    setxy(0, 850);\n    drawxy(1000, 0);\n    setxy(0, 900);\n    drawxy(1000, 0);\n    setxy(450, 850);\n    drawxy(0, 50);\n    setxy(850, 850);\n    drawxy(0, 50);\n    setxy(10, 858);\n    text('Left-click to draw, right-click to fill');\n    setxy(450 + 10, 858);\n    text('Brush width:');\n    setxy(850 + 10, 858);\n    text('Colour:');\n    setxy(0, 900);\n    for count := 1 to 20 do\n      begin\n        square(rgb(count));\n        movexy(0, 50);\n        square(rgb(count + 30));\n        movexy(50, -50)\n      end;\n    setbrushwidth(8);\n    setbrushcolour(black)\n  End;\n\nBEGIN\n  setup;\n  repeat\n    if ?lmouse > 0 then\n      begin\n        if ?mousey > 900 then\n          setbrushcolour(pixcol(?mousex, ?mousey))\n        else\n          if (?mousey > 850) and ((?mousex > 600) and (?mousex < 850)) then\n          setbrushwidth(((?mousex div 50) * 2) - 16)\n        else\n          if ?mousey < 850 - brushwidth then\n          paintbrush(?mousex, ?mousey)\n      end;\n    if (?rmouse > 0) and (?mousey < 850) then\n      paintcan(?mousex, ?mousey);\n  until false\nEND.\n"},function(e,n){e.exports="PROGRAM ParameterProcedure;\nVAR count: integer;\n\n  Procedure prong(len: integer);\n  Begin\n    forward(len);\n    blot(len div 20);\n    back(len)\n  End;\n\nBEGIN\n  for count := 360 downto 1 do\n    begin\n      randcol(10);\n      prong(count + 100);\n      right(61)\n    end\nEND.\n"},function(e,n){e.exports="PROGRAM PolygonRings;\n\n  Procedure annulus(inner, width, angle: integer);\n  Var count: integer;\n  Begin\n    for count := 0 to 360 div angle do\n      begin\n        forward(inner + width);\n        back(width);\n        back(inner);\n        forget(1);\n        right(angle);\n        forward(inner);\n        forward(width);\n        colour(rgb(count mod 20 + 1));\n        polygon(4);\n        back(inner + width)\n      end\n  End;\n\nBEGIN\n  penup;\n  blot(500);\n  randcol(6);\n  annulus(410, 80, 2);\n  annulus(310, 80, 3);\n  annulus(210, 80, 5);\n  annulus(110, 80, 7);\n  annulus(10, 80, 1)\nEND.\n"},function(e,n){e.exports="PROGRAM Polygons;\n\n  Procedure poly(points, col: integer);\n  Var count: integer;\n  Begin\n    direction(90);\n    for count := 1 to points do\n      begin\n        forward(600 div points);\n        left(360 div points)\n      end;\n    colour(col);\n    polygon(points);\n    colour(black);\n    polyline(points + 1)\n  End;\n\nBEGIN\n  penup;\n  thickness(4);\n  setxy(100, 400);\n  poly(3, blue);\n  setxy(400, 400);\n  poly(4, red);\n  setxy(700, 400);\n  poly(5, yellow);\n  setxy(150, 750);\n  poly(6, pink);\n  setxy(440, 750);\n  poly(7, green);\n  setxy(740, 750);\n  poly(8, turquoise)\nEND.\n"},function(e,n){e.exports="PROGRAM Quine;\nVAR lines: array[0..14] of string;\n    i: integer;\nBEGIN\n  output(true, cream, true);\n  lines[0] := 'PROGRAM Quine;';\n  lines[1] := 'VAR lines: array[0..14] of string;';\n  lines[2] := '    i: integer;';\n  lines[3] := 'BEGIN';\n  lines[4] := '  output(true, cream, true);';\n  lines[5] := '  for i := 0 to 4 do';\n  lines[6] := '    writeln(lines[i]);';\n  lines[7] := '  for i := 0 to 14 do';\n  lines[8] := '    writeln(chr(32) + chr(32) + lines[12] + str(i) + lines[13] + chr(39) + lines[i] + chr(39) + lines[14]);';\n  lines[9] := '  for i := 5 to 11 do';\n  lines[10] := '    writeln(lines[i])';\n  lines[11] := 'END.';\n  lines[12] := 'lines[';\n  lines[13] := '] := ';\n  lines[14] := ';';\n  for i := 0 to 4 do\n    writeln(lines[i]);\n  for i := 0 to 14 do\n    writeln(chr(32) + chr(32) + lines[12] + str(i) + lines[13] + chr(39) + lines[i] + chr(39) + lines[14]);\n  for i := 5 to 11 do\n    writeln(lines[i])\nEND.\n"},function(e,n){e.exports="PROGRAM RefParams;\n\n  Procedure lines(var style: integer; convert: boolean);\n  Var count: integer;\n  Begin\n    for count := 1 to 8 do\n      begin\n        if convert then\n          style := rgb(count)\n        else\n          style := count;\n        forward(50);\n        pause(100)\n      end\n  End;\n\n  Procedure dots(var coord: integer);\n  Var count: integer;\n  Begin\n    for count := 1 to 8 do\n      begin\n        coord := coord + 100;\n        blot(40);\n        pause(100)\n      end\n  End;\n\nBEGIN\n  setxy(100, 900);\n  lines(turtt, false);\n  lines(turtc, true);\n  dots(turtx);\n  dots(turty)\nEND.\n"},function(e,n){e.exports="PROGRAM Schelling;\nCONST width = 32;\n      height = 32;\n      empty = green;\nVAR test, tryi, tryj: integer;\n    this, i, j: integer;\n\n  Function happy(x, y, c: integer): boolean;\n  Var like, unlike, neighbour, i, j: integer;\n  Begin\n    like := 0;\n    unlike := 0;\n    for i := -1 to 1 do\n      for j := -1 to 1 do\n        if (i <> 0) or (j <> 0) then\n          begin\n            neighbour := pixcol(x + i, y + j);\n            if neighbour <> empty then\n              begin\n                if neighbour = c then\n                  inc(like)\n                else\n                  inc(unlike)\n              end\n          end;\n    result := (like >= unlike - 1)\n  End;\n\nBEGIN\n  canvas(-1, -1, width + 2, height + 2);\n  resolution(width + 2, height + 2);\n  noupdate;\n  blank(empty);\n  for i := 0 to width - 1 do\n    for j := 0 to height - 1 do\n      begin\n        test := random(25);\n        if test = 0 then\n          pixset(i, j, empty)\n        else\n          begin\n            if (i + j) mod 2 = 0 then\n              pixset(i, j, red)\n            else\n              pixset(i, j, blue)\n          end\n      end;\n  pause(2000);\n  while ?key <> \\escape do\n    begin\n      noupdate;\n      repeat\n        tryi := random(width);\n        tryj := random(height);\n        this := pixcol(tryi, tryj)\n      until (this <> empty) and (not(happy(tryi, tryj, this)));\n      pixset(tryi, tryj, empty);\n      repeat\n        tryi := random(width);\n        tryj := random(height)\n      until (pixcol(tryi, tryj) = empty) and happy(tryi, tryj, this);\n      pixset(tryi, tryj, this);\n      update\n    end\nEND.\n"},function(e,n){e.exports="PROGRAM SexRatio;\nCONST population = 1000;\n      matepergen = 400;\n      randomvar = 1; {%}\n      leftmargin = 70;\n      topmargin = 20;\nVAR female: array[1..population] of boolean;\n    fop: array[1..population] of integer;\n    generation: integer;\n    n: integer;\n\n  Procedure axes;\n  Var i: integer;\n  Begin\n    for i := 1 to 9 do\n      begin\n        setxy(leftmargin + i * 100 - 25, topmargin + 800);\n        print(str(i * 100), 4, 20)\n      end;\n    for i := 2 to 10 do\n      begin\n        setxy(0, 1000 - i * 100);\n        colour(black);\n        print(str(i * 10) + '%', 4, 20);\n        movexy(leftmargin, topmargin);\n        colour(lightgrey);\n        drawxy(1000 - leftmargin, 0)\n      end;\n    setxy(leftmargin, topmargin);\n    colour(black);\n    drawxy(0, 800);\n    drawxy(1000 - leftmargin, 0);\n    colour(red);\n    setxy(50, 880);\n    print('Proportion of Females in Population, over 900 Generations', 4, 25);\n    setxy(50, 930);\n    print('with Female Offspring Probability genes initially set 90%+', 4, 25)\n  End;\n\n  Procedure graph;\n  VAR females, n: integer;\n  Begin\n    females := 0;\n    for n := 1 to population do\n      if female[n] then\n        inc(females);\n    colour(red);\n    setxy(leftmargin + generation, topmargin + 1000 - females);\n    if generation > 0 then\n      polyline(2)\n  End;\n\n  Procedure domating;\n  Var A, B, replace: integer;\n      inheritA: boolean;\n  Begin\n    repeat\n      A := random(population) + 1;\n      B := random(population) + 1\n    until female[A] <> female[B];\n    inheritA := (random(2) = 0);\n    replace := random(population) + 1;\n    if inheritA then\n      fop[replace] := fop[A]\n    else\n      fop[replace] := fop[B];\n    female[replace] := fop[replace] > random(1000);\n    fop[replace] := fop[replace] + random(randomvar * 20 + 1) - randomvar * 10;\n    fop[replace] := max(0, min(1000, fop[replace]))\n  End;\n\nBEGIN\n  axes;\n  for n := 1 to population do\n    begin\n      female[n] := (random(2) = 0);\n      fop[n] := 900 + random(101) {900/1000 minimum}\n    end;\n  generation := 0;\n  repeat\n    graph;\n    inc(generation);\n    for n := 1 to matepergen do\n      domating;\n  until generation = 900\nEND.\n"},function(e,n){e.exports="PROGRAM Shoot;\nCONST targets = 10;\nVAR facex, facey: integer;\n    facexspeed, faceyspeed: integer;\n    hits, i: integer;\n\n  Procedure bottle(x, y: integer);\n  Begin\n    setxy(x, y);\n    colour(cyan);\n    movexy(0, -15);\n    thickness(40);\n    drawxy(0, -50);\n    thickness(10);\n    drawxy(0, -40);\n    thickness(2);\n    movexy(-20, 90);\n    movexy(40, 0);\n    movexy(0, -20);\n    movexy(-40, 0);\n    colour(purple);\n    polygon(4);\n    movexy(20, 35)\n  End;\n\n  Procedure addhat;\n  Begin\n    setxy(facex, facey - 80);\n    colour(darkgrey);\n    ellblot(90, 30);\n    thickness(2);\n    colour(black);\n    ellipse(90, 30);\n    movexy(-70, 0);\n    thickness(4);\n    drawxy(35, -70);\n    drawxy(70, 0);\n    drawxy(35, 70);\n    colour(darkgrey);\n    thickness(1);\n    polygon(4)\n  End;\n\n  Procedure face;\n  Begin\n    thickness(1);\n    colour($ff8899);\n    blot(100);\n    colour(white);\n    setxy(facex - 20, facey - 20);\n    blot(10);\n    colour(black);\n    blot(4);\n    thickness(4);\n    movexy(0, -22);\n    colour($663300);\n    drawxy(15, 15);\n    thickness(1);\n    colour(white);\n    setxy(facex + 20, facey - 20);\n    blot(10);\n    colour(black);\n    blot(4);\n    thickness(4);\n    movexy(0, -22);\n    colour($663300);\n    drawxy(-15, 15);\n    addhat;\n    setxy(facex, facey + 13);\n    colour(red);\n    blot(10);\n    movexy(0, 32);\n    ellblot(30, 6);\n    colour(white);\n    ellblot(20, 4)\n  End;\n\n  Procedure background;\n  Begin\n    blank(coffee);\n    bottle(100, 500);\n    bottle(200, 500);\n    bottle(450, 500);\n    bottle(500, 500);\n    bottle(565, 500);\n    bottle(865, 500);\n    colour(darkbrown);\n    thickness(20);\n    setxy(0, 125);\n    drawxy(1000, 0);\n    setxy(0, 325);\n    drawxy(1000, 0);\n    setxy(0, 525);\n    drawxy(1000, 0);\n    colour(brown);\n    thickness(30);\n    setxy(0, 100);\n    drawxy(1000, 0);\n    setxy(0, 300);\n    drawxy(1000, 0);\n    setxy(0, 500);\n    drawxy(1000, 0)\n  End;\n\n  Procedure gunsight;\n  Begin\n    colour(black);\n    thickness(6);\n    setxy(?mousex - 50, ?mousey);\n    drawxy(100, 0);\n    setxy(?mousex, ?mousey - 50);\n    drawxy(0, 100)\n  End;\n\nBEGIN\n  facex := -100;\n  facey := 625;\n  facexspeed := 5;\n  faceyspeed := 0;\n  hits := 0;\n  cursor(0);\n  while hits < targets do\n    begin\n      noupdate;\n      background;\n      setxy(facex, facey);\n      face;\n      for i := 1 to hits do\n        bottle(50 * i - 35, 740);\n      colour(brown);\n      thickness(272);\n      setxy(0, 863);\n      drawxy(1000, 0);\n      gunsight;\n      thickness(2);\n      update;\n      facex := facex + facexspeed;\n      facey := facey + faceyspeed;\n      if facex > 1100 then\n        facex := -100;\n      if facex < -100 then\n        facex := 1100;\n      if (facey < 100) or (facey > 625) then\n        faceyspeed := faceyspeed * -1;\n      if ((?lmouse > 0) and (((?mousex - facex) * (?mousex - facex)) + ((?mousey - facey) * (?mousey - facey)) < 10000)) then\n        begin\n          facex := -100;\n          facexspeed := random(5) + 2;\n          faceyspeed := random(9) - 4;\n          facey := random(550) + 50;\n          inc(hits)\n        end\n    end;\n  blank(black);\n  setxy(200, 450);\n  colour(green);\n  print('  Well done!  ', 4, 75)\nEND.\n"},function(e,n){e.exports="PROGRAM Sierpinski;\n\n  Procedure triangle(x1, y1, x2, y2, x3, y3: integer);\n  var x12, y12, x23, y23, x31, y31: integer;\n  Begin\n    setxy(x1, y1);\n    setxy(x2, y2);\n    setxy(x3, y3);\n    setxy(x1, y1);\n    colour(black);\n    polyline(4);\n    if hypot(x2 - x1, y2 - y1, 1) > 3 then\n      begin\n        x12 := (x1 + x2) / 2;\n        y12 := (y1 + y2) / 2;\n        x23 := (x2 + x3) / 2;\n        y23 := (y2 + y3) / 2;\n        x31 := (x3 + x1) / 2;\n        y31 := (y3 + y1) / 2;\n        setxy(x12, y12);\n        setxy(x23, y23);\n        setxy(x31, y31);\n        colour(white);\n        polygon(3);\n        triangle(x1, y1, x12, y12, x31, y31);\n        triangle(x2, y2, x23, y23, x12, y12);\n        triangle(x3, y3, x31, y31, x23, y23)\n      end\n  End;\n\nBEGIN\n  blank(cream);\n  thickness(1);\n  triangle(400, 138, 843, 650, 179, 778)\nEND.\n"},function(e,n){e.exports="PROGRAM SierpinskiColour;\nCONST xleft = 0;\n      xright = 999;\n      ytop = 0;\n      ybottom = 999;\n      scaledown = 4;\n      mappings = 3;\n      title = 'Sierpinski triangle';\n      gridlines = 5;\n      gridthick = 64;\nVAR xl, xr, yt, yb, gt: integer;\n    coeffdiv: integer;\n    mapxx, mapxy, mapxc: array[1..mappings] of integer;\n    mapyx, mapyy, mapyc: array[1..mappings] of integer;\n    count: integer;\n\n  Procedure setmaps;\n  Begin\n    coeffdiv := 100;\n    mapxx[1] := 50;\n    mapyx[1] := 0;\n    mapxy[1] := 0;\n    mapyy[1] := 50;\n    mapxc[1] := 250;\n    mapyc[1] := 0;\n    mapxx[2] := 50;\n    mapyx[2] := 0;\n    mapxy[2] := 0;\n    mapyy[2] := 50;\n    mapxc[2] := 0;\n    mapyc[2] := 500;\n    mapxx[3] := 50;\n    mapyx[3] := 0;\n    mapxy[3] := 0;\n    mapyy[3] := 50;\n    mapxc[3] := 500;\n    mapyc[3] := 500\n  End;\n\n  Procedure setscale;\n  Var i: integer;\n  Begin\n    xl := xleft / scaledown;\n    xr := xright / scaledown;\n    yt := ytop / scaledown;\n    yb := ybottom / scaledown;\n    for i := 1 to mappings do\n      begin\n        mapxc[i] := mapxc[i] / scaledown;\n        mapyc[i] := mapyc[i] / scaledown\n      end;\n    gt := gridthick / scaledown\n  End;\n\n  Procedure background(rad: integer);\n  Var x, y, cx, cy, r, g, b: integer;\n  Begin\n    thickness(gt);\n    colour(darkgrey);\n    for x := 1 to gridlines - 1 do\n      begin\n        setxy(xl + divmult(xr - xl, gridlines, x), yt);\n        drawxy(0, yb - yt)\n      end;\n    for y := 1 to gridlines - 1 do\n      begin\n        setxy(xl + gt / 2, yt + divmult(yb - yt, gridlines, y));\n        drawxy(xr - xl - gt, 0)\n      end;\n    colour(black);\n    setxy(xl, yt);\n    drawxy(xr - xl, 0);\n    drawxy(0, yb - yt);\n    drawxy(xl - xr, 0);\n    drawxy(0, yt - yb);\n    for x := 0 to gridlines - 1 do\n      for y := 0 to gridlines - 1 do\n        begin\n          xc := xl + divmult(xr - xl, gridlines, x) + gt;\n          cy := yt + divmult(yb - yt, gridlines, y) + gt;\n          r := divmult(255, gridlines - 1, x);\n          g := divmult(255, gridlines - 1, y);\n          b := divmult(255, 2 * gridlines - 2, 2 * gridlines - 2 - x - y);\n          recolour(cx, cy, (r * $10000) + (g * $100) + (b * $1))\n        end\n  End;\n\n  Procedure map(a, x, y: integer; var newx, newy: integer);\n  Begin\n    newx := divmult(x, coeffdiv, mapxx[a]) + divmult(y, coeffdiv, mapxy[a]) + mapxc[a];\n    newy := divmult(x, coeffdiv, mapyx[a]) + divmult(y, coeffdiv, mapyy[a]) + mapyc[a]\n  End;\n\n  Procedure domap(mapnum: integer);\n  Var x, y, newx, newy: integer;\n  Begin\n    noupdate;\n    for y := yt to yb do\n      for x := xl to xr do\n        begin\n          map(mapnum, x, y, newx, newy);\n          pixset(newx, newy, pixcol(x, y))\n        end;\n    update\n  End;\n\nBEGIN\n  setmaps;\n  setscale;\n  canvas(xl, yt, xr - xl + 1, yb - yt + 1);\n  resolution(xr - xl + 1, yb - yt + 1);\n  background(6);\n  writeln(title + ' mappings in colour');\n  for count := 1 to mappings do\n    domap(count)\nEND.\n"},function(e,n){e.exports="PROGRAM SierpinskiDots;\nVAR x: array[0..2] of integer;\n    y: array[0..2] of integer;\n    thisx, thisy, thisc: integer;\nBEGIN\n  x[0] := 400;\n  y[0] := 138;\n  x[1] := 843;\n  y[1] := 650;\n  x[2] := 179;\n  y[2] := 778;\n  thisx := random(200) + 400;\n  thisy := random(200) + 400;\n  repeat\n    thisc := random(3);\n    thisx := (thisx + x[thisc]) / 2;\n    thisy := (thisy + y[thisc]) / 2;\n    pixset(thisx, thisy, purple)\n  until 0 = 1\nEND.\n"},function(e,n){e.exports="PROGRAM SierpinskiIFS;\nCONST xleft = 0;\n      xright = 999;\n      ytop = 0;\n      ybottom = 999;\n      scaledown = 4;\n      mappings = 3;\n      title = 'Sierpinski triangle';\n      live = black;\n      copied = darkgrey;\n      pauseval = 2000;\nVAR xl, xr, yt, yb: integer;\n    coeffdiv: integer;\n    mapxx, mapxy, mapxc: array[1..mappings] of integer;\n    mapyx, mapyy, mapyc: array[1..mappings] of integer;\n    iteration, starttime: integer;\n    count, numborn, numkilled: integer;\n\n  Procedure setmaps;\n  Begin\n    coeffdiv := 100;\n    mapxx[1] := 50;\n    mapyx[1] := 0;\n    mapxy[1] := 0;\n    mapyy[1] := 50;\n    mapxc[1] := 250;\n    mapyc[1] := 0;\n    mapxx[2] := 50;\n    mapyx[2] := 0;\n    mapxy[2] := 0;\n    mapyy[2] := 50;\n    mapxc[2] := 0;\n    mapyc[2] := 500;\n    mapxx[3] := 50;\n    mapyx[3] := 0;\n    mapxy[3] := 0;\n    mapyy[3] := 50;\n    mapxc[3] := 500;\n    mapyc[3] := 500\n  End;\n\n  Procedure setscale;\n  Var i: integer;\n  Begin\n    xl := xleft / scaledown;\n    xr := xright / scaledown;\n    yt := ytop / scaledown;\n    yb := ybottom / scaledown;\n    for i := 1 to mappings do\n      begin\n        mapxc[i] := mapxc[i] / scaledown;\n        mapyc[i] := mapyc[i] / scaledown\n      end\n  End;\n\n  Procedure map(a, x, y: integer; var newx, newy: integer);\n  Begin\n    newx := divmult(x, coeffdiv, mapxx[a]) + divmult(y, coeffdiv, mapxy[a]) + mapxc[a];\n    newy := divmult(x, coeffdiv, mapyx[a]) + divmult(y, coeffdiv, mapyy[a]) + mapyc[a]\n  End;\n\n  Procedure domap(mapnum: integer);\n  Var x, y, newx, newy: integer;\n  Begin\n    noupdate;\n    for y := yt to yb do\n      for x := xl to xr do\n        if pixcol(x, y) <> white then\n          begin\n            map(mapnum, x, y, newx, newy);\n            if pixcol(newx, newy) = white then\n              inc(numborn);\n            pixset(newx, newy, copied)\n          end;\n    update\n  End;\n\n  Procedure cleanup;\n  Var x, y: integer;\n  Begin\n    noupdate;\n    for y := yt to yb do\n      for x := xl to xr do\n        if pixcol(x, y) = live then\n          begin\n            pixset(x, y, white);\n            inc(numkilled)\n          end\n        else\n        if pixcol(x, y) = copied then\n          pixset(x, y, live);\n    update\n  End;\n\nBEGIN\n  setmaps;\n  setscale;\n  canvas(xl, yt, xr - xl + 1, yb - yt + 1);\n  resolution(xr - xl + 1, yb - yt + 1);\n  blank(live);\n  iteration := 0;\n  writeln(title + ' by iterative mapping');\n  timeset(0);\n  repeat\n    starttime := time;\n    inc(iteration);\n    writeln('');\n    writeln('Iteration ' + str(iteration) + ':');\n    numborn := 0;\n    for count := 1 to mappings do\n      domap(count);\n    numkilled := 0;\n    cleanup;\n    writeln('  ' + str(numborn) + ' pixels born; ' + str(numkilled) + ' pixels killed');\n    writeln('  (took ' + str((time - starttime) / 1000) + ' seconds - total ' + str(time / 1000) + ' seconds so far)');\n    if (numborn + numkilled > 0) and (pauseval >= 1000) then\n      begin\n        write('  (now pausing ' + qstr(pauseval, 1000, 1) + ' seconds to allow halting if desired ...)');\n        pause(pauseval);\n        writeln('')\n      end\n  until numborn + numkilled = 0;\n  writeln('FINISH - fixed point of iterative mapping has been reached')\nEND.\n"},function(e,n){e.exports="PROGRAM SimpleDraw;\n\n  Procedure palette;\n  Var colcode: integer;\n  Begin\n    for colcode := 1 to 10 do\n      begin\n        setxy(colcode * 100 - 50, 950);\n        colour(rgb(colcode));\n        blot(50)\n      end\n  End;\n\nBEGIN\n  palette;\n  home;\n  thickness(10);\n  blot(2);\n  repeat\n    repeat\n    until (?lmouse > 0) or (?rmouse > 0);\n    if ?mousey > 900 then\n      colour(rgb(?mousex div 100 + 1))\n    else\n      if ?lmouse > 0 then\n      drawxy(?mousex - turtx, ?mousey - turty)\n    else\n      setxy(?mousex, ?mousey)\n  until false\nEND.\n"},function(e,n){e.exports="PROGRAM SimpleProcedure;\n\n  Procedure prong;\n  Begin\n    forward(400);\n    blot(20);\n    back(400)\n  End;\n\nBEGIN\n  repeat\n    randcol(10);\n    prong;\n    right(61)\n  until turtd = 0\nEND.\n"},function(e,n){e.exports="PROGRAM SnakeGame;\nCONST boardsize = 30;\n      snakecolour = purple;\n      applecolour = green;\nVAR snakelength: integer;\n    crash: boolean;\n\n  Procedure newapple;\n  Var x, y: integer;\n  Begin\n    repeat\n      x := random(boardsize);\n      y := random(boardsize)\n    until (pixcol(x, y) <> snakecolour);\n    pixset(x, y, applecolour)\n  End;\n\nBEGIN\n  canvas(0, 0, boardsize, boardsize);\n  resolution(boardsize, boardsize);\n  angles(4);\n  blank(lightblue);\n  cursor(0);\n  colour(snakecolour);\n  thickness(1);\n  penup;\n  forward(1);\n  snakelength := 2;\n  newapple;\n  crash := false;\n  repeat\n    noupdate;\n    if (abs(?key) = \\up) and (turtd <> 2) then\n      direction(0);\n    if (abs(?key) = \\right) and (turtd <> 3) then\n      direction(1);\n    if (abs(?key) = \\down) and (turtd <> 0) then\n      direction(2);\n    if (abs(?key) = \\left) and (turtd <> 1) then\n      direction(3);\n    forward(1);\n    if (turtx < 0) or (turtx >= boardsize) or (turty < 0) or (turty >= boardsize) then\n      crash := true;\n    if pixcol(turtx, turty) = snakecolour then\n      crash := true;\n    if pixcol(turtx, turty) = applecolour then\n      begin\n        inc(snakelength);\n        pixset(turtx, turty, snakecolour);\n       newapple\n      end;\n    colour(lightblue);\n    polyline(snakelength + 2);\n    colour(snakecolour);\n    polyline(snakelength);\n    update;\n    pause(250 - (snakelength * 3))\n  until crash;\n  resolution(1000, 1000);\n  blank(lilac);\n  setxy(boardsize / 4, 2 * boardsize / 5);\n  print('Score ' + str(snakelength - 2), 20, 100)\nEND.\n"},function(e,n){e.exports="PROGRAM SolarSystem;\nCONST sunradius = 50000;\nVAR radius, distancefromsun, design, rotation, speed: array[1..8] of integer;\nVAR i: integer;\nBEGIN\n  radius[1] := 2433;\n  distancefromsun[1] := 5795;\n  speed[1] := 1607;\n  design[1] := white;\n  radius[2] := 6053;\n  distancefromsun[2] := 10811;\n  speed[2] := 1174;\n  design[2] := ochre;\n  radius[3] := 6371;\n  distancefromsun[3] := 14957;\n  speed[3] := 1000;\n  design[3] := blue;\n  radius[4] := 3380;\n  distancefromsun[4] := 22784;\n  speed[4] := 802;\n  design[4] := orangered;\n  radius[5] := 71492;\n  distancefromsun[5] := 77814;\n  speed[5] := 434;\n  design[5] := lightred;\n  radius[6] := 58219;\n  distancefromsun[6] := 142700;\n  speed[6] := 323;\n  design[6] := cream;\n  radius[7] := 23470;\n  distancefromsun[7] := 287030;\n  speed[7] := 182;\n  design[7] := cyan;\n  radius[8] := 23716;\n  distancefromsun[8] := 449990;\n  speed[8] := 159;\n  design[8] := royal;\n  angles(360000);\n  canvas(0, 0, 1000000, 1000000);\n  resolution(500, 500);\n  thickness(1);\n  penup;\n  while true do\n    begin\n      blank(black);\n      home;\n      colour(yellow);\n      blot(sunradius);\n      for i := 1 to 8 do\n        begin\n          home;\n          colour(white);\n          circle(distancefromsun[i] + sunradius);\n          right(rotation[i]);\n          forward(distancefromsun[i] + sunradius);\n          rotation[i] := (rotation[i] + speed[i]) mod 360000;\n          colour(design[i]);\n          if i <= 4 then\n            blot(radius[i] * 2)\n          else\n            blot(radius[i] / 2)\n        end;\n      update;\n      noupdate\n    end\nEND.\n"},function(e,n){e.exports="PROGRAM Stars;\nVAR n: integer;\n\n  Procedure star(points, col: integer);\n  Var count: integer;\n  Begin\n    angles(points * 2);\n    for count := 1 to points do\n      begin\n        forward(450);\n        back(450);\n        forget(1);\n        right(1);\n        forward(200);\n        back(200);\n        forget(1);\n        right(1)\n      end;\n    colour(col);\n    polygon(points * 2)\n  End;\n\nBEGIN\n  penup;\n  for n := 3 to 12 do\n    begin\n      star(n, rgb(n - 2));\n      pause(500)\n    end\nEND.\n"},function(e,n){e.exports="PROGRAM StringFunctions;\nCONST delay = 500;\nVAR s1, s2, s3, s4, s5: string;\n    posn, n: integer;\nBEGIN\n  output(true, cream, true);\n  s1 := 'Turtle Pascal';\n  s2 := copy(s1, 1, 6);\n  writeln(s2 + ' is the name of a small animal.');\n  pause(delay);\n  s3 := copy(s1, 8, 6);\n  writeln(s3 + ' was a French philosopher.');\n  pause(delay);\n  s4 := insert('eter R', s3, 2);\n  writeln('''' + s4 + ''' is a silly name.');\n  pause(delay);\n  writeln('\\\"' + s1 + '\\\" has ' + str(length(s1)) + ' characters.');\n  pause(delay);\n  writeln('In lower case it is \\\"' + lowercase(s1) + '\\\".');\n  writeln('In upper case it is \\\"' + uppercase(s1) + '\\\".');\n  pause(delay);\n  posn := pos(s3, s1);\n  if posn > 0 then\n    writeln('\\\"' + s3 + '\\\" occurs within \\\"' + s1 + '\\\" at position ' + str(posn) + '.');\n  pause(delay);\n  s5 := '3.14159';\n  writeln(s5 + ' times 100000 = ' + str(qval(s5, 100000, -1)) + '.');\n  pause(delay);\n  n := qval(s5, 100000, -1);\n  writeln(str(n) + ' divided by 100000 = ' + qstr(n, 100000, 5) + '.');\n  writeln('');\n  pause(delay * 5);\n  writeln('Now back to the Canvas and Console ...');\n  output(false, peach, true);\n  pause(delay * 5);\n  output(false, lightred, false);\n  pause(delay * 5);\n  console(true, lightblue);\n  writeln('You will see this on a clear light blue Console')\nEND.\n"},function(e,n){e.exports="PROGRAM ThePlough;\nBEGIN\n  blank(black);\n  colour(lightblue);\n  setxy(100, 200);\n  blot(10);\n  setxy(300, 250);\n  blot(10);\n  setxy(420, 350);\n  blot(10);\n  setxy(570, 490);\n  blot(10);\n  setxy(900, 560);\n  blot(10);\n  setxy(840, 720);\n  blot(10);\n  setxy(590, 660);\n  blot(10);\n  setxy(570, 490);\n  colour(silver);\n  polyline(8)\nEND.\n"},function(e,n){e.exports="PROGRAM TreeIFS;\nCONST xleft = 0;\n      xright = 999;\n      ytop = 0;\n      ybottom = 999;\n      scaledown = 4;\n      mappings = 5;\n      title = 'Tree';\n      live = green;\n      copied = emerald;\n      pauseval = 2000;\nVAR xl, xr, yt, yb: integer;\n    coeffdiv: integer;\n    mapxx, mapxy, mapxc: array[1..mappings] of integer;\n    mapyx, mapyy, mapyc: array[1..mappings] of integer;\n    iteration, starttime: integer;\n    count, numborn, numkilled: integer;\n\n  Procedure setmaps;\n  Begin\n    coeffdiv := 1000;\n    mapxx[1] := 195;\n    mapyx[1] := 344;\n    mapxy[1] := -488;\n    mapyy[1] := 443;\n    mapxc[1] := 443;\n    mapyc[1] := 245;\n    mapxx[2] := 462;\n    mapyx[2] := -252;\n    mapxy[2] := 414;\n    mapyy[2] := 361;\n    mapxc[2] := 251;\n    mapyc[2] := 569;\n    mapxx[3] := -58;\n    mapyx[3] := 453;\n    mapxy[3] := -70;\n    mapyy[3] := -111;\n    mapxc[3] := 598;\n    mapyc[3] := 97;\n    mapxx[4] := -35;\n    mapyx[4] := -469;\n    mapxy[4] := 70;\n    mapyy[4] := -22;\n    mapxc[4] := 488;\n    mapyc[4] := 507;\n    mapxx[5] := -637;\n    mapyx[5] := 0;\n    mapxy[5] := 0;\n    mapyy[5] := 501;\n    mapxc[5] := 856;\n    mapyc[5] := 251\n  End;\n\n  Procedure setscale;\n  Var i: integer;\n  Begin\n    xl := xleft / scaledown;\n    xr := xright / scaledown;\n    yt := ytop / scaledown;\n    yb := ybottom / scaledown;\n    for i := 1 to mappings do\n      begin\n        mapxc[i] := mapxc[i] / scaledown;\n        mapyc[i] := mapyc[i] / scaledown\n      end\n  End;\n\n  Procedure map(a, x, y: integer; var newx, newy: integer);\n  Begin\n    newx := divmult(x, coeffdiv, mapxx[a]) + divmult(y, coeffdiv, mapxy[a]) + mapxc[a];\n    newy := divmult(x, coeffdiv, mapyx[a]) + divmult(y, coeffdiv, mapyy[a]) + mapyc[a]\n  End;\n\n  Procedure domap(mapnum: integer);\n  Var x, y, newx, newy: integer;\n  Begin\n    noupdate;\n    for y := yt to yb do\n      for x := xl to xr do\n        if pixcol(x, y) <> white then\n          begin\n            map(mapnum, x, y, newx, newy);\n            if pixcol(newx, newy) = white then\n              inc(numborn);\n            pixset(newx, newy, copied)\n          end;\n    update\n  End;\n\n  Procedure cleanup;\n  Var x, y: integer;\n  Begin\n    noupdate;\n    for y := yt to yb do\n      for x := xl to xr do\n        if pixcol(x, y) = live then\n          begin\n            pixset(x, y, white);\n            inc(numkilled)\n          end\n        else\n        if pixcol(x, y) = copied then\n          pixset(x, y, live);\n    update\n  End;\n\nBEGIN\n  setmaps;\n  setscale;\n  canvas(xl, yt, xr - xl + 1, yb - yt + 1);\n  resolution(xr - xl + 1, yb - yt + 1);\n  pixset(1, 1, live);\n  iteration := 0;\n  writeln(title + ' by iterative mapping');\n  timeset(0);\n  repeat\n    starttime := time;\n    inc(iteration);\n    writeln('');\n    writeln('Iteration ' + str(iteration) + ':');\n    numborn := 0;\n    for count := 1 to mappings do\n      domap(count);\n    numkilled := 0;\n    cleanup;\n    writeln('  ' + str(numborn) + ' pixels born; ' + str(numkilled) + ' pixels killed');\n    writeln('  (took ' + str((time - starttime) / 1000) + ' seconds - total ' + str(time / 1000) + ' seconds so far)');\n    if (numborn + numkilled > 0) and (pauseval >= 1000) then\n      begin\n        write('  (now pausing ' + qstr(pauseval, 1000, 1) + ' seconds to allow halting if desired ...)');\n        pause(pauseval);\n        writeln('')\n      end\n  until numborn + numkilled = 0;\n  writeln('FINISH - fixed point of iterative mapping has been reached')\nEND.\n"},function(e,n){e.exports="PROGRAM Triangles;\n\n  Procedure triangle(size: integer);\n  Begin\n    if size > 1 then\n      begin\n        forward(size);\n        triangle(size / 2);\n        right(120);\n        forward(size);\n        triangle(size / 2);\n        right(120);\n        forward(size);\n        triangle(size / 2);\n        right(120)\n      end\n  End;\n\nBEGIN\n  movexy(-100, 150);\n  triangle(256)\nEND.\n"},function(e,n){e.exports="PROGRAM TrigonometricGraphs;\nCONST xorigin = 500;\n      yorigin = 500;\n      halfwidth = 400;\n      yscale = 200;\nVAR degrees: integer;\n    x, y: integer;\n\n  Procedure axes;\n  Begin\n    thickness(3);\n    setxy(xorigin - halfwidth, yorigin);\n    drawxy(halfwidth * 2, 0);\n    setxy(xorigin, 0);\n    drawxy(0, 1000);\n    setxy(xorigin, yorigin);\n    circle(15);\n    thickness(2);\n    setxy(xorigin - halfwidth, yorigin - yscale);\n    drawxy(halfwidth * 2, 0);\n    setxy(xorigin - halfwidth, yorigin + yscale);\n    drawxy(halfwidth * 2, 0);\n    setxy(xorigin + halfwidth + 10, yorigin - yscale - 18);\n    print('+1', 0, 20);\n    setxy(xorigin + halfwidth + 10, yorigin + yscale - 18);\n    print('-1', 0, 20);\n    setxy(xorigin - halfwidth - 60, yorigin);\n    print('-180', 0, 20);\n    setxy(xorigin - halfwidth / 2, yorigin);\n    print('-90', 0, 20);\n    setxy(xorigin + halfwidth / 2 - 30, yorigin);\n    print('90', 0, 20);\n    setxy(xorigin + halfwidth, yorigin);\n    print('180', 0, 20)\n  End;\n\n  Procedure sinecurve;\n  Begin\n    for degrees := -180 to 180 do\n      begin\n        x := xorigin + divmult(degrees, 180, halfwidth);\n        y := yorigin - sin(degrees, 1, yscale);\n        setxy(x, y)\n      end;\n    polyline(361)\n  End;\n\n  Procedure cosinecurve;\n  Begin\n    for degrees := -180 to 180 do\n      begin\n        x := xorigin + divmult(degrees, 180, halfwidth);\n        y := yorigin - cos(degrees, 1, yscale);\n        setxy(x, y)\n      end;\n    polyline(361)\n  End;\n\n  Procedure tancurve;\n  Begin\n    for degrees := -180 to 180 do\n      if degrees = -90 then\n        polyline(90)\n      else\n        if degrees = 90 then\n        polyline(179)\n      else\n        begin\n          x := xorigin + divmult(degrees, 180, halfwidth);\n          y := yorigin - tan(degrees, 1, yscale);\n          setxy(x, y)\n        end;\n    polyline(90)\n  End;\n\nBEGIN\n  axes;\n  noupdate;\n  thickness(4);\n  colour(green);\n  setxy(20, 800);\n  print('sine', 16, 40);\n  sinecurve;\n  colour(red);\n  setxy(20, 860);\n  print('cosine', 16, 40);\n  cosinecurve;\n  colour(blue);\n  setxy(20, 920);\n  print('tangent', 16, 40);\n  tancurve\nEND.\n"},function(e,n){e.exports="PROGRAM TurtleBounce;\nVAR xvel, yvel: integer;\nBEGIN\n  setxy(100, 700);\n  xvel := 8;\n  yvel := -4;\n  while 0 < 1 do\n    begin\n      noupdate;\n      colour(white);\n      blot(51);\n      movexy(xvel, yvel);\n      colour(red);\n      blot(50);\n      update;\n      pause(10);\n      if (turtx < 50) or (turtx > 949) then\n        xvel := -xvel;\n      if (turty < 50) or (turty > 949) then\n        yvel := -yvel;\n    end\nEND.\n"},function(e,n){e.exports="PROGRAM TurtleMove;\nVAR count: integer;\nBEGIN\n  setxy(100, 700);\n  for count := 1 to 100 do\n    begin\n      noupdate;\n      colour(white);\n      blot(51);\n      movexy(8, -4);\n      colour(red);\n      blot(50);\n      update;\n      pause(10)\n    end\nEND.\n"},function(e,n){e.exports="PROGRAM TwoSlits;\nCONST sectors = 7;\n      wavelength = 100;\n      sourcey = 730;\n      source1x = 275;\n      source2x = 725;\nVAR lampx: integer;\n    x, y: integer;\n    disty, dist1, dist2: integer;\n    wave1, wave2: integer;\n    waveaddi, waveaddj, waveadd: integer;\n    angleadd: integer;\n    sectcol: array[0..sectors] of integer;\n    boundary: array[0..sectors] of integer;\n\n  Procedure colsetup;\n  Var n: integer;\n  Begin\n    sectcol[0] := violet;\n    sectcol[1] := blue;\n    sectcol[2] := cyan;\n    sectcol[3] := lime;\n    sectcol[4] := yellow;\n    sectcol[5] := orange;\n    sectcol[6] := red;\n    sectcol[7] := violet;\n    for n := 0 to sectors do\n      boundary[n] := divmult(360, sectors, n)\n  End;\n\n  Function wavecolour(n: integer): integer;\n  Var col1, col2: integer;\n      mix1, mix2: integer;\n  Begin\n    col2 := 0;\n    repeat\n      inc(col2)\n    until boundary[col2] >= n;\n    col1 := col2 - 1;\n    result := mixcols(sectcol[col1], sectcol[col2], boundary[col2] - n, n - boundary[col1])\n  End;\n\n  Procedure background;\n  Var n: integer;\n      diagx, diag: integer;\n  Begin\n    lampx := (source1x + source2x) / 2;\n    blank(black);\n    colour(white);\n    thickness(5);\n    setxy(0, 733);\n    drawxy(1000, 0);\n    setxy(source1x, 732);\n    for dist1 := 1 to 4 do\n      begin\n        colour(wavecolour(wavelength - dist1));\n        drawxy(0, 1)\n      end;\n    diagx := lampx - source1x;\n    diag := hypot(diagx, 250, 1);\n    for n := 1 to 250 do\n      begin\n        dist1 := divmult(diag, 250, n);\n        wave1 := wavelength - ((dist1 + 5) mod wavelength);\n        colour(wavecolour(divmult(wave1, wavelength, 360)));\n        drawxy(source1x + divmult(diagx, 250, n) - turtx, 1)\n      end;\n    setxy(source2x, 732);\n    for dist2 := 1 to 4 do\n      begin\n        colour(wavecolour(wavelength - dist2));\n        drawxy(0, 1)\n      end;\n    diagx := source2x - lampx;\n    diag := hypot(diagx, 250, 1);\n    for n := 1 to 250 do\n      begin\n        dist2 := divmult(diag, 250, n);\n        wave2 := wavelength - ((dist2 + 5) mod wavelength);\n        colour(wavecolour(divmult(wave2, wavelength, 360)));\n        drawxy(source2x - divmult(diagx, 250, n) - turtx, 1)\n      end;\n    colour(yellow);\n    setxy(lampx, 984);\n    blot(10);\n  End;\n\nBEGIN\n  colsetup;\n  background;\n  noupdate;\n  for y := 0 to sourcey do\n   begin\n    disty := sourcey - y;\n    for x := 0 to 999 do\n      begin\n        dist1 := hypot(x - source1x, disty, 1);\n        dist2 := hypot(x - source2x, disty, 1);\n        wave1 := dist1 mod wavelength;\n        wave2 := dist2 mod wavelength;\n        waveaddi := sin(wave1 * 360, wavelength, 500) + sin(wave2 * 360, wavelength, 500);\n        waveaddj := cos(wave1 * 360, wavelength, 500) + cos(wave2 * 360, wavelength, 500);\n        waveadd := hypot(waveaddi, waveaddj, 1);\n        angleadd := (arctan(waveaddi, waveaddj, 1) + 360)mod 360;\n        pixset(x, y, mixcols(wavecolour(angleadd), black, waveadd, 1000 - waveadd))\n      end\n    end\nEND.\n"},function(e,n){e.exports="PROGRAM WaveSuperposer31;\n\n{* WSv3.1 - DO NOT MODIFY - copyright Hugh Wallis 23/3/16 **************************}\n{* Dev version of WaveSuperposer24.tgp *********************************************}\n\n{* CONSTANTS - CBMv2.0 DO NOT MODIFY Constants *************************************}\nConst textRow=0;tvalRow=1;spinRow=2;buttRow=3;fine=1;course=0;\nConst normText=0;boldText=1;large=1;small=0;noBorder=0;withBorder=1;\nConst noBackground=0;withBackground=1;\n{* END CBMv2.0 DO NOT MODIFY Constants *********************************************}\n\nCONST maxwaves=60;maxAmplitude=500;maxPhase=360;amplitudeInc=5;phaseInc=2;maxDecayRate=10;\nCONST precDecay=100; {decay rate precision multiplier}\nVAR exitFlag,count,numwaves,selectedwave,multSumWaves,decayRate,infoFlag: integer;\nVAR divideBy,granularity:integer;\nVAR keypressed:string;\nVAR wavesShown,buttonText:string;\nVAR amplitudes,phases,onoff,decayMult: array[1..maxwaves] of integer;\n\n{* UTILITIES - CBMv2.0 DO NOT MODIFY Procedures ************************************}\n{* Internal Utilities *}\nFunction getNumDigits(num:integer):integer;\n{Returns the number of digits in num (for right justification in outValue)}\nVar numDigits:integer;\nBegin\n num:=abs(num);\n if (num = 0) then numDigits:=1\n else\n begin\n  numDigits:=0;\n  while num > 0 do\n   begin\n    num:=num/10;\n    inc(numDigits);\n   end;\n end;\n result:=numDigits;\nEnd;\nProcedure outText(x,y,textType,textColour:integer;text:string);\n{Prints normal/bold text with slightly different start positions}\nVar height:integer;\nBegin\n if textType = boldText then y:=y-3 else y:=y-1;\n setxy(x+5,y);\n colour(textColour);\n if textType = boldText then print(text,16,18) else print(text,0,18);\nEnd;\nProcedure outValue(x,y,numWidth,value,textColour:integer);\n{Prints value in box allowing for numWidth digits, right justified}\nVar width,height,minusShift,charWidth:integer;\nvar valueStr:string;\nBegin\n charWidth:=13;\n minusShift:=8;\n width:=12+charWidth*numWidth;\n height:=24;\n {Display borders}\n pendown; setxy(x+width,y); colour(midgrey); drawxy(0,height); drawxy(-width,0);\n colour(darkgrey); drawxy(0,-height-1); drawxy(width,0);\n {Background}\n setxy(x+1,y+1);setxy(x+width-2,y+1);setxy(x+width-2,y+height-2);setxy(x+1,y\n+height-2);\n colour(black);\n polygon(4);\n {recolour(x+1,y+1,black);}\n {Display value}\n if (value < 0) then\n  setxy(x+5+charWidth*(numWidth-getNumDigits(value))-minusShift,y-2)\n else\n  setxy(x+5+charWidth*(numWidth-getNumDigits(value)),y-2);\n colour(textColour);\n valueStr:=str(value);\n print(valueStr,0,18);\nEnd;\nProcedure spinButton(x,y:integer;symbol:char;buttonColour:integer);\n{Prints a spinner button with symbol in buttonColour}\nVar width,height:integer;\nBegin\n width:=24;\n height:=24;\n {Display borders}\n pendown;\n setxy(x+width,y);\n colour(darkgrey);\n drawxy(0,height);\n drawxy(-width,0);\n colour(lightgrey);\n drawxy(0,-height-1);\n drawxy(width,0);\n {Background}\n recolour(x+1,y+1,buttonColour);\n {Display symbol}\n setxy(x+6,y-14);\n colour(black);\n print(symbol,4,24);\nEnd;\n{* End Internal Utilities *}\n{* Available for external use: Button, smallButton, Border, Borders, Spinner *}\nProcedure Button(x,y,numChars:integer;bText:string;buttonColour,textColour:integer);\n{Prints larger button for displaying outside a Control board}\n{Note: Parameter bText needs to be declared as a pstring before being passed into here}\nVar width,height:integer;\nBegin\n width:=8+13*numChars;\n height:=30;\n y:=y-2;\n {Display borders}\n pendown;\n setxy(x+width,y);\n colour(darkgrey);\n drawxy(0,height);\n drawxy(-width,0);\n colour(lightgrey);\n drawxy(0,-height-1);\n drawxy(width,0);\n {Background}\n recolour(x+1,y+1,buttonColour);\n {Display symbol}\n setxy(x+8,y-2);\n colour(textColour);\n print(bText,0,22);\nEnd;\nProcedure smallButton\n(x,y,numChars:integer;bText:string;buttonColour,textColour:integer);\n{Prints smaller button for displaying within a Control board}\n{Note: Parameter bText needs to be declared as a pstring before being passed into here}\nVar width,height:integer;\nBegin\n width:=8+13*numChars;\n height:=24;\n {Display borders}\n pendown;\n setxy(x+width,y);\n colour(darkgrey);\n drawxy(0,height);\n drawxy(-width,0);\n colour(lightgrey);\n drawxy(0,-height-1);\n drawxy(width,0);\n {Background}\n recolour(x+1,y+1,buttonColour);\n {Display symbol}\n setxy(x+4,y-1);\n colour(textColour);\n print(bText,0,18);\nEnd;\nProcedure Border(x,y,width,height,highcolour,lowcolour,backColour,backFlag:integer);\n{Display border only (no background) with pixel location/dimensions and highlighting\ncolours}\nBegin\n pendown;\n if (backFlag = withBackground) then\n  begin\n   setxy(x+1,y+1);setxy(x-2+width,y+1);setxy(x-2+width,y-2+height);setxy(x+1,y-\n2+height);\n   colour(backColour);\n   polygon(4);\n  end;\n setxy(x+width,y);\n colour(lowcolour);\n drawxy(0,height);\n drawxy(-width,0);\n colour(highcolour);\n drawxy(0,-height-1);\n drawxy(width,0);\nEnd;\nProcedure Borders\n(x,y,numChars,numDigits,numRows,highColour,lowColour,backColour,borderFlag,backFlag:integer);\n{Display board border with background at pixel location, but dimensions specified in no.\nchars+digits and rows}\nVar width,height,spinnerShift:integer;\nBegin\n spinnerShift:=34;\n height:=8+numRows*spinnerShift;\n width:=8+(numChars+numDigits+6)*13;\n if borderFlag = withBorder then\n  {Display border}\n  begin\n    Border(x,y,width,height,highColour,lowColour,silver,noBackground);\n    Border(x+2,y+2,width-4,height-4,lowColour,highColour,silver,noBackground);\n  end;\n if backFlag = withBackground then\n  {Display background}\n  begin\n   if borderFlag = noBorder then\n    begin\n     x:=x-2;y:=y-8;\n    end\n   else\n    begin\n     x:=x+2;y:=y+2;\n    end;\n   setxy(x,y);setxy(x-6+width,y);setxy(x-6+width,y-6+height);setxy(x,y-6+height);\n   colour(backColour);\n   polygon(4);\n  end;\nEnd;\nProcedure Spinner(row,spinType,textType,x,y,numChars,numDigits:integer; text:string;\nvalue,textColour,digitColour,buttonColour:integer);\n{Displays a spinner row in a board.  3 Types: text only, text and value or full spinner -\ntext, value and spinner buttons}\n{Note: Parameter text needs to be declared as a pstring before being passed into here}\nVar charWidth,textShift,buttonShift,numShift,spinnerShift:integer;\nBegin\n spinnerShift:=34;\n charWidth:=13;\n buttonShift:=30;\n textShift:=charWidth*numChars;\n numShift:=18+charWidth*numDigits;\n y:=y+(row-1)*spinnerShift;\n outText(x,y,textType,textColour,text);\n if spinType = spinRow then spinButton(x+textShift,y,'<',buttonColour);\n if spinType <> textRow then outValue(x+textShift\n+buttonShift,y,numDigits,value,digitColour);\n if spinType = spinRow then spinButton(x+textShift+buttonShift\n+numShift,y,'>',buttonColour);\nEnd;\nProcedure incDecSpinner(row,x,y,numChars,numDigits:integer;var value:integer;min,max,mult:integer);\n{* Increments or decrements a spinner value by mult (between max and min), if mouse\nclicked on spinner button. *}\n{* Called by updateControlBoard procedure(s). *}\n{* Copy and modify this procedure to create different behaviour for spinner buttons. *}\nVar charWidth,textShift,buttonShift,numShift,spinnerShift:integer;\nBegin\n spinnerShift:=34; charWidth:=13; buttonShift:=30;\n textShift:=charWidth*numChars; numShift:=18+charWidth*numDigits;\n y:=y+(row-1)*spinnerShift;\n {Decrement button clicked}\n if (?mousex>(x+textShift)) and\n    (?mousex<(x+textShift+buttonShift)) and\n    (?mousey>y) and (?mousey<y+spinnerShift) then\n   if(value >= (min+mult)) then value:=value-mult; {Modify for alternative decrement}\n {Increment button clicked}\n if (?mousex>(x+textShift+buttonShift+numShift)) and\n    (?mousex<(x+textShift+2*buttonShift+numShift)) and\n    (?mousey>y) and (?mousey<y+spinnerShift) then\n   if (value <= (max-mult)) then value:=value+mult; {Modify for alternative increment}\nEnd;\nProcedure loadDecayMults(decayRate:integer);\nVar count,count2:integer;\nBegin\n{Load Decay multipliers}\n  for count:=1 to maxwaves do decayMult[count]:=precDecay;\n  for count:=2 to maxwaves do\n  begin\n   for count2:=count to maxwaves do\n   begin\n    decayMult[count2]:=((precDecay-decayRate)*decayMult[count2])/precDecay;\n   end;\n  end\nEnd;\nProcedure incDecDecay(row,x,y,numChars,numDigits:integer;var value:integer;min,max,mult:integer);\nVar charWidth,textShift,buttonShift,numShift,spinnerShift:integer;\nVar count,count2:integer;\nBegin\n spinnerShift:=34; charWidth:=13; buttonShift:=30;\n textShift:=charWidth*numChars; numShift:=18+charWidth*numDigits;\n y:=y+(row-1)*spinnerShift;\n {Decrement button clicked}\n if (?mousex>(x+textShift)) and\n    (?mousex<(x+textShift+buttonShift)) and\n    (?mousey>y) and (?mousey<y+spinnerShift) then\n   if(value >= (min+mult)) then value:=value-mult; {Modify for alternative decrement}\n {Increment button clicked}\n if (?mousex>(x+textShift+buttonShift+numShift)) and\n    (?mousex<(x+textShift+2*buttonShift+numShift)) and\n    (?mousey>y) and (?mousey<y+spinnerShift) then\n   if (value <= (max-mult)) then value:=value+mult; {Modify for alternative increment}\n loadDecayMults(decayRate);\nEnd;\nProcedure incDecDivideBy(row,x,y,numChars,numDigits:integer;var value:integer;min,max,mult:integer);\nVar charWidth,textShift,buttonShift,numShift,spinnerShift:integer;\nVar count,count2:integer;\nBegin\n spinnerShift:=34; charWidth:=13; buttonShift:=30;\n textShift:=charWidth*numChars; numShift:=18+charWidth*numDigits;\n y:=y+(row-1)*spinnerShift;\n {Decrement button clicked}\n if (?mousex>(x+textShift)) and\n    (?mousex<(x+textShift+buttonShift)) and\n    (?mousey>y) and (?mousey<y+spinnerShift) then\n   if(value >= (min+mult)) then\n   begin\n    value:=value-mult; {Modify for alternative decrement}\n    wavesShown:='Divide by';\n     for count:= 1 to maxwaves do\n      begin\n       if (count) mod divideBy = 0 then onoff[count]:=1 else onoff[count]:=0;\n      end;\n    end;\n {Increment button clicked}\n if (?mousex>(x+textShift+buttonShift+numShift)) and\n    (?mousex<(x+textShift+2*buttonShift+numShift)) and\n    (?mousey>y) and (?mousey<y+spinnerShift) then\n   if (value <= (max-mult)) then\n    begin\n     value:=value+mult; {Modify for alternative increment}\n     wavesShown:='Divide by';\n     for count:= 1 to maxwaves do\n      begin\n       if (count) mod divideBy = 0 then onoff[count]:=1 else onoff[count]:=0;\n      end;\n    end;\n loadDecayMults(decayRate);\nEnd;\nProcedure updateValueButton(x,y,numChars:integer;var\nvalue:integer;newValue,size:integer);\n{* Sets value to newValue, if mouse clicked on button. *}\n{* Called by updateControlBoard procedure(s). *}\n{* Copy and modify this procedure to create different behaviour for buttons. *}\nVar width,height:integer;\nBegin\n width:=8+13*numChars;\n if size=large then height:=30 else height:=22;\n if (?mousex>x) and (?mousex<(x+width)) and (?mousey>y) and (?mousey<y+height)\nthen\n  Begin\n   value:=newValue; {Modify for alternative button action}\n  End;\nEnd;\nProcedure updateToggleButton(x,y,numChars:integer;var value:integer;size:integer);\n{* Toggles value between 0 and 1, if mouse clicked on button. *}\n{* Called by updateControlBoard procedure(s). *}\n{* Copy and modify this procedure to create different behaviour for buttons. *}\nVar width,height:integer;\nBegin\n width:=8+13*numChars;\n if size=large then height:=30 else height:=22;\n if (?mousex>x) and (?mousex<(x+width)) and (?mousey>y) and (?mousey<y+height)\nthen\n  Begin\n   if (value=0) then value:=1 else value:=0; {Modify for alternative button behaviour}\n  End;\nEnd;\nProcedure updateWaveButton(x,y,numChars,size:integer);\nVar width,height:integer;\nBegin\n width:=8+13*numChars;\n if size=large then height:=30 else height:=34;\n if (?mousex>x) and (?mousex<(x+width)) and (?mousey>y) and (?mousey<y+height)\nthen\n  Begin\n   amplitudes[selectedWave]:=100;\n   phases[selectedWave]:=0;\n  End;\nEnd;\nProcedure initWaves;\nVar count:integer;\nBegin\n   for count:= 1 to maxwaves do\n   begin\n    amplitudes[count]:=100;\n    phases[count]:=0;\n    onoff[count]:=1;\n   end;\n   decayRate:=10;\n   loadDecayMults(decayRate);\n   multSumWaves:=1;\nEnd;\nProcedure initAllWavesButton(x,y,numChars,size:integer);\nVar width,height:integer;\nBegin\n width:=8+13*numChars;\n if size=large then height:=30 else height:=34;\n if (?mousex>x) and (?mousex<(x+width)) and (?mousey>y) and (?mousey<y+height)\n then\n  begin\n   initWaves;\n   wavesShown:='All waves';\n  end;\nEnd;\nProcedure updateShowButtons(showType,x,y,numChars,size:integer);\nVar width,height,count,prevCount,temp:integer;\nBegin\n width:=8+13*numChars;\n if size=large then height:=30 else height:=22;\n if (?mousex>x) and (?mousex<(x+width)) and (?mousey>y) and (?mousey<y+height)\n then\n  Begin\n   if showType = 1 then {Show All}\n    begin\n     wavesShown:='All waves';\n     for count:= 1 to maxwaves do\n      begin\n       onoff[count]:=1;\n      end;\n    end;\n   if (showType = 2)then {Evens}\n    begin\n     wavesShown:='Evens';\n     for count:= 1 to maxwaves do\n      begin\n       if count mod 2 = 0 then onoff[count]:=1 else onoff[count]:=0;\n      end;\n    end;\n   if showType = 3 then {Odds}\n    begin\n     wavesShown:='Odds';\n     for count:= 1 to maxwaves do\n      begin\n       if count mod 2 = 0 then onoff[count]:=0 else onoff[count]:=1;\n      end;\n    end;\n   if showType = 4 then {Fibonacci}\n    begin\n     wavesShown:='Fibonacci';\n     for count:= 1 to maxwaves do\n      begin\n       onoff[count]:=0;\n      end;\n     onoff[1]:=1;\n     count:=2;prevCount:=1;\n     repeat\n      onoff[count]:=1;\n      temp:=count;count:=count+prevCount;prevCount:=temp;\n     until count>maxwaves;\n    end;\n   if showType = 5 then {Show None}\n    begin\n     wavesShown:='None';\n     for count:= 1 to maxwaves do\n      begin\n       onoff[count]:=0;\n      end;\n    end;\n  End;\nEnd;\nProcedure Fibonacci;\nVar count,prevCount,temp:integer;\nBegin\n     for count:= 1 to maxwaves do\n      begin\n       onoff[count]:=0;\n      end;\n     onoff[1]:=1;\n     count:=2;prevCount:=1;\n     repeat\n      onoff[count]:=1;\n      temp:=count;count:=count+prevCount;prevCount:=temp;\n     until count>maxwaves;\nEnd;\nProcedure updatePresetButtons(showType,x,y,numChars,size:integer);\nVar width,height,count,prevCount,temp:integer;\nBegin\n width:=8+13*numChars;\n if size=large then height:=30 else height:=26;\n if (?mousex>x) and (?mousex<(x+width)) and (?mousey>y) and (?mousey<y+height)\n then\n  Begin\n   initWaves;\n   if showType = 0 then {Limited Divide by}\n    begin\n     for count:=1 to (selectedWave-1) do\n      begin\n       onoff[count]:=0;\n      end;\n     onoff[selectedWave]:=1;\n     for count:= selectedWave+1 to maxwaves do\n      begin\n       if (count-selectedWave) mod divideBy = 0 then onoff[count]:=1 else onoff[count]:=0;\n      end;\n     wavesShown:='Lim Divide';\n     loadDecayMults(decayRate);\n     multSumWaves:=1;\n    end;\n   if showType = 1 then {Blunt Saw}\n    begin\n     initWaves;\n     for count:=1 to maxwaves do\n      begin\n       if count mod 2 = 0 then onoff[count]:=1 else onoff[count]:=0;\n       amplitudes[count]:=200;\n      end;\n     wavesShown:='Sawtooth';\n     decayRate:=30;\n     loadDecayMults(decayRate);\n     numwaves:=12;\n     multSumWaves:=1;\n    end;\n   if showType = 2 then {Square}\n    begin\n     initWaves;\n     for count:=1 to maxwaves do\n      begin\n       if count mod 2 = 0 then onoff[count]:=0 else onoff[count]:=1;\n       amplitudes[count]:=150;\n      end;\n     wavesShown:='Square';\n     decayRate:=40;\n     loadDecayMults(decayRate);\n     numwaves:=11;\n     amplitudes[3]:=115;amplitudes[5]:=130;amplitudes[7]:=130;amplitudes[9]:=190;\n     multSumWaves:=1;\n    end;\n   if showType = 3 then {Stock}\n    begin\n     initWaves;\n     fibonacci;\n     wavesShown:='Shortstock';\n     decayRate:=3;\n     loadDecayMults(decayRate);\n     numwaves:=40;\n     multSumWaves:=1;\n     granularity:=fine;\n    end;\n   if showType = 4 then {Longstock}\n    begin\n     initWaves;\n     fibonacci;\n     wavesShown:='Longstock';\n     decayRate:=3;\n     loadDecayMults(decayRate);\n     numwaves:=60;\n     multSumWaves:=1;\n     granularity:=fine;\n     onoff[1]:=0;onoff[2]:=0;onoff[3]:=0;onoff[5]:=0;\n    end;\n   if showType = 5 then {Pulse Heartbeat}\n    begin\n     initWaves;\n     for count:=1 to maxwaves do\n      begin\n       if count mod 2 = 0 then onoff[count]:=0 else onoff[count]:=1;\n       amplitudes[count]:=100;\n      end;\n     wavesShown:='Pulse';\n     decayRate:=3;\n     loadDecayMults(decayRate);\n     numwaves:=60;\n     onoff[3]:=0;\n     multSumWaves:=3;\n    end;\n   if showType = 6 then {Relaxed Heartbeat}\n    begin\n     initWaves;\n     for count:=1 to maxwaves do\n      begin\n       if count mod 2 = 0 then onoff[count]:=1 else onoff[count]:=0;\n       amplitudes[count]:=100;\n      end;\n     wavesShown:='Relaxed';\n     decayRate:=2;\n     loadDecayMults(decayRate);\n     numwaves:=60;\n     onoff[1]:=0;onoff[3]:=0;onoff[5]:=0;onoff[7]:=0;onoff[9]:=0;\n     phases[2]:=90;\n     multSumWaves:=4;\n    end;\n   if showType = 7 then {Beat}\n    begin\n     initWaves;\n     for count:=1 to maxwaves do\n      begin\n       onoff[count]:=0;\n       amplitudes[count]:=100;\n      end;\n     wavesShown:='One beat';\n     decayRate:=1;\n     loadDecayMults(decayRate);\n     numwaves:=40;\n     onoff[28]:=1;onoff[30]:=1;\n     granularity:=fine;\n     multSumWaves:=1;\n    end;\n   if showType = 8 then {Double}\n    begin\n     initWaves;\n     for count:=1 to maxwaves do\n      begin\n       onoff[count]:=0;\n       amplitudes[count]:=100;\n      end;\n     wavesShown:='Two beats';\n     decayRate:=1;\n     loadDecayMults(decayRate);\n     numwaves:=40;\n     onoff[34]:=1;onoff[36]:=1;onoff[38]:=1;\n     granularity:=fine;\n     multSumWaves:=1;\n    end;\n  End;\nEnd;\n{* End Available for external use *}\n{* END CBMv2.0 DO NOT MODIFY Procedures ********************************************}\n\n{* PROCEDURES CBMv2.0 MODIFY *******************************************************}\nProcedure ControlBoard(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);\nVar t1,t2:string;\nBegin\n Borders(x,y,numChars,numDigits,numRows,gold,darkbrown,ochre,borderFlag,backFlag);\n if borderFlag = withBorder then\n  begin\n   x:=x+4;y:=y+8;\n  end;\n     t1:='No. Waves';\n     Spinner(1,spinRow,boldText,x,y,numChars,numDigits,t1,numwaves,black,white,red);\n     t2:=' 2';\n     smallButton(x+10,y+34,2,t2,red,black);\n     t2:='10';\n     smallButton(x+54,y+34,2,t2,red,black);\n     t2:='20';\n     smallButton(x+98,y+34,2,t2,red,black);\n     t2:='40';\n     smallButton(x+142,y+34,2,t2,red,black);\n     t2:='60';\n     smallButton(x+186,y+34,2,t2,red,black);\n     t2:='Initialise all waves';\n     smallButton(x+8,y+68,16,t2,lightgreen,black);\nEnd;\nProcedure ControlBoard2(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);\nVar t1,t2:string;\nBegin\n Borders(x,y,numChars,numDigits,numRows,gold,darkbrown,ochre,borderFlag,backFlag);\n if borderFlag = withBorder then\n  begin\n   x:=x+4;y:=y+8;\n  end;\n     t1:='Select Wave';t2:='';\n     Spinner(1,spinRow,boldText,x,y,numChars,numDigits,t1,selectedWave,black,white,lime);\n     Spinner(2,tvalRow,normText,x,y,numChars,numDigits,t2,onoff[selectedWave],black,white,emerald);\n     t2:='Wave On/Off';\n     smallButton(x+28,y+34,11,t2,emerald,black);\nEnd;\nProcedure ControlBoard2a(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);\nVar t1,t2:string;\nBegin\n Borders(x,y,numChars,numDigits,numRows,gold,darkbrown,ochre,borderFlag,backFlag);\n if borderFlag = withBorder then\n  begin\n   x:=x+4;y:=y+8;\n  end;\n     t1:=' Amplitude';\n     t2:='       Phase';\n     Spinner(1,spinRow,normText,x,y,numChars,numDigits,t1,amplitudes[selectedWave],black,white,lightgreen);\n     Spinner(2,spinRow,normText,x,y,numChars,numDigits,t2,phases[selectedWave],black,white,lightgreen);\n     t2:='X';\n     smallButton(x+14,y+34,1,t2,lightgreen,black);\nEnd;\nProcedure ControlBoard3(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);\nVar t1:string;\nVar xshift:integer;\nBegin\n Borders(x,y,numChars,numDigits,numRows,gold,darkbrown,ochre,borderFlag,backFlag);\n if borderFlag = withBorder then\n  begin\n   x:=x+4;y:=y+8;\n  end;\n     xshift:=32;\n     t1:='All';\n     smallButton(x+xshift,y,2,t1,emerald,black);\n     t1:='Evens';\n     smallButton(x+xshift+55,y,5,t1,emerald,black);\n     t1:='Odds';\n     smallButton(x+xshift+150,y,5,t1,emerald,black);\n     t1:='Fibonacci';\n     smallButton(x+xshift+245,y,8,t1,emerald,black);\n     t1:='None';\n     smallButton(x+xshift+380,y,5,t1,emerald,black);\nEnd;\nProcedure ControlBoard4(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);\nVar dummy:integer;\nVar t1,t2:string;\nBegin\n Borders(x,y,numChars,numDigits,numRows,gold,darkbrown,ochre,borderFlag,backFlag);\n if borderFlag = withBorder then\n  begin\n   x:=x+4;y:=y+8;\n  end;\n     t1:='Decay Rate';t2:='%';\n     Spinner(1,textRow,boldText,x,y,numChars,numDigits,t1,dummy,black,white,darkblue);\n     Spinner(2,spinRow,boldText,x,y,numChars,numDigits,t2,decayRate,black,white,skyblue);\nEnd;\nProcedure ControlBoard5(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);\nVar dummy:integer;\nVar t1:string;\nBegin\n Borders(x,y,numChars,numDigits,numRows,ochre,darkbrown,ochre,borderFlag,backFlag);\n if borderFlag = withBorder then\n  begin\n   x:=x+4;y:=y+8;\n  end;\n     t1:='Shrink Y';\n     Spinner(1,spinRow,normText,x,y,numChars,numDigits,t1,multSumWaves,black,white,ochre);\nEnd;\nProcedure ControlBoard6(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);\nVar dummy:integer;\nVar t1:string;\nBegin\n Borders(x,y,numChars,numDigits,numRows,ochre,darkbrown,gold,borderFlag,backFlag);\n if borderFlag = withBorder then\n  begin\n   x:=x+4;y:=y+8;\n  end;\n     t1:='  Superposed Wave';\n     Spinner(1,textRow,boldText,x,y,numChars,numDigits,t1,dummy,black,white,ochre);\nEnd;\nProcedure ControlBoard7(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);\nVar dummy:integer;\nVar t1:string;\nBegin\n Borders(x,y,numChars,numDigits,numRows,ochre,darkbrown,gold,borderFlag,backFlag);\n if borderFlag = withBorder then\n  begin\n   x:=x+4;y:=y+8;\n  end;\n     t1:=' Component Waves';\n     Spinner(1,textRow,boldText,x,y,numChars,numDigits,t1,dummy,black,white,ochre);\nEnd;\nProcedure ControlBoard8(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);\nVar t1:string;\nBegin\n Borders(x,y,numChars,numDigits,numRows,gold,darkbrown,ochre,borderFlag,backFlag);\n if borderFlag = withBorder then\n  begin\n   x:=x+4;y:=y+8;\n  end;\n     t1:='Coarse';\n     smallButton(x+22,y+2,6,t1,ochre,black);\n     t1:='Fine';\n     smallButton(x+130,y+2,4,t1,ochre,black);\nEnd;\nProcedure infoBoard(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);\nVar dummy:integer;\nVar t1,t2:string;\nBegin\n Borders(x,y,numChars,numDigits,numRows,gold,blue,ochre,borderFlag,backFlag);\n if borderFlag = withBorder then\n  begin\n   x:=x+4;y:=y+8;\n  end;\n     t1:='Showing:  ' + wavesShown;\n     t2:='        Divide by';\n     Spinner(1,textRow,boldText,x,y,numChars,numDigits,t1,dummy,black,white,emerald);\n     Spinner(2,spinRow,normText,x,y,numChars,numDigits,t2,divideBy,black,white,emerald);\n     t2:='Lim';\n     smallButton(x+8,y+1*34,3,t2,emerald,black);\n     t2:='  Square';\n     smallButton(x+8,y+2*34,9,t2,emerald,black);\n     t2:='    Pulse';\n     smallButton(x+8,y+3*34,9,t2,emerald,black);\n     t2:='One beat';\n     smallButton(x+8,y+4*34,9,t2,emerald,black);\n     t2:='Shortstock';\n     smallButton(x+8,y+5*34,9,t2,emerald,black);\n     t2:=' Sawtooth';\n     smallButton(x+142,y+2*34,9,t2,emerald,black);\n     t2:='  Relaxed';\n     smallButton(x+142,y+3*34,9,t2,emerald,black);\n     t2:='Two beats';\n     smallButton(x+142,y+4*34,9,t2,emerald,black);\n     t2:='Longstock';\n     smallButton(x+142,y+5*34,9,t2,emerald,black);\nEnd;\nProcedure helpExitBoard(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);\nVar t1:string;\nBegin\n Borders(x,y,numChars,numDigits,numRows,gold,darkbrown,ochre,borderFlag,backFlag);\n if borderFlag = withBorder then\n  begin\n   x:=x+4;y:=y+8;\n  end;\n     t1:=' Menu';\n     smallButton(x+3,y,5,t1,blue,cream);\n     t1:=' Exit';\n     smallButton(x+81,y,4,t1,red,white);\nEnd;\n{**********************************************************************************}\nProcedure updateControlBoard(x,y,numChars,numDigits,borderFlag:integer);\nBegin\n if borderFlag = noBorder then\n begin\n  x:=x-4;y:=y-8;\n end;\n     incDecSpinner(1,x,y,numChars,numDigits,numwaves,1,maxwaves,1);\n     updateValueButton(x+10,y+40,2,numwaves,2,small);\n     updateValueButton(x+54,y+40,2,numwaves,10,small);\n     updateValueButton(x+98,y+40,2,numwaves,20,small);\n     updateValueButton(x+142,y+40,2,numwaves,40,small);\n     updateValueButton(x+186,y+40,2,numwaves,60,small);\n     initAllWavesButton(x+8,y+68,16,small);\nEnd;\nProcedure updateControlBoard2(x,y,numChars,numDigits,borderFlag:integer);\nBegin\n if borderFlag = noBorder then\n begin\n  x:=x-4;y:=y-8;\n end;\n incDecSpinner(1,x,y,numChars,numDigits,selectedWave,1,maxWaves,1);\n updateToggleButton(x+28,y+34,11,onoff[selectedWave],small);\nEnd;\nProcedure updateControlBoard2a(x,y,numChars,numDigits,borderFlag:integer);\nBegin\n if borderFlag = noBorder then\n begin\n  x:=x-4;y:=y-8;\n end;\n     incDecSpinner(1,x,y,numChars,numDigits,amplitudes[selectedWave],-maxAmplitude,maxAmplitude,amplitudeInc);\n     incDecSpinner(2,x,y,numChars,numDigits,phases[selectedWave],-maxPhase,maxPhase,phaseInc);\n     updateWaveButton(x+14,y+34,1,small);\nEnd;\nProcedure updateControlBoard3(x,y,numChars,numDigits,borderFlag:integer);\nVar xshift:integer;\nBegin\n if borderFlag = noBorder then\n begin\n  x:=x-4;y:=y-8;\n end;\n     xshift:=32;\n     updateShowButtons(1,x+xshift,y,2,small);\n     updateShowButtons(2,x+xshift+55,y,5,small);\n     updateShowButtons(3,x+xshift+150,y,5,small);\n     updateShowButtons(4,x+xshift+245,y,8,small);\n     updateShowButtons(5,x+xshift+380,y,5,small);\nEnd;\nProcedure updateControlBoard4(x,y,numChars,numDigits,borderFlag:integer);\nVar dummy:integer;\nBegin\n if borderFlag = noBorder then\n begin\n  x:=x-4;y:=y-8;\n end;\n     incDecDecay(2,x,y,numChars,numDigits,decayRate,0,precDecay-1,1);\nEnd;\nProcedure updateControlBoard5(x,y,numChars,numDigits,borderFlag:integer);\nBegin\n if borderFlag = noBorder then\n begin\n  x:=x-4;y:=y-8;\n end;\n     incDecSpinner(1,x,y,numChars,numDigits,multSumWaves,1,20,1);\nEnd;\nProcedure updateControlBoard8(x,y,numChars,numDigits,borderFlag:integer);\nBegin\n if borderFlag = noBorder then\n begin\n  x:=x-4;y:=y-8;\n end;\n     updateValueButton(x+22,y+8,6,granularity,course,small);\n     updateValueButton(x+130,y+8,4,granularity,fine,small);\nEnd;\nProcedure updateInfoBoard(x,y,numChars,numDigits,borderFlag:integer);\nVar dummy:integer;\nBegin\n if borderFlag = noBorder then\n begin\n  x:=x-4;y:=y-8;\n end;\n     incDecDivideBy(2,x,y,numChars,numDigits,divideBy,1,20,1);\n     updatePresetButtons(0,x+8,y+1*36,3,small);\n     updatePresetButtons(2,x+8,y+2*36,9,small);\n     updatePresetButtons(5,x+8,y+3*36,9,small);\n     updatePresetButtons(7,x+8,y+4*36,9,small);\n     updatePresetButtons(3,x+8,y+5*36,9,small);\n     updatePresetButtons(1,x+142,y+2*36,9,small);\n     updatePresetButtons(6,x+142,y+3*36,9,small);\n     updatePresetButtons(8,x+142,y+4*36,9,small);\n     updatePresetButtons(4,x+142,y+5*36,9,small);\nEnd;\nProcedure updateHelpExitBoard(x,y,numChars,numDigits,borderFlag:integer);\nVar dummy:integer;\nBegin\n if borderFlag = noBorder then\n begin\n  x:=x-4;y:=y-8;\n end;\n     updateToggleButton(x+8,y,4,infoFlag,small);\n     updateValueButton(x+76,y,4,exitFlag,1,small);\nEnd;\n{***********************************************************************************}\nProcedure displayControlBoards;\nBegin\n  ControlBoard(36,6,10,2,3,withBorder,withBackground);\n  Borders(280,2,34,0,2,gold,darkbrown,ochre,withBorder,withBackground);\n  ControlBoard2(286,10,12,2,3,noBorder,noBackground);\n  ControlBoard2a(546,10,10,4,3,noBorder,noBackground);\n  ControlBoard3(280,74,33,1,1,withBorder,withBackground);\n  ControlBoard4(810,40,2,3,2,withBorder,withBackground);\n  ControlBoard5(34,954,8,2,1,withBorder,withBackground);\n  ControlBoard6(372,956,11,2,1,withBorder,withBackground);\n  ControlBoard7(372,414,11,2,1,withBorder,withBackground);\n  ControlBoard8(750,954,10,0,1,withBorder,withBackground);\n  helpExitBoard(810,2,5,0,1,withBorder,withBackground);\n  if infoFlag = 1 then infoBoard(684,122,13,2,6,withBorder,withBackground);\nEnd;\nProcedure updateControlBoards;\nBegin\n  updateControlBoard(36,6,10,2,withBorder);\n  updateControlBoard2(286,14,12,2,noBorder);\n  updateControlBoard2a(546,14,10,4,noBorder);\n  updateControlBoard3(280,80,33,1,withBorder);\n  updateControlBoard4(810,36,2,3,withBorder);\n  updateControlBoard5(34,954,8,2,withBorder);\n  updateControlBoard8(750,954,10,0,withBorder);\n  updateHelpExitBoard(810,7,5,0,withBorder);\n  if infoFlag = 1 then updateInfoBoard(684,122,13,2,withBorder);\nEnd;\n{* END CBMv2.0 MODIFY **************************************************************}\n\n{* Fourier curve procedures ********************************************************}\n Procedure sinecurve(period,gwidth,scolour,xstart,ystart: integer);\n Var x,y,gran,step,xdiv: integer;\n Begin\n  if onoff[period] = 1 then\n  begin\n   if granularity = fine then\n    begin\n     gran:=180;\n     step:=5;\n     xdiv:=2;\n     xstart:=xstart+4;\n    end\n  else\n   begin\n    gran:=90;\n    step:=10;\n    xdiv:=1;\n   end;\n  colour(scolour);\n  setxy(xstart,ystart);\n  direction(90);\n  x:=0;\n  for x:=0 to gran do\n   begin\n    penup;\n    forward(step);\n    {forward(gwidth/gran);}\n    forget(1);\n    {pendown;}\n    left(90);\n    y:=(decayMult[period]*sin((4*x/xdiv+phases[period])*period,1,amplitudes[period]))/precDecay;\n    forward(y);\n    back(y);\n    forget(1);\n    right(90)\n   end;\n  if period=selectedwave then\n   thickness(4);\n  polyline(gran+1);\n  if period=selectedwave then\n   thickness(2);\n  end;\n End;\n Procedure addsinecurves(maxperiod,amplitude,phase,scolour,xstart,ystart: integer);\n Var x,period,y,gran,step,xdiv: integer;\n Begin\n  colour(scolour);\n  if granularity = fine then\n    begin\n     gran:=180;\n     step:=5;\n     xdiv:=2;\n     xstart:=xstart+4;\n     thickness(2);\n     colour(black);\n    end\n  else\n   begin\n    gran:=90;\n    step:=10;\n    xdiv:=1;\n    thickness(2);\n   end;\n  setxy(xstart,ystart);\n  direction(90);\n  x:=0;\n  for x:=0 to gran do\n   begin\n    penup;\n    forward(step);\n    forget(1);\n    pendown;\n    left(90);\n    y:=0;\n    for period:=1 to maxperiod do\n     begin\n      if onoff[period] = 1 then\n         y:=y+(decayMult[period]*sin((4*x/xdiv+phases[period])*period,1,amplitudes[period]))/precDecay;\n     end;\n     if multSumWaves > 0 then\n      y:=y/multSumWaves\n     else\n      if multSumWaves < 0 then\n       begin\n        y:=y*abs(multSumWaves);\n       end;\n    if granularity=fine then penup;\n    forward(y);\n    back(y);\n    pendown;\n    forget(1);\n    right(90)\n   end;\n  polyline(gran+1)\n End;\n Procedure verticalgrid(startx,starty,gwidth,gheight: integer);\n Var count: integer;\n Begin\n {Draw vertical lines of grid}\n  setxy(startx,starty+gheight);\n  colour(lightgrey);\n  direction(0);\n  for count:=1 to 9 do\n   begin\n    pendown;\n    if count=1 then\n     thickness(4)\n    else\n     thickness(2);\n    forward(2*gheight);\n    back(2*gheight);\n    right(90);\n    penup;\n    forward(gwidth/8);\n    if count mod 2=1 then\n     forward(1);\n    pendown;\n    left(90)\n   end\n End;\n Procedure horizontalgrid(startx,starty,gwidth,gheight: integer);\n Var count,steps: integer;\n Begin\n {Draw horizontal lines of grid}\n  steps:=50;\n  setxy(startx,starty-gheight);\n  colour(lightgrey);\n  direction(90);\n  for count:=1 to 2*(gheight/steps)+1 do\n   begin\n    if count=gheight/steps+1 then\n     thickness(4)\n    else\n     thickness(2);\n    pendown;\n    forward(gwidth);\n    back(gwidth);\n    right(90);\n    penup;\n    forward(steps);\n    pendown;\n    left(90)\n   end\n End;\n Procedure initialise;\n Var count: integer;\n Begin\n  keyecho(false);\n  numwaves:=2;\n  selectedwave:=1;\n  multSumWaves:=1;\n  decayRate:=10;\n  infoFlag:=0;\n  divideBy:=1;\n  granularity:=course;\n  wavesShown:='All waves';\n  loadDecayMults(decayRate);\n  for count:=1 to maxwaves do\n   begin\n    amplitudes[count]:=100;\n    phases[count]:=0;\n    onoff[count]:=1;\n   end\n End;\n Procedure displayGraphs;\n Var count: integer;\n Begin\n  Border(30,460,940,540,ochre,black,silver,withBackground);\n  Border(32,462,936,536,black,ochre,white,withBackground);\n  verticalgrid(50,730,900,250);\n  horizontalgrid(50,730,900,250);\n  addsinecurves(numwaves,100,0,darkgrey,40,730);\n  Border(30,118,940,340,ochre,darkbrown,silver,noBackground);\n  Border(32,120,936,336,darkbrown,ochre,cream,withBackground);\n  verticalgrid(50,288,900,150);\n  horizontalgrid(50,288,900,150);\n  for count:=1 to numwaves do\n   sinecurve(count,900,count,40,288);\n End;\n{* End Fourier curve procedures ****************************************************}\n\nBegin\n initialise;\n exitFlag:=0;\n repeat\n  noupdate;\n  blank(coffee);\n  displayGraphs;\n  displayControlBoards;\n  update;\n  repeat\n   pause(30);\n  until ?click > 0;\n  updateControlBoards;\n until exitFlag=1\nEnd.\n\n{* END SCBMv2.4 - DO NOT MODIFY - copyright Hugh Wallis 15/9/14 ************************}\n"},function(e,n){e.exports="PROGRAM YouAreHere;\nBEGIN\n  colour(red);\n  blot(20);\n  colour(violet);\n  print('You are here', 2, 36);\n  setxy(790, 540);\n  colour(blue);\n  drawxy(40, 0);\n  drawxy(28, -28);\n  drawxy(0, -40);\n  drawxy(-28, -28);\n  drawxy(-40, 0);\n  setxy(500, 500);\n  setxy(530, 480);\n  setxy(535, 505);\n  setxy(500, 500);\n  polyline(5);\n  polygon(3)\nEND.\n"},function(e,n,t){e.exports={AimCannon:t(196),AskInput:t(197),AutoCannon:t(198),Automata:t(199),Balls3D:t(200),BarnsleyColour:t(201),BarnsleyIFS:t(202),BouncingBall:t(203),BrownianMotion:t(204),Cheetahs:t(205),Circles:t(206),Clock:t(207),ColourSpiral:t(208),CycleColours:t(209),Diffusion:t(210),DigitalClock:t(211),Disease:t(212),DragonColour:t(213),DragonIFS:t(214),DrawPause:t(215),FiveTurtles:t(216),Flashlights:t(217),Flocking:t(218),ForLoop:t(219),GameOfLife:t(220),GravitySteps:t(221),IFSBackground:t(222),Interference:t(223),IteratedPD:t(224),KnightsTour:t(225),Launch:t(226),LifeStart:t(227),Logistic:t(228),LogisticSpider:t(229),Mandelbrot:t(230),MandelbrotMini:t(231),MandelbrotMiniSpectrum:t(232),MandelbrotSpectrum:t(233),MathFunctions:t(234),MovingBall:t(235),MultiBounce:t(236),NestedLoops:t(237),Nim:t(238),NoughtsAndCrosses:t(239),OlympicRings1:t(240),OlympicRings2:t(241),PaintApp:t(242),ParameterProcedure:t(243),PolygonRings:t(244),Polygons:t(245),Quine:t(246),RefParams:t(247),Schelling:t(248),SexRatio:t(249),Shoot:t(250),Sierpinski:t(251),SierpinskiColour:t(252),SierpinskiDots:t(253),SierpinskiIFS:t(254),SimpleDraw:t(255),SimpleProcedure:t(256),SnakeGame:t(257),SolarSystem:t(258),Stars:t(259),StringFunctions:t(260),ThePlough:t(261),TreeIFS:t(262),Triangles:t(263),TrigonometricGraphs:t(264),TurtleBounce:t(265),TurtleMove:t(266),TwoSlits:t(267),WaveSuperposer:t(268),YouAreHere:t(269)}},function(e,n){e.exports="# AimCannon\n\ndef graphaxes():\n  global distancecol, timecol\n  thickness(5)\n  setxy(9700, 600)\n  drawxy(0, 3900)\n  drawxy(-9000, 0) # x axis 700 to 9700\n  drawxy(0, -3900) # y axis 4500 to 600\n  for n in range(0, 91, 1):\n    if n mod 5 == 0:\n      setxy(650 + n * 100, 4600)\n      print(str(n), 2, 16)\n  for n in range(0, 10, 1):\n    setxy(100, 4350 - n * 400)\n    print(str(n * 1000), 2, 16)\n  for n in range(0, 10, 1):\n    setxy(9900, 4380 - n * 400)\n    print(str(n * 20), 2, 16)\n  setxy(4000, 4900)\n  print('Angle of elevation', 2, 24)\n  colour(distancecol)\n  setxy(0, 100)\n  print('Distance', 2, 24)\n  colour(timecol)\n  setxy(9600, 100)\n  print('Time', 2, 24)\n\ndef plot(x, y, col):\n  setxy(700 + x * 100, 4500 - y * 2 / 5)\n  colour(col)\n  blot(40)\n\ndef aim():\n  global gunlength\n  while (pixcol(?mousex, ?mousey) != red):\n    noupdate()\n    setxy(0, 10000)\n    colour(cream)\n    blot(1600)\n    colour(yellowgreen)\n    blot(1400)\n    colour(maroon)\n    setxy(250, 9750)\n    blot(250)\n    forward(gunlength)\n    setxy(250, 9750)\n    colour(red)\n    blot(100)\n    update()\n    while (?lmouse <= 0):\n      pass\n    if (pixcol(?mousex, ?mousey) == cream):\n      turnxy(?mousex - 250, ?mousey - 9750)\n\ndef fire(xvel, yvel, gravity, floor):\n  global turtx, turty, steps\n  setxy(250, 9750)\n  steps = 0\n  while (turty != floor):\n    inc(steps)\n    if (pixcol(turtx, turty) == black):\n      colour(white)\n      blot(80)\n    movexy(xvel, yvel)\n    yvel = yvel + gravity\n    if (turty > floor):\n      turty = floor\n    if ((pixcol(turtx, turty) == white) or (turty == floor)):\n      colour(black)\n      blot(75)\n    update()\n    pause(10)\n    noupdate()\n\ndef main():\n  global turtx, turty, turtd\n  gunlength = 1000\n  distancecol = green\n  timecol = red\n  steps = 0\n  canvas(0, 0, 10500, 10000)\n  graphaxes()\n  turtd = 45\n  thickness(20)\n  while (1 == 1):\n    aim()\n    write('Elevation: ' + str(90 - turtd))\n    fire(cos(90 - turtd, 1, 96), sin(90 - turtd, 1, -96), 1, 9950)\n    write('  Distance: ' + str(turtx))\n    writeline('  Time: ' + str(steps))\n    plot(90 - turtd, turtx, distancecol)\n    plot(90 - turtd, steps * 50, timecol)\n"},function(e,n){e.exports="# AskInput\n\ndef main():\n  name=input('What is your name?')\n  writeline('')\n  writeline('Hello, ' + name + ',')\n  writeline('How are you?')\n"},function(e,n){e.exports="# AutoCannon\n\ndef graphaxes():\n  global distancecol, timecol\n  thickness(5)\n  setxy(9700, 600)\n  drawxy(0, 3900)\n  drawxy(-9000, 0) # x axis 700 to 9700\n  drawxy(0, -3900) # y axis 4500 to 600\n  for n in range(0, 91, 1):\n    if (n mod 5 == 0):\n      setxy(650 + n * 100, 4600)\n      print(str(n), 2, 16)\n  for n in range(0, 10, 1):\n    setxy(100, 4350 - n * 400)\n    print(str(n * 1000), 2, 16)\n  for n in range(0, 10, 1):\n    setxy(9900, 4380 - n * 400)\n    print(str(n * 20), 2, 16)\n  setxy(4000, 4900)\n  print('Angle of elevation', 2, 24)\n  colour(distancecol)\n  setxy(0, 100)\n  print('Distance', 2, 24)\n  colour(timecol)\n  setxy(9600, 100)\n  print('Time', 2, 24)\n\ndef plot(x, y, col):\n  setxy(700 + x * 100, 4500 - y * 2 / 5)\n  colour(col)\n  blot(40)\n\ndef aim(elevation):\n  global gunlength\n  noupdate()\n  setxy(0, 10000)\n  colour(cream)\n  blot(1600)\n  colour(yellowgreen)\n  blot(1400)\n  colour(maroon)\n  setxy(250, 9750)\n  blot(250)\n  direction(90 - elevation)\n  forward(gunlength)\n  setxy(250, 9750)\n  colour(red)\n  blot(100)\n  update()\n\ndef fire(xvel, yvel, gravity, floor):\n  global turtx, turty\n  setxy(250, 9750)\n  steps = 0\n  while (turty != floor):\n    inc(steps)\n    if (pixcol(turtx, turty) == black):\n      colour(white)\n      blot(80)\n    movexy(xvel, yvel)\n    yvel = yvel + gravity\n    if (turty > floor):\n      turty = floor\n    if ((pixcol(turtx, turty) == white) or (turty == floor)):\n      colour(black)\n      blot(75)\n    update()\n    pause(10)\n    noupdate()\n\ndef main():\n  global turtd, turtx\n  gunlength = 1000\n  distancecol = green\n  timecol = red\n  steps = 0\n  canvas(0, 0, 10500, 10000)\n  graphaxes()\n  turtd = 45\n  thickness(20)\n  for n in range(0, 91, 1):\n    aim(n)\n    write('Elevation: ' + str(90 - turtd))\n    fire(cos(90 - turtd, 1, 96), sin(90 - turtd, 1, -96), 1, 9950)\n    write('  Distance: ' + str(turtx))\n    writeline('  Time: ' + str(steps))\n    plot(90 - turtd, turtx, distancecol)\n    plot(90 - turtd, steps * 50, timecol)\n"},function(e,n){e.exports="# Automata\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# Balls3D\n\ndef main():\n  global turtc\n  setxy(250, 250)\n  colour(0x00FFFF)\n  for count in range(240, 0, -1):\n    blot(count)\n    turtc = turtc + 0x10000\n  right(60)\n  setxy(750, 250)\n  colour(0xD2691E)\n  for count in range(40, 0, -1):\n    blot(count * 6)\n    forward(3)\n    turtc=turtc + 0x10102\n  setxy(250, 750)\n  colour(0xD2691E)\n  for count in range(40, 0, -1):\n    blot(count * 6)\n    forward(3)\n    turtc = turtc + 0x10102\n  setxy(750, 750)\n  colour(0xFFA500)\n  for count in range(80, 0, -1):\n    blot(count * 3)\n    forward(2)\n    turtc = turtc + 0x101\n"},function(e,n){e.exports="# BarnsleyColour\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# BarnsleyIFS\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# BouncingBall\n\ndef main():\n  x = 100\n  y = 700\n  xvel = 8\n  yvel = -4\n  while 0 < 1:\n    noupdate()\n    colour(white)\n    blot(51)\n    x = x + xvel\n    y = y + yvel\n    setxy(x, y)\n    colour(red)\n    blot(50)\n    update()\n    pause(5)\n    if (x < 50) or (x > 949):\n      xvel = -xvel\n    if (y < 50) or (y > 949):\n      yvel = -yvel\n"},function(e,n){e.exports="# BrownianMotion\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# Cheetahs\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# Circles\n\ndef main():\n  thickness(6)\n  penup()\n  blank(black)\n  colour(orange)\n  for count in range(0, 36, 1):\n    forward(200)\n    circle(200)\n    back(200)\n    right(10)\n    pause(25)\n"},function(e,n){e.exports="# Clock\n\ndef showhands():\n  global hours, minutes\n  colour(white)\n  blot(360)\n  colour(red)\n  direction(hours * 30)\n  thickness(10)\n  forward(250)\n  back(250)\n  direction(minutes * 6)\n  thickness(6)\n  forward(350)\n  back(350)\n\ndef main():\n  global hours, minutes\n  thickness(10)\n  circle(400)\n  hours = 0\n  minutes = 0\n  while not(hours == 12):\n    while not(minutes == 60):\n      showhands()\n      pause(600)\n      inc(minutes)\n    inc(hours)\n    minutes = 0\n  showhands()\n"},function(e,n){e.exports="# ColourSpiral\n\ndef lineturn():\n  global length\n  forward(length)\n  right(60)\n\ndef main():\n  global length\n  blank(black)\n  forward(15)\n  thickness(27)\n  length=20\n  while length <= 500:\n    randcol(40)\n    lineturn()\n    length = length + 10\n"},function(e,n){e.exports="# CycleColours\n\ndef main():\n  global turtc\n  blank(black)\n  colinc=randint(0, 4)\n  colcode=randint(1, 20)\n  colour(rgb(colcode))\n  length = 0\n  thickness(16)\n  while not(length > 250):\n    colcode=(colcode + colinc) % 20 + 1\n    colour(rgb(colcode))\n    length = length + 1\n    forward(length)\n    right(30)\n"},function(e,n){e.exports="# Diffusion\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# DigitalClock\n\ndef showtime():\n  global hours, minutes\n  setxy(300, 430)\n  box(400, 130, white, False)\n  if hours < 10:\n    hstring = '0' + str(hours)\n  else:\n    hstring = str(hours)\n  if minutes < 10:\n    mstring = '0' + str(minutes)\n  else:\n    mstring = str(minutes)\n  print(hstring + ':' + mstring, 21, 100)\n\ndef main():\n  global hours, minutes\n  blank(lightgreen)\n  setxy(250, 390)\n  colour(maroon)\n  thickness(10)\n  box(500, 210, lightbrown, True)\n  colour(black)\n  hours = 0\n  minutes = 0\n  while hours < 12:\n    showtime()\n    pause(600)\n    inc(minutes)\n    if minutes == 60:\n      inc(hours)\n      minutes = 0\n  showtime()\n"},function(e,n){e.exports="# Disease\n\ndef infect(x, y):\n  global infected, numinfected\n  pixset(x, y, infected)\n  inc(numinfected)\n\ndef main():\n  width = 100\n  height = 100\n  susceptible = lightgreen\n  infected = red\n  recovered = blue\n  startradius = 10\n  infectprob = 1\n  immuneprob = 2\n  recoverprob = 15\n  canvas(0, 0, width, height)\n  resolution(width, height)\n  numinfected = 0\n  noupdate()\n  for x in range(0, width, 1):\n    for y in range(0, height, 1):\n      if ((randint(0, 100) < infectprob) and (hypot(x - width / 2, y - height / 2, 1) <= startradius)):\n        infect(x, y)\n      else:\n        if (randint(0, 100) < immuneprob):\n          pixset(x, y, recovered)\n        else:\n          pixset(x, y, susceptible)\n  update()\n  while (numinfected > 0):\n    x = randint(0, width)\n    y = randint(0, height)\n    if (pixcol(x, y) == infected):\n      if (randint(0, 100) < recoverprob):\n        pixset(x, y, recovered)\n        dec(numinfected)\n    else:\n      n = randint(0, 4) * 2 + 1\n      x = x + n // 3 - 1\n      y = y + n % 3 - 1\n      if (pixcol(x, y) == susceptible):\n        infect(x, y)\n"},function(e,n){e.exports="# DragonColour\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# DragonIFS\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# DrawPause\n\ndef main():\n  colour(green)\n  blot(100)\n  pause(1000)\n  colour(red)\n  forward(450)\n  pause(1000)\n  right(90)\n  thickness(9)\n  colour(blue)\n  pause(1000)\n  forward(300)\n"},function(e,n){e.exports="# FiveTurtles\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# Flashlights\n\ndef drawit(blob):\n  temp = 0\n  temp = blob\n  if blob:\n    randcol(10)\n    blot(25)\n  else:\n    colour(black)\n    blot(30)\n    randcol(10)\n    circle(25)\n\ndef main():\n  blot(1000)\n  thickness(8)\n  while True:\n    setx(randint(1, 8) * 111)\n    sety(randint(1, 8) * 111)\n    drawit(randint(0, 1) == 1)\n"},function(e,n){e.exports="# Flocking\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# ForLoop\n\ndef main():\n  for count in range(0, 200, 1):\n    forward(count // 3)\n    right(5)\n    colour(red)\n    blot(200)\n    colour(black)\n    circle(200)\n"},function(e,n){e.exports="# GameOfLife\n\ndef main():\n  width = 32\n  height = 32\n  canvas(0, 0, width, height)\n  resolution(width, height)\n  for x in range(0, width, 1):\n    for y in range(0, height, 1):\n      if randint(0, 6) == 0:\n        pixset(x, y, black)\n  while ?key != \\escape:\n    for x in range(0, width, 1):\n      for y in range(0, height, 1):\n        dn = 0\n        for i in range(-1, 2, 1):\n          for j in range(-1, 2, 1):\n            dn = dn + pixcol((x + i + width) % width, (y + j + height) % height) and 1\n        if ((pixcol(x, y) and 1 == 0) and ((dn < 5) or (dn > 6))) or ((pixcol(x, y) and 1 == 1) and (dn == 6)):\n          pixset(x, y, pixcol(x, y) xor 2)\n    for x in range(0, width + 1, 1):\n      for y in range(0, height + 1, 1):\n        if (pixcol(x, y) and 3) % 3 != 0:\n          pixset(x, y, pixcol(x, y) xor 0xFFFFFD)\n"},function(e,n){e.exports="# GravitySteps\n\ndef steps(s):\n  size = 1000 / s\n  setxy(0, 1000)\n  thickness(1)\n  for count in range(0, s * 2, 1):\n    if count % 2 == 1:\n      movexy(0, -size)\n    else:\n      movexy(size, 0)\n  movexy(0, s * size)\n  movexy(-s * size, 0)\n  colour(blue)\n  polygon(s * 2 + 2)\n\ndef throwball(xvel, yvel, gravity, floor):\n  global turty\n  dec(turty)\n  while (turty != floor):\n    colour(white)\n    blot(25)\n    movexy(xvel, yvel)\n    yvel = yvel + gravity\n    if turty > floor:\n      turty = floor\n    colour(red)\n    blot(24)\n    update()\n    pause(10)\n    noupdate()\n\ndef main():\n  global turtx, turty\n  steps(10)\n  setxy(950, 75)\n  while not(turtx < 75):\n    throwball(-2, -22, 1, turty + 100)\n  for bounce in range(0, 10, 1):\n    throwball(0, bounce * 2 - 18, 1, turty)\n"},function(e,n){e.exports="# IFSBackground\n\ndef background(rad):\n  global gridscale, gridthick\n  thickness(gridthick)\n  colour(darkgrey)\n  for x in range(1, gridscale, 1):\n    setxy(xleft + divmult(xright - xleft, gridscale, x), ytop)\n    drawxy(0, ybottom - ytop)\n  for y in range(1, gridscale, 1):\n    setxy(xleft + gridthick / 2, ytop + divmult(ybottom - ytop, gridscale, y))\n    drawxy(xright - xleft - gridthick, 0)\n  colour(black)\n  setxy(xleft, ytop)\n  drawxy(xright - xleft, 0)\n  drawxy(0, ybottom - ytop)\n  drawxy(xleft - xright, 0)\n  drawxy(0, ytop - ybottom)\n  for x in range(1, gridscale, 1):\n    for y in range(1, gridscale, 1):\n      cx = xleft + divmult(xright - xleft, gridscale, x) + gridthick\n      cy = ytop + divmult(ybottom - ytop, gridscale, y) + gridthick\n      r = divmult(255, gridscale - 1, x)\n      g = divmult(255, gridscale - 1 , y)\n      b = divmult(255, 2 * gridscale - 2, 2 * gridscale - 2 - x - y)\n      recolour(cx, cy, (r * 0x10000) + (g * 0x100) + (b * 0x1))\n\ndef main():\n  xleft = 0\n  xright = 999\n  ytop = 0\n  ybottom = 999\n  gridscale = 5\n  gridthick = 64\n  canvas(xleft, ytop, xright - xleft + 1, ybottom - ytop + 1)\n  resolution(xright - xleft + 1, ybottom - ytop + 1)\n  background(6)\n"},function(e,n){e.exports="# Interference\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# IteratedPD\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# KinghtsTour\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# Launch\n\n  Procedure drawrocket\n  Begin\n    noupdate\n    blank(black)\n    colour(teal)\n    setxy(0, 0)\n    blot(earthradius / 1000)\n    setxy(x / 1000, y / 1000)\n    direction(d)\n    thickness(4)\n    colour(silver)\n    forward(200)\n    back(200)\n    if thrust > 0 then\n      begin\n        thickness(8)\n        colour(yellow)\n        back(200)\n        forward(200)\n      end\n    update\n  End\n\n  Procedure report\n  Begin\n    writeln('')\n    writeln('TIME = ' + str(t))\n    writeln(' Xposition = ' + str(x) + ' metres')\n    writeln(' Yposition = ' + str(y) + ' metres')\n    writeln(' Height = ' + qstr(dist - earthradius, 1000, 2) + ' km')\n    writeln(' Direction = ' + qstr(d, 3600, 1) + ' degrees')\n    writeln(' Thrust = ' + qstr(thrust, 1000, 1) + ' newtons per kg')\n    writeln('  Xthrust = ' + qstr(xthrust, 1000, 1) + ' newtons per kg')\n    writeln('  Ythrust = ' + qstr(ythrust, 1000, 1) + ' newtons per kg')\n    writeln(' Gravity = ' + qstr(gravity, 1000, 1) + ' newtons per kg')\n    writeln('  Xgravity = ' + qstr(xgravity, 1000, 1) + ' newtons per kg')\n    writeln('  Ygravity = ' + qstr(ygravity, 1000, 1) + ' newtons per kg')\n    writeln(' Xvelocity = ' + qstr(xvel, 1000, 1) + ' metres per s')\n    writeln(' Yvelocity = ' + qstr(yvel, 1000, 1) + ' metres per s')\n  End\n\ndef main():\n  earthradius = 6371000 # m\n  earthGM = 398600442 # km3 / s2 * 1000\n  initdirection = 2000 # seconds of arc\n  initthrust = 20000 # milliN per kg\n  thrusttime = 500\n  angleprecision = 1296000 # seconds of arc\n  canvas(-10000, -10000, 20000, 20000)\n  angles(angleprecision)\n  x = 0\n  y = -earthradius # metres\n  xvel = 0\n  yvel = 0\n  d = initdirection\n  t = 0\n  prevdiff = 1 # so first apogee will report\n  thrust = initthrust\n  while (earthradius < dist) and (dist < 40000000):\n    drawrocket()\n    prevdist = dist\n    dist = hypot(x, y ,1)\n    if ((dist - prevdist) * prevdiff <= 0):\n      report()\n    prevdiff = dist - prevdist\n    gravity = divmult(earthGM, divmult(dist, 1000000, dist), 1000)\n    xgravity = divmult(gravity, dist, -x)\n    ygravity = divmult(gravity, dist, -y)\n    xthrust = sin(d, 1, thrust)\n    ythrust = -cos(d, 1, thrust)\n    xvel = xvel + xgravity + xthrust\n    yvel = yvel + ygravity + ythrust\n    x = x + xvel / 1000\n    y = y + yvel / 1000\n    # report()\n    if (yvel > 0):\n      d = angleprecision / 2 - arctan(xvel, yvel, 1)\n    else:\n      d = arctan(xvel, -yvel, 1)\n    inc(t)\n    if (t == thrusttime):\n      thrust = 0\n  if (dist < earthradius):\n    colour(yellow)\n    for explosion in range(100, 200, 1):\n      blot(explosion)\n      pause(3)\n    colour(black)\n    blot(200)\n"},function(e,n){e.exports="# LifeStart\n\ndef main():\n  width = 32\n  height = 32\n  canvas(0, 0, width, height)\n  resolution(width, height)\n  for x in range(0, width, 1):\n    for y in range(0, height, 1):\n      if (randint(0, 6) == 0):\n        pixset(x, y, black)\n      else:\n        pixset(x, y, white)\n"},function(e,n){e.exports="# Logistic\n\ndef axes():\n  global lmargin, maxgen, maxpop, r\n  colour(black)\n  for i in range(0, 11, 1):\n    setxy(i * 100 - 25, 1000)\n    print(str(i * maxgen / 10), 4, 20)\n  for i in range(1, 11, 1):\n    setxy(-lmargin + 5, 1000 - i * 100 - 20)\n    print(str(i * maxpop / 10), 4, 20)\n  setxy(0, 0)\n  drawxy(0, 1000)\n  drawxy(1000, 0)\n  colour(red)\n  setxy(0, 1060)\n  print('Population over ' + str(maxgen) + ' generations, where P (population/' + str(maxpop) + ')', 4, 25)\n  setxy(0, 1110)\n  print('is determined by the logistic equation P\\' = rP(1 - P), with r = ' + qstr(r, 10, 1), 4, 25)\n\ndef menu():\n  global tmargin, r\n  colour(black)\n  setxy(10, -tmargin + 20)\n  print('Set r:', 4, 25)\n  for i in range(21, 41, 1):\n    setxy(((i - 1) % 10) * 90 + 130,((i - 1) // 10) * 50 - 100 - tmargin)\n    if (i == r):\n      box(90, 50, red, True)\n    else:\n      box(90, 50, cream, True)\n    print('  ' + qstr(i, 10, 1), 4, 25)\n\ndef main():\n  maxpop = 100000\n  maxgen = 100\n  lmargin = 105\n  rmargin = 40\n  tmargin = 150\n  bmargin = 200\n  showoutput = False\n  canvas(-lmargin, -tmargin, 1000 + lmargin + rmargin, 1000 + tmargin + bmargin)\n  resolution(1000 + lmargin + rmargin, 1000 + tmargin + bmargin)\n  thickness(3)\n  r = 30\n  while True:\n    noupdate()\n    blank(white)\n    axes()\n    menu()\n    colour(blue)\n    pop = randint(0, maxpop - 8) + 10\n    if showoutput:\n      writeline('')\n      writeline('r = ' + qstr(r, 10, 1) + ' Initial population = ' + str(pop))\n    setxy(0, 1000 - divmult(pop, maxpop, 1000))\n    for gen in range(1, maxgen + 1, 1):\n      pop = divmult(pop, 10 * maxpop, r * (maxpop - pop))\n      setxy(divmult(gen, maxgen, 1000), 1000 - divmult(pop, maxpop, 1000))\n      polyline(2)\n      if showoutput:\n        write(str(pop) + ' ')\n        if (gen % 10 == 0):\n          writeline('')\n    heapreset()\n    update()\n    while not((?lmouse > 0) and (?clicky < (100 - tmargin)) and (?clickx >= 130) and (?clickx < 1030)):\n      pass\n    r = ((?clickx - 130) // 90) + ((?clicky + tmargin + 100) // 50) * 10 + 1\n"},function(e,n){e.exports="# Logistic Spider\n\ndef axes():\n  global lmargin, maxgen, maxpop\n  colour(black)\n  for i in range(0, 11, 1):\n    setxy(i * 100 - 25, 1000)\n    print(qstr(i, 10, 1), 4, 20)\n  for i in range(1, 11, 1):\n    setxy(-lmargin + 5, 1000 - i * 100 - 20)\n    print(qstr(i, 10, 1), 4, 20)\n  setxy(0, 0)\n  drawxy(0, 1000)\n  drawxy(1000, 0)\n  colour(red)\n  setxy(0, 1060)\n  print('Population over ' + str(maxgen) + ' generations, where P (population/' + str(maxpop) + ')', 4, 25)\n  setxy(0, 1110)\n  print('is determined by the logistic equation P'' = rP(1 - P), with r = ' + qstr(r, 10, 1), 4, 25)\n\ndef menu():\n  global tmargin\n  colour(black)\n  setxy(10, -tmargin + 20)\n  print('Set k:', 4, 25)\n  for i in range(21, 41, 1):\n    setxy(((i - 1) % 10) * 90 + 130,((i - 1) // 10) * 50 - 100 - tmargin)\n    if (i == r):\n      box(90, 50, red, true)\n    else:\n      box(90, 50, cream, true)\n    print('  ' + qstr(i, 10, 1), 4, 25)\n\ndef curve():\n  global maxpop\n  noupdate()\n  colour(black)\n  setxy(0, 1000)\n  drawxy(1000, -1000)\n  colour(blue)\n  setxy(0, 1000)\n  for i in range(1, 1001, 1):\n    pop = divmult(i, 1000, maxpop)\n    nextpop = divmult(pop, 10 * maxpop, r * (maxpop - pop))\n    setxy(divmult(pop, maxpop, 1000), 1000 - divmult(nextpop, maxpop, 1000))\n    polyline(2)\n  update()\n\ndef main():\n  maxpop = 100000\n  maxgen = 100\n  lmargin = 60\n  rmargin = 40\n  tmargin = 150\n  bmargin = 200\n  output = true\n  canvas(-lmargin, -tmargin, 1000 + lmargin + rmargin, 1000 + tmargin + bmargin)\n  resolution(1000 + lmargin + rmargin, 1000 + tmargin + bmargin)\n  thickness(3)\n  r = 30\n  repeat\n    noupdate\n    blank(white)\n    axes\n    menu\n    curve\n    pop := random(maxpop - 9) + 10\n    if output then\n      begin\n        writeln('')\n        writeln('r = ' + qstr(r, 10, 1) + ' Initial population = ' + str(pop))\n      end\n    setxy(divmult(pop, maxpop, 1000), 1000)\n    for gen := 1 to maxgen do\n      begin\n        pop := divmult(pop, 10 * maxpop, r * (maxpop - pop))\n        colour(mixcols(lightgreen, green, maxgen - gen, gen))\n        drawxy(0, 1000 - divmult(pop, maxpop, 1000) - turty)\n        drawxy(divmult(pop, maxpop, 1000) - turtx, 0)\n        if output then\n          begin\n            write(str(pop) + ' ')\n            if gen mod 10 = 0 then\n              writeln('')\n          end\n      end\n    blot(3)\n    heapreset\n    update\n    repeat\n    until (?lmouse > 0) and (?clicky < (100 - tmargin)) and (?clickx >= 130) and (?clickx < 1030)\n    r := ((?clickx - 130) div 90) + ((?clicky + tmargin + 100) div 50) * 10 + 1\n  until 0 = 1\nEND.\n"},function(e,n){e.exports="# Mandelbrot\n\ndef main():\n  maxcol = 40\n  scale = 250\n  pixels = 750\n  xcentre = -500000 # millionths\n  ycentre = 0 # millionths\n  xstart = divmult(xcentre, 1000000, scale) - pixels / 2\n  ystart = divmult(ycentre, 1000000, scale) - pixels / 2\n  xfinish = xstart + pixels - 1\n  yfinish = ystart + pixels - 1\n  canvas(xstart, ystart, pixels, pixels)\n  resolution(pixels, pixels)\n  timeset(0)\n  for a in range(xstart, xfinish + 1, 1):\n    noupdate()\n    for b in range(ystart, yfinish + 1, 1):\n      x = a\n      y = b\n      iterations = 0\n      while ((hypot(x, y, 1) < 2 * scale) and (iterations <= maxcol)):\n        temp = divmult(x + y, scale, x - y)\n        y = divmult(2 * x, scale, y) + b\n        x = temp + a\n        inc(iterations)\n      if (iterations > maxcol):\n        pixset(a, b, black)\n      else:\n        pixset(a, b, rgb(iterations + 1))\n    update()\n  writeline('Resolution: ' + str(scale * 3) + ' Time taken: ' + qstr(time, 1000, 1) + ' seconds.')\n"},function(e,n){e.exports="# MandelbrotMini\n\ndef main():\n  maxcol = 40\n  scale = 10000\n  pixels = 300\n  xcentre = -159200\n  ycentre = -1033000\n  xstart = divmult(xcentre, 1000000, scale) - pixels / 2\n  ystart = divmult(ycentre, 1000000, scale) - pixels / 2\n  xfinish = xstart + pixels - 1\n  yfinish = ystart + pixels - 1\n  canvas(xstart, ystart, pixels, pixels)\n  resolution(pixels, pixels)\n  timeset(0)\n  for a in range(xstart, xfinish + 1, 1):\n    noupdate()\n    for b in range(ystart, yfinish + 1, 1):\n      x = a\n      y = b\n      iterations = 0\n      while ((hypot(x, y, 1) < 2 * scale) and (iterations <= maxcol)):\n        temp = divmult(x + y, scale, x - y)\n        y = divmult(2 * x, scale, y) + b\n        x = temp + a\n        inc(iterations)\n      if (iterations > maxcol):\n        pixset(a, b, black)\n      else:\n        pixset(a, b, rgb(iterations + 1))\n    update()\n  writeline('Resolution: ' + str(scale * 3) + ' Time taken: ' + qstr(time, 1000, 1) + ' seconds.')\n"},function(e,n){e.exports="# MandelbrotMiniSpectrum\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# MandelbrotSpectrum\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# MathFunctions\n\ndef show(s, n):\n  global a, b, denominator, decimals\n  writeline(s + '(' + str(a) + ' / ' + str(b) + ') = ' + qstr(n, denominator, decimals))\n\ndef selectab():\n  global a, b\n  a = randint(100, 999)\n  b = randint(100, 999)\n\ndef main():\n  global a, b, denominator, decimals\n  decimals = 4\n  denominator = 1000000\n  output(-1, white, -1)\n  writeline('This program selects two random numbers a and b, in the')\n  writeline('range 100-999, and then outputs various mathematical')\n  writeline('functions of the fraction a/b. The results are expressed')\n  writeline('to ' + str(decimals) + ' decimal places, and a denominator of ' + str(denominator) + ' is')\n  writeline('used in the calculations to provide precision, even')\n  writeline('though the Turtle functions strictly operate only on')\n  writeline('integers and produce integer results.')\n  writeline('')\n  selectab()\n  writeline('a = ' + str(a) + '; b = ' + str(b))\n  writeline('a / b = ' + str(a) + ' / ' + str(b) + ' = ' + qstr(a, b, decimals))\n  writeline('')\n  show('square', power(a, b, 2, denominator))\n  show('square root', root(a, b, 2, denominator))\n  show('cube', power(a, b, 3, denominator))\n  show('cube root', root(a, b, 3, denominator))\n  writeline('')\n  show('hypot', hypot(a, b, denominator))\n  show('calculated hypot', sqrt(a * a + b * b, denominator))\n  writeline('')\n  show('sin', sin(a, b, denominator))\n  show('cos', cos(a, b, denominator))\n  show('tan', tan(a, b, denominator))\n  writeline('')\n  show('ln', ln(a, b, denominator))\n  if divmult(a, b, 1000) + ln(denominator, 1, 1000) > ln(maxint, 1, 1000):\n    writeline('EXP(' + str(a) + ' / ' + str(b) + ') would give numerical overflow, because')\n    writeline('the result * ' + str(denominator) + ' would be greater than ' + str(maxint))\n  else:\n    show('exp', exp(a, b, denominator))\n  show('log10', log10(a, b, denominator))\n  if divmult(a, b, 1000) + log10(denominator, 1, 1000) > log10(maxint, 1, 1000):\n    writeline('ANTILOG(' + str(a) + ' / ' + str(b) + ') would give numerical overflow, because')\n    writeline('the result * ' + str(denominator) + ' would be greater than ' + str(maxint))\n  else:\n    show('antilog', antilog(a, b, denominator))\n  writeline('')\n  if a > b:\n    writeline('ARCCOS and ARCSIN are not defined for ' + str(a) + ' / ' + str(b) + ' = ' + qstr(a, b, decimals))\n  else:\n    show('arccos', acos(a, b, denominator))\n    show('arcsin', asin(a, b, denominator))\n  show('arctan', atan(a, b, denominator))\n"},function(e,n){e.exports="# MovingBall\n\ndef main():\n  x = 100\n  y = 700\n  for count in range(0, 100, 1):\n    noupdate()\n    colour(white)\n    blot(51)\n    x = x + 8\n    y = y - 4\n    setxy(x, y)\n    colour(red)\n    blot(50)\n    update()\n    pause(5)\n"},function(e,n){e.exports="# MultiBounce\n\n# to do\n"},function(e,n){e.exports="# NestedLoops\n\ndef main():\n  penup()\n  for countblot in range(0, 10, 1):\n    forward(260)\n    colour(black)\n    blot(150)\n    colour(rgb(countblot + 1))\n    for countcirc in range(1, 26, 1):\n      circle(countcirc*8)\n    back(260)\n    right(36)\n"},function(e,n){e.exports="# Nim\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# NoughtsAndCrosses\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# OlympicRings1\n\ndef main():\n  thickness(20)\n  penup()\n  forward(50)\n  circle(130)\n  left(90)\n  forward(300)\n  colour(blue)\n  circle(130)\n  back(600)\n  colour(red)\n  circle(130)\n  forward(150)\n  right(90)\n  back(125)\n  colour(lime)\n  circle(130)\n  left(90)\n  forward(300)\n  colour(yellow)\n  circle(130)\n"},function(e,n){e.exports="# OlympicRings2\n\ndef main():\n  ringsize=130\n  thickness(20)\n  penup()\n  forward(50)\n  circle(ringsize)\n  left(90)\n  forward(300)\n  colour(blue)\n  circle(ringsize)\n  back(600)\n  colour(red)\n  circle(ringsize)\n  forward(150)\n  right(90)\n  back(125)\n  colour(lime)\n  circle(ringsize)\n  left(90)\n  forward(300)\n  colour(yellow)\n  circle(ringsize)\n"},function(e,n){e.exports="# PaintApp\n\ndef setbrushwidth(wdth):\n  global brushwidth,brushcolour\n  brushwidth=0\n  colour(black)\n  for count in range(0,5,1):\n    setxy(625+count*50,875)\n    blot(8+count*2)\n  colour(brushcolour)\n  brushwidth=wdth\n  recolour(((brushwidth+16)*25)+25,875,lightred)\n\ndef setbrushcolour(clr):\n  global brushcolour\n  brushcolour=clr\n  colour(clr)\n  setxy(975,875)\n  blot(16)\n\ndef paintbrush(x,y):\n  global brushwidth\n  setxy(x,y)\n  blot(brushwidth)\n\ndef paintcan(x,y):\n  global brushcolour\n  recolour(x,y,brushcolour)\n\ndef setup():\n\n  def square(col):\n    movexy(50,0)\n    movexy(0,50)\n    movexy(-50,0)\n    movexy(0,-50)\n    colour(col)\n    polygon(4)\n\n  def text(s):\n    colour(black)\n    print(s,0,20)\n\n  colour(lightred)\n  setxy(0,850)\n  drawxy(1000,0)\n  setxy(0,900)\n  drawxy(1000,0)\n  setxy(450,850)\n  drawxy(0,50)\n  setxy(850,850)\n  drawxy(0,50)\n  setxy(10,858)\n  text('Left-click to draw, right-click to fill')\n  setxy(450+10,858)\n  text('Brush width:')\n  setxy(850+10,858)\n  text('Colour:')\n  setxy(0,900)\n  for count in range(1,21,1):\n    square(rgb(count))\n    movexy(0,50)\n    square(rgb(count+30))\n    movexy(50,-50)\n  setbrushwidth(8)\n  setbrushcolour(black)\n\ndef main():\n  global brushwidth,brushcolour\n  setup()\n  while True:\n    if ?lmouse>0:\n      if ?mousey>900:\n        setbrushcolour(pixcol(?mousex,?mousey))\n      else:\n        if ((?mousey>850) and ((?mousex>600) and (?mousex<850))):\n          setbrushwidth(((?mousex//50)*2)-16)\n        else:\n          if ?mousey<850-brushwidth:\n            paintbrush(?mousex,?mousey)\n    if (?rmouse>0) and (?mousey<850):\n      paintcan(?mousex,?mousey)\n    update()\n"},function(e,n){e.exports="# ParameterProcedure\n\ndef prong(length):\n  forward(length)\n  blot(length // 20)\n  back(length)\n\ndef main():\n  for count in range(360, 0, -1):\n    randcol(10)\n    prong(count + 100)\n    right(61)\n"},function(e,n){e.exports="# PolygonRings\n\ndef annulus(inner, width, angle):\n  global turtc\n  for count in range(0, 360 // angle + 1, 1):\n    forward(inner + width)\n    back(width)\n    back(inner)\n    forget(1)\n    right(angle)\n    forward(inner)\n    forward(width)\n    colour(rgb(count % 20 + 1))\n    polygon(4)\n    back(inner + width)\n\ndef main():\n  penup()\n  blot(500)\n  randcol(6)\n  annulus(410, 80, 2)\n  annulus(310, 80, 3)\n  annulus(210, 80, 5)\n  annulus(110, 80, 7)\n  annulus(10, 80, 1)\n"},function(e,n){e.exports="# Polygons\n\ndef poly(points,col):\n  direction(90)\n  for count in range(0, points, 1):\n    forward(600 // points)\n    left(360 // points)\n  colour(col)\n  polygon(points)\n  colour(black)\n  polyline(points + 1)\n\ndef main():\n  penup()\n  thickness(4)\n  setxy(100, 400)\n  poly(3, blue)\n  setxy(400, 400)\n  poly(4, red)\n  setxy(700, 400)\n  poly(5, yellow)\n  setxy(150, 750)\n  poly(6, pink)\n  setxy(440, 750)\n  poly(7, green)\n  setxy(740, 750)\n  poly(8, turquoise)\n"},function(e,n){e.exports="# Quine\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# RefParams\n\n# this program is not available in Turtle Python\n# (Python does not have reference parameters)\n"},function(e,n){e.exports="# Schelling\n\ndef happy(x, y, c):\n  global empty\n  like = 0\n  unlike = 0\n  for i in range(-1, 2, 1):\n    for j in range(-1, 2, 1):\n      if (i != 0) or (j != 0):\n        neighbour = pixcol(x + i, y + j)\n        if neighbour != empty:\n          if neighbour == c:\n            inc(like)\n          else:\n            inc(unlike)\n  return (like >= unlike - 1)\n\ndef main():\n  width = 32\n  height = 32\n  empty = green\n  canvas(-1, -1, width + 2, height + 2)\n  resolution(width + 2, height + 2)\n  noupdate()\n  blank(empty)\n  for i in range(0, width, 1):\n    for j in range(0, height, 1):\n      test = randint(0, 24)\n      if test == 0:\n        pixset(i, j, empty)\n      else:\n        if (i + j) % 2 == 0:\n          pixset(i, j, red)\n        else:\n          pixset(i, j, blue)\n  pause(2000)\n  while ?key != \\escape:\n    noupdate()\n    continue = True\n    while continue:\n      tryi = randint(0, width - 1)\n      tryj = randint(0, height - 1)\n      this = pixcol(tryi, tryj)\n      if (this != empty) and (not(happy(tryi, tryj, this))):\n        continue = False\n    pixset(tryi, tryj, empty)\n    continue = True\n    while continue:\n      tryi = randint(0, width - 1)\n      tryj = randint(0, height - 1)\n      if (pixcol(tryi, tryj) == empty) and happy(tryi, tryj, this):\n        continue = False\n    pixset(tryi, tryj, this)\n    update()\n"},function(e,n){e.exports="# SexRatio\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# Shoot\n\ndef bottle(x,y):\n  setxy(x,y)\n  colour(cyan)\n  movexy(0,-15)\n  thickness(40)\n  drawxy(0,-50)\n  thickness(10)\n  drawxy(0,-40)\n  thickness(2)\n  movexy(-20,90)\n  movexy(40,0)\n  movexy(0,-20)\n  movexy(-40,0)\n  colour(purple)\n  polygon(4)\n  movexy(20,35)\n\ndef addhat():\n  global facex,facey\n  setxy(facex,facey-80)\n  colour(darkgrey)\n  ellblot(90,30)\n  thickness(2)\n  colour(black)\n  ellipse(90,30)\n  movexy(-70,0)\n  thickness(4)\n  drawxy(35,-70)\n  drawxy(70,0)\n  drawxy(35,70)\n  colour(darkgrey)\n  thickness(1)\n  polygon(4)\n\ndef face():\n  global facex,facey\n  thickness(1)\n  colour(#FF8899)\n  blot(100)\n  colour(white)\n  setxy(facex-20,facey-20)\n  blot(10)\n  colour(black)\n  blot(4)\n  thickness(4)\n  movexy(0,-22)\n  colour(#663300)\n  drawxy(15,15)\n  thickness(1)\n  colour(white)\n  setxy(facex+20,facey-20)\n  blot(10)\n  colour(black)\n  blot(4)\n  thickness(4)\n  movexy(0,-22)\n  colour(#663300)\n  drawxy(-15,15)\n  addhat()\n  setxy(facex,facey+13)\n  colour(red)\n  blot(10)\n  movexy(0,32)\n  ellblot(30,6)\n  colour(white)\n  ellblot(20,4)\n\ndef background():\n  blank(coffee)\n  bottle(100,500)\n  bottle(200,500)\n  bottle(450,500)\n  bottle(500,500)\n  bottle(565,500)\n  bottle(865,500)\n  colour(darkbrown)\n  thickness(20)\n  setxy(0,125)\n  drawxy(1000,0)\n  setxy(0,325)\n  drawxy(1000,0)\n  setxy(0,525)\n  drawxy(1000,0)\n  colour(brown)\n  thickness(30)\n  setxy(0,100)\n  drawxy(1000,0)\n  setxy(0,300)\n  drawxy(1000,0)\n  setxy(0,500)\n  drawxy(1000,0)\n\ndef gunsight():\n  colour(black)\n  thickness(6)\n  setxy(?mousex-50,?mousey)\n  drawxy(100,0)\n  setxy(?mousex,?mousey-50)\n  drawxy(0,100)\n\ndef main():\n  global facex,facey\n  facex=-100\n  facey=625\n  facexspeed=5\n  faceyspeed=0\n  targets=10\n  hits=0\n  cursor(0)\n  while hits<targets:\n    noupdate()\n    background()\n    setxy(facex,facey)\n    face()\n    for i in range(0,hits,1):\n      bottle(50*i+15,740)\n    colour(brown)\n    thickness(272)\n    setxy(0,863)\n    drawxy(1000,0)\n    gunsight()\n    thickness(2)\n    update()\n    facex=facex+facexspeed\n    facey=facey+faceyspeed\n    if facex>1100:\n      facex=-100\n    if facex<-100:\n      facex=1100\n    if (facey<100) or (facey>625):\n      faceyspeed=faceyspeed*-1\n    if ((?lmouse>0) and (((?mousex-facex)*(?mousex-facex))+((?mousey-facey)*(?mousey-facey))<10000)):\n      facex=-100\n      facexspeed=randint(2,6)\n      faceyspeed=randint(-4,4)\n      facey=randint(50,599)\n      inc(hits)\n  blank(black)\n  setxy(200,450)\n  colour(green)\n  print('  Well done!  ',4,75)\n"},function(e,n){e.exports="# Sierpinski\n\ndef triangle(x1, y1, x2, y2, x3, y3):\n  setxy(x1, y1)\n  setxy(x2, y2)\n  setxy(x3, y3)\n  setxy(x1, y1)\n  colour(black)\n  polyline(4)\n  if (hypot(x2 - x1, y2 - y1, 1) > 3):\n    x12 = (x1 + x2) / 2\n    y12 = (y1 + y2) / 2\n    x23 = (x2 + x3) / 2\n    y23 = (y2 + y3) / 2\n    x31 = (x3 + x1) / 2\n    y31 = (y3 + y1) / 2\n    setxy(x12, y12)\n    setxy(x23, y23)\n    setxy(x31, y31)\n    colour(white)\n    polygon(3)\n    triangle(x1, y1, x12, y12, x31, y31)\n    triangle(x2, y2, x23, y23, x12, y12)\n    triangle(x3, y3, x31, y31, x23, y23)\n\ndef main():\n  blank(cream)\n  thickness(1)\n  triangle(400, 138, 843, 650, 179, 778)\n"},function(e,n){e.exports="# SierpinskiColour\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# SierpinskiDots\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# SierpinskiIFS\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# SimpleDraw\n\ndef palette():\n  for col in range(1, 11, 1):\n    setxy(col * 100 - 50, 950)\n    colour(rgb(col))\n    blot(50)\n\ndef main():\n  global turtx, turty\n  palette()\n  home()\n  thickness(10)\n  blot(2)\n  while True:\n    while not((?lmouse > 0) or (?rmouse > 0)):\n      update()\n    if ?mousey > 900:\n      colour(rgb(?mousex // 100 + 1))\n    else:\n      if ?lmouse > 0:\n        drawxy(?mousex - turtx, ?mousey - turty)\n      else:\n        setxy(?mousex, ?mousey)\n"},function(e,n){e.exports="# SimpleProcedure\n\ndef prong():\n  forward(400)\n  blot(20)\n  back(400)\n\ndef main():\n  global turtd\n  randcol(10)\n  prong()\n  right(61)\n  while turtd != 0:\n    randcol(10)\n    prong()\n    right(61)\n"},function(e,n){e.exports="# SnakeGame\n\ndef newapple():\n  global applecolour,snakecolour,boardsize\n  x=randint(0,boardsize-1)\n  y=randint(0,boardsize-1)\n  while pixcol(x,y)==snakecolour:\n    x=randint(0,boardsize-1)\n    y=randint(0,boardsize-1)\n  pixset(x,y,applecolour)\n\ndef main():\n  global turtx,turty,turtd\n  global applecolour,snakecolour,boardsize\n  boardsize=30\n  canvas(0,0,boardsize,boardsize)\n  resolution(boardsize,boardsize)\n  angles(4)\n  snakecolour=purple\n  applecolour=green\n  blank(lightblue)\n  cursor(0)\n  colour(snakecolour)\n  thickness(1)\n  penup()\n  forward(1)\n  snakelength=2\n  newapple()\n  crash=False\n  while not crash:\n    noupdate()\n    if (abs(?key)==\\\\up) and (turtd!=2):\n      direction(0)\n    if (abs(?key)==\\\\right) and (turtd!=3):\n      direction(1)\n    if (abs(?key)==\\\\down) and (turtd!=0):\n      direction(2)\n    if (abs(?key)==\\\\left) and (turtd!=1):\n      direction(3)\n    forward(1)\n    if (turtx<0) or (turtx>=boardsize) or (turty<0) or (turty>=boardsize):\n      crash=True\n    if pixcol(turtx,turty)==snakecolour:\n      crash=True\n    if pixcol(turtx,turty)==applecolour:\n      inc(snakelength)\n      pixset(turtx,turty,snakecolour)\n      newapple()\n    colour(lightblue)\n    polyline(snakelength+2)\n    colour(snakecolour)\n    polyline(snakelength)\n    update()\n    pause(250-(snakelength*3))\n  resolution(1000,1000)\n  blank(lilac)\n  setxy(boardsize//4,2*boardsize//5)\n  print('Score '+str(snakelength-2),20,100)\n"},function(e,n){e.exports="# SolarSystem\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# Stars\n\ndef star(points, col):\n  angles(points * 2)\n  for count in range(0, points, 1):\n    forward(450)\n    back(450)\n    forget(1)\n    right(1)\n    forward(200)\n    back(200)\n    forget(1)\n    right(1)\n  colour(col)\n  polygon(points * 2)\n\ndef main():\n  penup()\n  for n in range(3, 13, 1):\n    star(n, rgb(n - 2))\n    pause(500)\n"},function(e,n){e.exports="# StringFunctions\n\ndef main():\n  output(-1, cream, -1)\n  delay = 500\n  s1 = 'Turtle Python'\n  s2 = copy(s1, 1, 6)\n  writeline(s2 + ' is the name of a small animal.')\n  pause(delay)\n  s3 = copy(s1, 8, 6)\n  writeline(s3 + ' is a large snake.')\n  pause(delay)\n  s4 = insert(s3, 2, 'onty M')\n  writeline('\\'' + s4 + '\\' is a silly name.')\n  pause(delay)\n  writeline('\"' + s1 + '\" has ' + str(len(s1)) + ' characters.')\n  pause(delay)\n  writeline('In lower case it is \"' + lower(s1) + '\".')\n  writeline('In upper case it is \"' + upper(s1) + '\".')\n  pause(delay)\n  posn = find(s1, s3)\n  if posn > 0:\n    writeline('\"' + s3 + '\" occurs within \"' + s1 + '\" at position ' + str(posn) + '.')\n  pause(delay)\n  s5 = '3.14159'\n  writeline(s5 + ' times 100000 = ' + str(qval(s5, 100000, -1)) + '.')\n  pause(delay)\n  n = qval(s5, 100000, -1)\n  writeline(str(n) + ' divided by 100000 = ' + qstr(n, 100000, 5) + '.')\n  writeline('')\n  pause(delay * 5)\n  writeline('Now back to the Canvas and Console ...')\n  output(0, peach, -1)\n  pause(delay * 5)\n  output(0, lightred, 0)\n  pause(delay * 5)\n  console(-1, lightblue)\n  writeline('You will see this on a clear light blue Console')\n"},function(e,n){e.exports="# ThePlough\n\ndef main():\n  blank(black)\n  colour(lightblue)\n  setxy(100, 200)\n  blot(10)\n  setxy(300, 250)\n  blot(10)\n  setxy(420, 350)\n  blot(10)\n  setxy(570, 490)\n  blot(10)\n  setxy(900, 560)\n  blot(10)\n  setxy(840, 720)\n  blot(10)\n  setxy(590, 660)\n  blot(10)\n  setxy(570, 490)\n  colour(silver)\n  polyline(8)\n"},function(e,n){e.exports="# TreeIFS\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# Triangles\n\ndef triangle(size):\n  if size >= 2:\n    forward(size)\n    triangle(size // 2)\n    right(120)\n    forward(size)\n    triangle(size // 2)\n    right(120)\n    forward(size)\n    triangle(size // 2)\n    right(120)\n\ndef main():\n  movexy(-100, 150)\n  triangle(256)\n"},function(e,n){e.exports="# TrigonometricGraphs\n\ndef axes():\n  global yscale, xorigin, yorigin, halfwidth\n  thickness(3)\n  setxy(xorigin - halfwidth, yorigin)\n  drawxy(halfwidth * 2, 0)\n  setxy(xorigin, 0)\n  drawxy(0, 1000)\n  setxy(xorigin, yorigin)\n  circle(15)\n  thickness(2)\n  setxy(xorigin - halfwidth, yorigin - yscale)\n  drawxy(halfwidth * 2, 0)\n  setxy(xorigin - halfwidth, yorigin + yscale)\n  drawxy(halfwidth * 2, 0)\n  setxy(xorigin + halfwidth + 10, yorigin - yscale - 18)\n  print('+1', 0, 20)\n  setxy(xorigin + halfwidth + 10, yorigin + yscale - 18)\n  print('-1', 0, 20)\n  setxy(xorigin - halfwidth - 60, yorigin)\n  print('-180', 0, 20)\n  setxy(xorigin - halfwidth / 2, yorigin)\n  print('-90', 0, 20)\n  setxy(xorigin + halfwidth / 2 - 30, yorigin)\n  print('90', 0, 20)\n  setxy(xorigin + halfwidth, yorigin)\n  print('180', 0, 20)\n\ndef sinecurve():\n  global yscale, xorigin, yorigin, halfwidth\n  for degrees in range(-180, 181, 1):\n    x = xorigin + divmult(degrees, 180, halfwidth)\n    y = yorigin - sin(degrees, 1, yscale)\n    setxy(x, y)\n  polyline(361)\n\ndef cosinecurve():\n  global yscale, xorigin, yorigin, halfwidth\n  for degrees in range(-180, 181, 1):\n    x = xorigin + divmult(degrees, 180, halfwidth)\n    y = yorigin - cos(degrees, 1, yscale)\n    setxy(x, y)\n  polyline(361)\n\ndef tancurve():\n  global yscale, xorigin, yorigin, halfwidth\n  for degrees in range(-180, 181, 1):\n    if degrees == -90:\n      polyline(90)\n    else:\n      if degrees == 90:\n        polyline(179)\n      else:\n        x = xorigin + divmult(degrees, 180, halfwidth)\n        y = yorigin - tan(degrees, 1, yscale)\n        setxy(x, y)\n  polyline(90)\n\ndef main():\n  global xorigin, yorigin, halfwidth, yscale\n  xorigin = 500\n  yorigin = 500\n  halfwidth = 400\n  yscale = 200\n  axes()\n  noupdate()\n  thickness(4)\n  colour(green)\n  setxy(20, 800)\n  print('sine', 16, 40)\n  sinecurve()\n  colour(red)\n  setxy(20, 860)\n  print('cosine', 16, 40)\n  cosinecurve()\n  colour(blue)\n  setxy(20, 920)\n  print('tangent', 16, 40)\n  tancurve()\n"},function(e,n){e.exports="# TurtleBounce\n\ndef main():\n  global turtx, turty\n  xvel = 3\n  yvel = -2\n  while (0 < 1):\n    colour(white)\n    blot(51)\n    movexy(xvel, yvel)\n    colour(red)\n    blot(50)\n    update()\n    noupdate()\n    if (turtx < 50) or (turtx > 950):\n      xvel = -xvel\n    if (turty < 50) or (turty > 950):\n      yvel = -yvel\n"},function(e,n){e.exports="# TurtleMove\n\ndef main():\n  setxy(100, 700)\n  for count in range(0, 100, 1):\n    noupdate()\n    colour(white)\n    blot(51)\n    movexy(8, -4)\n    colour(red)\n    blot(50)\n    update()\n    pause(5)\n"},function(e,n){e.exports="# TwoSlits\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# WaveSuperposer\n\n# this program is not available in Turtle Python\n# because lists have not yet been implemented\n"},function(e,n){e.exports="# YouAreHere\n\ndef main():\n  colour(red)\n  blot(20)\n  colour(violet)\n  print('You are here', 2, 36)\n  setxy(790, 540)\n  colour(blue)\n  drawxy(40, 0)\n  drawxy(28, -28)\n  drawxy(0, -40)\n  drawxy(-28, -28)\n  drawxy(-40, 0)\n  setxy(500, 500)\n  setxy(530, 480)\n  setxy(535, 505)\n  setxy(500, 500)\n  polyline(5)\n  polygon(3)\n"},function(e,n,t){const{tabs:o}=t(0),r=t(271),a=t(272),i=t(273),s=t(274),l=t(275),c=t(276),d=t(277),u=t(278),p=o("tsx-help-tabs",[{label:"Commands",active:!0,content:[i]},{label:"Basics",active:!1,content:[a]},{label:"Structures",active:!1,content:[d]},{label:"Operators",active:!1,content:[c]},{label:"User Input",active:!1,content:[l]},{label:"Constants",active:!1,content:[s]}]),h=o("tsx-help-tabs",[{label:"About",active:!0,content:[r]},{label:"Versions",active:!1,content:[u]}]);e.exports={language:p,system:h}},function(e,n,t){const{element:o}=t(0),r=o("div",{content:[o("h3",{content:"Turtle System X"}),o("p",{content:"This is a multi-platform version of the <i>Turtle System</i>. It is available for Windows, MacOS, and Linux, and can also be run directly in a web browser. It is written in JavaScript, and uses Node and Electron to create the downloadable desktop versions."}),o("p",{content:'The application is open source, and the source code can be viewed at <a href="https://github.com/oxfordturtle/turtlesystemx">https://github.com/oxfordturtle/turtlesystemx</a>.'}),o("p",{content:"This version is developed in tandem with the original version of the <i>Turtle System</i>, which is written in Delphi Pascal, and is available for download as a Windows desktop application. The original Delphi Pascal version is more powerful in some respects, and is faster at compiling and running very long or complicated programs. Windows users may therefore prefer to use that version."})]});e.exports=r},function(e,n,t){const{element:o}=t(0),r=o("div");e.exports=r;const{highlight:a}=t(4),i=t(1),s=[o("h3",{content:"Programs and Procedures: the Basics"}),o("p",{content:"The simplest BASIC programs take this form:"}),o("pre",{content:`<code>${a("REM myprog  [this is a comment]\nREM [program commands]\nEND","BASIC")}</code>`}),o("p",{content:`The first couple of Turtle example programs (from the Help menu) are like this. But the &lsquo;Olympic rings 2&rsquo; program introduces a global variable: it is called <code>${a("ringsize%","BASIC")}</code> and specifies the size of the rings. Such variables are &lsquo;declared&rsquo; by assigning a value, like this:`}),o("pre",{content:`<code>${a("ringsize% = 130\nREM [other program commands]\nEND","BASIC")}</code>`}),o("p",{content:"Complicated programs are usually divided into subroutines, to separate the various tasks and make them easier to understand. BASIC has two types of subroutine, procedures (which are like mini-programs) and functions (which are designed to calculate some value)."}),o("p",{content:`The &lsquo;Simple procedure&rsquo; example program has a procedure to draw a &lsquo;prong&rsquo; – a line ending in a blot – and then return to the starting point. Procedures fit into a BASIC program after the end of the main program, indicated by <code>${a("END","BASIC")}</code>. They look like this:`}),o("pre",{content:`<code>${a("DEF PROCmyprocedure(par1%)\n  LOCAL local1%, local2$\n  REM [procedure commands]\nENDPROC","BASIC")}</code>`}),o("p",{content:`All procedure names must begin with &lsquo;PROC&rsquo;, e.g. &lsquo;PROCmyprocedure&rsquo;. A procedure can have its own local variables, declared using <code>${a("LOCAL","BASIC")}</code>. A <code>${a("PRIVATE","BASIC")}</code> variable is declared the same way, but unlike a <code>${a("LOCAL","BASIC")}</code> variable, it retains its value between procedure calls. A procedure can also have parameters (or &lsquo;arguments&rsquo;) that are values sent into the subroutine when it is called from the program, and given a name within the subroutine (e.g. <code>${a("par1%","BASIC")}</code> above).`}),o("p",{content:"A function is similar to a procedure, with the addition that it returns a value. Also a function name must begin with &lsquo;FN&rsquo;, for example:"}),o("pre",{content:`<code>${a('DEF FNmyfunction(par1%)\n  REM [procedure commands]\n  = "output"',"BASIC")}</code>`}),o("p",{content:`The last statement of a function always begins with <code>${a("=","BASIC")}</code> and the <code>${a('"output"',"BASIC")}</code> provides the return value for the function.`}),o("h4",{content:"Reserved Words, Declarations, Types, and Variables"}),o("p",{content:`The words <code>${a("REM","BASIC")}</code>, <code>${a("END","BASIC")}</code>, <code>${a("DEF","BASIC")}</code>, etc. are all capitalized to emphasise the program structure. BASIC takes notice of capitalization. These three words are also in red here (or gray for comments) – this is to indicate that they are special &lsquo;reserved&rsquo; words that cannot be used for other purposes (so you can&rsquo;t call a procedure or variable &lsquo;END&rsquo;).`}),o("p",{content:"Variables all end with either a &lsquo;%&rsquo; or a &lsquo;$&rsquo; – Turtle will tell you if you forget! Turtle BASIC allows two types of variables:"}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:"<td>integer</td><td>whole number (name ends in &lsquo;%&rsquo;)</td>"}),o("tr",{content:"<td>string</td><td>sequence of characters (name ends in &lsquo;$&rsquo;)</td>"})]}),o("p",{content:`Most of your variables are likely to be integer variables, like a transparent box that stores a number. You can look at the box to see which number it contains at any time, and you can change the number by assigning a new value. In the &lsquo;Olympic rings 2&rsquo; example program, <code>${a("ringsize%","BASIC")}</code> is declared by assigning the value <code>${a("130","BASIC")}</code> using the command:`}),o("pre",{content:`<code>${a("ringsize% = 130","BASIC")}</code>`}),o("p",{content:"Five special integer variables are &lsquo;built in&rsquo; from the start, and these are called the Turtle&rsquo;s fields:"}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:`<td><code>${a("TURTX%","BASIC")}</code></td><td>The Turtle&rsquo;s x-coordinate</td>`}),o("tr",{content:`<td><code>${a("TURTY%","BASIC")}</code></td><td>The Turtle&rsquo;s y-coordinate</td>`}),o("tr",{content:`<td><code>${a("TURTD%","BASIC")}</code></td><td>The Turtle&rsquo;s direction</td>`}),o("tr",{content:`<td><code>${a("TURTT%","BASIC")}</code></td><td>The Turtle&rsquo;s pen thickness</td>`}),o("tr",{content:`<td><code>${a("TURTC%","BASIC")}</code></td><td>The Turtle&rsquo;s colour setting</td>`})]}),o("p",{content:"These automatically change to keep track of the Turtle&rsquo;s state, and are shown above the Canvas."}),o("p",{content:`For a use of <code>${a("TURTD%","BASIC")}</code>, see the &lsquo;Simple procedure&rsquo; example.`})],l=[o("h3",{content:"Programs and Procedures: the Basics"}),o("p",{content:"The simplest Pascal programs take this form:"}),o("pre",{content:`<code>${a("PROGRAM myprog;\nBEGIN\n  {program commands}\nEND.","Pascal")}</code>`}),o("p",{content:`The first couple of Turtle example programs (from the Help menu) are like this. But the &lsquo;Olympic rings 2&rsquo; program introduces a global variable: it is called <code>${a("ringsize","Pascal")}</code> and specifies the size of the rings. Such variables are &lsquo;declared&rsquo; at the beginning of the program, like this:`}),o("pre",{content:`<code>${a("PROGRAM myprog;\nVAR global1: integer;\n    global2, global3: integer;\nBEGIN\n  {program commands}\nEND.","Pascal")}</code>`}),o("p",{content:`Complicated programs are usually divided into subroutines, to separate the various tasks and make them easier to understand. Pascal has two types of subroutine, procedures (which are like mini-programs) and functions (which are designed to calculate some value). The &lsquo;Simple procedure&rsquo; example program has a procedure to draw a &lsquo;prong&rsquo; – a line ending in a blot – and then return to the starting point. Procedures fit into a Pascal program after the global variables and before the <code>${a("BEGIN","Pascal")}</code> of the main program; they look like this:`}),o("pre",{content:`<code>${a("Procedure myprocedure(par1: integer);\nVar local1, local2: integer;\nBegin\n  {procedure commands}\nEnd;","Pascal")}</code>`}),o("p",{content:`A procedure can have its own local variables, declared much like global variables. But it can also have parameters (or &lsquo;arguments&rsquo;) that are values sent into the subroutine when it is called from the program, and given a name within the subroutine (e.g. <code>${a("par1","Pascal")}</code> above).`}),o("h4",{content:"Reserved Words, Declarations, Types, and Variables"}),o("p",{content:`The words <code>${a("PROGRAM","Pascal")}</code>, <code>${a("BEGIN","Pascal")}</code> and <code>${a("END","Pascal")}</code> are often capitalized to emphasise the program structure, but Pascal actually takes no notice of capitalization (so you could write <code>${a("program","Pascal")}</code>, <code>${a("Program","Pascal")}</code> or even <code>${a("PrOgRaM","Pascal")}</code>!). These three words are also in red here – this is to indicate that they are special &lsquo;reserved&rsquo; words that cannot be used for other purposes (so you can&rsquo;t call a procedure or variable &lsquo;begin&rsquo;). As well as variables, a program can use constants to give a convenient name to a particular value. Any constants must be &lsquo;declared&rsquo; even before the variables, like this:`}),o("pre",{content:`<code>${a("PROGRAM myprog;\nCONST limit = 4;\nVAR global1: integer;\n{and so on}","Pascal")}</code>`}),o("p",{content:`Notice that variable and constant declarations must all end with a semicolon – Turtle will tell you if you forget! Notice also that while constants are given a value when declared (e.g. <code>${a("limit","Pascal")}</code> is given the value <code>${a("4","Pascal")}</code> above), variables are given a <em>type</em>, to indicate the sort of data that they can store. Turtle Pascal allows four main types of variables:`}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:"<td>integer</td><td>whole number</td>"}),o("tr",{content:"<td>boolean</td><td>true or false</td>"}),o("tr",{content:"<td>char</td><td>single character</td>"}),o("tr",{content:"<td>string</td><td>sequence of character(s)</td>"})]}),o("p",{content:"Most of your variables are likely to be integer variables, like a transparent box that stores a number. You can look at the box to see which number it contains at any time, and you can change the number by assigning a new value, e.g."}),o("pre",{content:`<code>${a("VAR ringsize: integer;","Pascal")}</code>`}),o("p",{content:`is declared in the &lsquo;Olympic rings 2&rsquo; example program, and <code>${a("ringsize","Pascal")}</code> is later assigned the value <code>${a("130","Pascal")}</code> using the command:`}),o("pre",{content:`<code>${a("ringsize := 130;","Pascal")}</code>`}),o("p",{content:"Five special integer variables are &lsquo;built in&rsquo; from the start, and these are called the Turtle&rsquo;s fields:"}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:`<td><code>${a("turtx","Pascal")}</code></td><td>The Turtle’s x-coordinate</td>`}),o("tr",{content:`<td><code>${a("turty","Pascal")}</code></td><td>The Turtle’s y-coordinate</td>`}),o("tr",{content:`<td><code>${a("turtd","Pascal")}</code></td><td>The Turtle’s direction</td>`}),o("tr",{content:`<td><code>${a("turtt","Pascal")}</code></td><td>The Turtle’s pen thickness</td>`}),o("tr",{content:`<td><code>${a("turtc","Pascal")}</code></td><td>The Turtle’s colour setting</td>`})]}),o("p",{content:"These automatically change to keep track of the Turtle&rsquo;s state, and are shown above the Canvas."}),o("p",{content:`For a use of <code>${a("turtd","Pascal")}</code>, see the &lsquo;Simple procedure&rsquo; example.`})],c=[o("h3",{content:"Programs and Procedures: the Basics"}),o("p",{content:"The simplest Python programs take this form:"}),o("pre",{content:`<code>${a("# myprog  [this is a comment]\ndef main():\n  # program commands","Python")}</code>`}),o("p",{content:`The first couple of Turtle example programs (from the Help menu) are like this. But the &lsquo;Olympic rings 2&rsquo; program introduces a variable: it is called <code>${a("ringsize","Python")}</code> and specifies the size of the rings. Such variables are &lsquo;declared&rsquo; by assigning a value, like this:`}),o("pre",{content:`<code>${a("ringsize = 130\n# other program commands","Python")}</code>`}),o("p",{content:`Complicated programs are usually divided into functions, to separate the various tasks and make them easier to understand. The &lsquo;Simple procedure&rsquo; example program has a function to draw a &lsquo;prong&rsquo; – a line ending in a blot – and then return to the starting point. Functions fit into a Python program before the <code>${a("main()","Python")}</code> function and may be nested; they look like this:`}),o("pre",{content:`<code>${a("def outsidefunction(par1):\n  global global1, global2        # optional\n  nonlocal nonlocal1, nonlocal2  # optional\n\n  def insidefunction():\n    # insidefunction&rsquo;s commands\n\n  # outsidefunction&rsquo;s commands","Python")}`}),o("p",{content:`Nested functions must occur after any <code>${a("global","Python")}</code> or <code>${a("nonlocal","Python")}</code> declarations and before the function&rsquo;s commands. Functions may return a value like this:`}),o("pre",{content:`<code>${a("def fname(par1):\n  # function commands\n  return somevalue","Python")}</code>`}),o("p",{content:"If there is no return statement then the function behaves like a procedure in Pascal or BASIC."}),o("p",{content:`A function can also have parameters (or &lsquo;arguments&rsquo;) that are values sent into the subroutine when it is called from the program, and given a name within the subroutine (e.g. <code>${a("par1","Python")}</code> above).`}),o("h4",{content:"Reserved Words, Declarations, Types, and Variables"}),o("p",{content:`The words <code>${a("def","Python")}</code>, <code>${a("return","Python")}</code>, <code>${a("global","Python")}</code>, etc. must all be in lower case; Python takes notice of capitalisation! These three words are also in red here – this is to indicate that they are special &lsquo;reserved&rsquo; words that cannot be used for other purposes (so you can&rsquo;t call a procedure or variable &lsquo;return&rsquo;). Variables are of two types, depending on the sort of data that they can store. Turtle Python allows two main types of variables:`}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:"<td>integer</td><td>whole number</td>"}),o("tr",{content:"<td>string</td><td>sequence of character(s)</td>"})]}),o("p",{content:`Most of your variables are likely to be integer variables, like a transparent box that stores a number. You can look at the box to see which number it contains at any time, and you can change the number by assigning a new value. In the &lsquo;Olympic rings 2&rsquo; example program, <code>${a("ringsize","Python")}</code> is declared by assigning the value <span>${a("130","Python")}</span> using the command:`}),o("pre",{content:`<code>${a("ringsize = 130","Python")}</code>`}),o("p",{content:`Note that sometimes Python cannot automatically determine what type a variable is meant to be. If this occurs an error message will be generated. To solve these cases the type of the variable can be forced into an integer by adding zero, e.g. <code>${a("varname + 0","Python")}</code>, or forced into a string by adding the null string, e.g. <code>${a("varname + ''","Python")}</code>.`}),o("p",{content:"Five special global integer variables are &lsquo;built in&rsquo; from the start, and these are called the Turtle&rsquo;s fields:"}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:`<td><code>${a("turtx","Python")}</code></td><td>The Turtle&rsquo;s x-coordinate</td>`}),o("tr",{content:`<td><code>${a("turty","Python")}</code></td><td>The Turtle&rsquo;s y-coordinate</td>`}),o("tr",{content:`<td><code>${a("turtd","Python")}</code></td><td>The Turtle&rsquo;s direction</td>`}),o("tr",{content:`<td><code>${a("turtt","Python")}</code></td><td>The Turtle&rsquo;s pen thickness</td>`}),o("tr",{content:`<td><code>${a("turtc","Python")}</code></td><td>The Turtle&rsquo;s colour setting</td>`})]}),o("p",{content:"These automatically change to keep track of the Turtle&rsquo;s state, and are shown above the Canvas."}),o("p",{content:`For a use of <code>${a("turtd","Python")}</code>, see the &lsquo;Simple procedure&rsquo; example.`})];i.on("language-changed",e=>{const n={BASIC:s,Pascal:l,Python:c};r.innerHTML="",n[e].forEach(e=>r.appendChild(e))})},function(e,n,t){const{element:o}=t(0),r=o("div",{content:"commands"});e.exports=r},function(e,n,t){const{element:o}=t(0),r=o("div",{content:"constants"});e.exports=r},function(e,n,t){const{element:o}=t(0),r=o("div");e.exports=r;const{highlight:a}=t(4),i=t(1),s=[o("h3",{content:"User Input"}),o("p",{content:"The facilities for user input – via keyboard or mouse – are designed to be as straightforward and comprehensible as possible, while operating strictly through simple processes that are consistent with the workings of the <em>Turtle Machine</em>."}),o("h4",{content:"Mouse Position Detection"}),o("p",{content:`The x- and y-coordinates of the mouse&rsquo;s current position can be found at any time by using the special global variables <code>${a("?MOUSEX","BASIC")}</code> and <code>${a("?MOUSEY","BASIC")}</code> – these do not require the mouse to be clicked.`}),o("h4",{content:"Mouse Click Detection"}),o("p",{content:`When a mouse click is performed, the x- and y-coordinates of the click position are remembered by the variables <code>${a("?CLICKX","BASIC")}</code> and <code>${a("?CLICKY","BASIC")}</code>. However to identify the type of click, use the variable <code>${a("?CLICK","BASIC")}</code>, which is initially set to a value of -1, but after any click has taken place is set to a numerical value of 128 plus additions as follows:`}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:"<td>1</td><td>if the click was with the left mouse button</td>"}),o("tr",{content:"<td>2</td><td>if the click was with the right mouse button</td>"}),o("tr",{content:"<td>4</td><td>if the click was with the middle mouse button</td>"}),o("tr",{content:"<td>8</td><td>if the <kbd>shift</kbd> key was held down while clicking</td>"}),o("tr",{content:"<td>16</td><td>if the <kbd>alt</kbd> key was held down while clicking</td>"}),o("tr",{content:"<td>32</td><td>if the <kbd>ctrl</kbd> key was held down while clicking</td>"}),o("tr",{content:"<td>64</td><td>if it was a double-click</td>"})]}),o("p",{content:`So if <code>${a("n% = ?CLICK","BASIC")}</code> makes <code>${a("n%","BASIC")}</code> equal to 137 (128+8+1), this indicates that a left-click is currently under way, with the <kbd>shift</kbd> key held down. When the click event is finished, the <code>${a("?CLICK","BASIC")}</code> value will become negative. Thus if <code>${a("?CLICK","BASIC")}</code> returns a value of -137, this indicates that the last click event – now finished – was <kbd>shift</kbd>+left; the coordinate position of that click can still be identified – until the next click takes place – as (<code>${a("?CLICKX","BASIC")}</code>, <code>${a("?CLICKY","BASIC")}</code>). On a left-click, the variable <code>${a("?LMOUSE","BASIC")}</code> records the relevant value (as calculated above); likewise <code>${a("?RMOUSE","BASIC")}</code> and <code>${a("?MMOUSE","BASIC")}</code> record any right-click or middle-click. Again, these are all made negative when the click is released, so an empty loop like:`}),o("pre",{content:`<code>${a("REPEAT\nUNTIL ?LMOUSE > 0","BASIC")}</code>`}),o("p",{content:`waits for a left-click with the mouse. Afterwards, <code>${a("?CLICKX","BASIC")}</code> and <code>${a("?CLICKY","BASIC")}</code> indicate where that click event occurred, and <code>${a("?CLICK","BASIC")}</code> can be queried using the bitwise <code>${a("AND","BASIC")}</code> operator to discover which special keys were pressed (e.g. <code>${a("IF (ABS(?CLICK) AND 8) > 0","BASIC")}</code> will test whether <kbd>shift</kbd> was being held down).`}),o("h4",{content:"Key Press Detection"}),o("p",{content:`Detecting key presses (rather than typing in of characters) uses the variables <code>${a("?KEY","BASIC")}</code> and <code>${a("?KSHIFT","BASIC")}</code>, and the function <code>${a("KEYSTATUS","BASIC")}</code>. <code>${a("?KEY","BASIC")}</code> gives the code of the last key to be pressed – these codes can be tested using the special keycode constants <code>${a("\\ALT","BASIC")}</code>, <code>${a("\\BACKSPACE","BASIC")}</code>, <code>${a("\\CAPSLOCK","BASIC")}</code>, <code>${a("\\CTRL","BASIC")}</code>, <code>${a("\\DELETE","BASIC")}</code>, <code>${a("\\DOWN","BASIC")}</code>, <code>${a("\\END","BASIC")}</code>, <code>${a("\\ESCAPE","BASIC")}</code>, <code>${a("\\HOME","BASIC")}</code>, <code>${a("\\INSERT","BASIC")}</code>, <code>${a("\\LEFT","BASIC")}</code>, <code>${a("\\LWIN","BASIC")}</code>, <code>${a("\\PGDN","BASIC")}</code>, <code>${a("\\PGUP","BASIC")}</code>, <code>${a("\\RETURN","BASIC")}</code>, <code>${a("\\RIGHT","BASIC")}</code>, <code>${a("\\RWIN","BASIC")}</code>, <code>${a("\\SHIFT","BASIC")}</code>, <code>${a("\\SPACE","BASIC")}</code>, <code>${a("\\TAB","BASIC")}</code>, and <code>${a("\\UP","BASIC")}</code>, as well as <code>${a("\\A","BASIC")}</code> to <code>${a("\\Z","BASIC")}</code>, <code>${a("\\0","BASIC")}</code> to <code>${a("\\9","BASIC")}</code>, <code>${a("\\HASH","BASIC")}</code>, <code>${a("\\EQUALS","BASIC")}</code> etc. Keys on the numeric keypad have codes <code>${a("\\#0","BASIC")}</code>, <code>${a("\\#1","BASIC")}</code> etc., and function keys <code>${a("\\F1","BASIC")}</code>, <code>${a("\\F2","BASIC")}</code> etc. All these stand for numeric values (e.g. <code>${a("\\RETURN","BASIC")}</code> is 13, <code>${a("\\ESCAPE","BASIC")}</code> is 27), but <code>${a("IF ?KEY = \\RETURN","BASIC")}</code> is easier to understand than <code>${a("IF ?KEY = 13","BASIC")}</code>.`}),o("p",{content:`Like the mouse-click variables, <code>${a("?KEY","BASIC")}</code> becomes negative after the key is released, so <code>${a("REPEAT : UNTIL ?KEY = -\\A","BASIC")}</code> will wait until the &lsquo;A&rsquo; key has been released. If you want to identify the last key whether it is still pressed or not, use <code>${a("ABS","BASIC")}</code> (e.g. <code>${a("IF ABS(?KEY) = \\A THEN","BASIC")}</code>).`}),o("p",{content:`Whenever a key is pressed, the variable <code>${a("?KSHIFT","BASIC")}</code> gives its &lsquo;shift-status&rsquo;, calculated in the same way as <code>${a("?CLICK","BASIC")}</code> (i.e. 128 plus 8 if <kbd>shift</kbd> was down, 16 for <kbd>alt</kbd>, 32 for <kbd>ctrl</kbd>, and turning negative after the key is released). So to test if <kbd>ctrl</kbd> was down on the last keypress, use <code>${a("IF (ABS(?KSHIFT) AND 32) > 0","BASIC")}</code>, with <code>${a("AND","BASIC")}</code> here acting as a bitwise boolean operator.`}),o("p",{content:`To recover the shift-status for the last press of the <kbd>X</kbd> key (say), use <code>${a("KEYSTATUS(\\X)","BASIC")}</code>, which can tell you (a) whether <kbd>shift</kbd> / <kbd>alt</kbd> / <kbd>ctrl</kbd> were down; (b) whether the <kbd>X</kbd> is still pressed (since <code>${a("KEYSTATUS","BASIC")}</code> goes negative on release); (c) whether <kbd>X</kbd> has been pressed at all (since all of these input codes are set to -1 initially, and can be reset to -1 using <code>${a("RESET(\\X)","BASIC")}</code> etc.).`}),o("h4",{content:"Keyboard Input"}),o("p",{content:`The system provides a <em>keyboard buffer</em> to store typed characters. Initially this is set to store up to 32 characters, but can be extended using e.g. <code>${a("KEYBUFFER(50)","BASIC")}</code>. To read from the buffer into a string, use e.g. <code>${a("s$ = GET$(10)","BASIC")}</code>, which reads up to 10 characters (depending on how many are in the buffer). <code>${a("KEYSTATUS(\\KEYBUFFER)","BASIC")}</code> returns the number of characters it contains, and <code>${a("RESET(\\KEYBUFFER)","BASIC")}</code> flushes it.`}),o("p",{content:`<code>${a("s$ = GETLINE$","BASIC")}</code> reads a line of text, waiting until the <kbd>return</kbd> key is pressed and then making <code>${a("s$","BASIC")}</code> equal to what has been typed into the buffer (discarding the <kbd>return</kbd> character).`}),o("p",{content:`The function <code>${a("DETECT","BASIC")}</code> waits a given time for some input to be received (e.g. a specific key pressed), and returns <code>${a("TRUE","BASIC")}</code> when that input is received, or <code>${a("FALSE","BASIC")}</code> if it is not received in time. Thus <code>${a("IF DETECT(\\ESCAPE, 5000) THEN - ELSE -","BASIC")}</code> gives 5 seconds to press the <kbd>escape</kbd> key (meanwhile continuing to collect any typed characters in the keyboard buffer). By default, text that goes into the keyboard buffer is also &lsquo;echoed&rsquo; to the console (below the Canvas), along with text that is output (using <code>${a("WRITE","BASIC")}</code> or <code>${a("WRITELN","BASIC")}</code>). This behaviour can be turned on and off with <code>${a("KEYECHO(TRUE)","BASIC")}</code> and <code>${a("KEYECHO(FALSE)","BASIC")}</code>.`})],l=[o("h3",{content:"User Input"}),o("p",{content:"The facilities for user input – via keyboard or mouse – are designed to be as straightforward and comprehensible as possible, while operating strictly through simple processes that are consistent with the workings of the <em>Turtle Machine</em>."}),o("h4",{content:"Mouse Position Detection"}),o("p",{content:`The x- and y-coordinates of the mouse&rsquo;s current position can be found at any time by using the special global variables <code>${a("?mousex","Pascal")}</code> and <code>${a("?mousey","Pascal")}</code> – these do not require the mouse to be clicked.`}),o("h4",{content:"Mouse Click Detection"}),o("p",{content:`When a mouse click is performed, the x- and y-coordinates of the click position are remembered by the variables <code>${a("?clickx","Pascal")}</code> and <code>${a("?clicky","Pascal")}</code>. However to identify the type of click, use the variable <code>${a("?click","Pascal")}</code>, which is initially set to a value of -1, but after any click has taken place is set to a numerical value of 128 plus additions as follows:`}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:"<td>1</td><td>if the click was with the left mouse button</td>"}),o("tr",{content:"<td>2</td><td>if the click was with the right mouse button</td>"}),o("tr",{content:"<td>4</td><td>if the click was with the middle mouse button</td>"}),o("tr",{content:"<td>8</td><td>if the shift key was held down while clicking</td>"}),o("tr",{content:"<td>16</td><td>if the alt key was held down while clicking</td>"}),o("tr",{content:"<td>32</td><td>if the ctrl key was held down while clicking</td>"}),o("tr",{content:"<td>64</td><td>if it was a double-click</td>"})]}),o("p",{content:`So if <code>${a("n := ?click","Pascal")}</code> makes <code>${a("n","Pascal")}</code> equal to 137 (128 + 8 + 1), this indicates that a left-click is currently under way, with the <kbd>shift</kbd> key held down. When the click event is finished, the <code>${a("?click","Pascal")}</code> value will become negative. Thus if <code>${a("?click","Pascal")}</code> returns a value of -137, this indicates that the last click event – now finished – was shift+left; the coordinate position of that click can still be identified – until the next click takes place – as (<code>${a("?clickx","Pascal")}</code>, <code>${a("?clicky","Pascal")}</code>). On a left-click, the variable <code>${a("?lmouse","Pascal")}</code> records the relevant value (as calculated above); likewise <code>${a("?rmouse","Pascal")}</code> and <code>${a("?mmouse","Pascal")}</code> record any right-click or middle-click. Again, these are all made negative when the click is released, so an empty loop like:`}),o("pre",{content:`<code>${a("repeat\nuntil ?lmouse > 0;","Pascal")}</code>`}),o("p",{content:`waits for a left-click with the mouse. Afterwards, <code>${a("?clickx","Pascal")}</code> and <code>${a("?clicky","Pascal")}</code> indicate where that click event occurred, and <code>${a("?click","Pascal")}</code> can be queried using the bitwise <code>${a("and","Pascal")}</code> operator to discover which special keys were pressed (e.g. <code>${a("if (abs(?click) and 8) > 0","Pascal")}</code> will test whether <kbd>shift</kbd> was being held down).`}),o("h4",{content:"Key Press Detection"}),o("p",{content:`Detecting key presses (rather than typing in of characters) uses the variables <code>${a("?key","Pascal")}</code> and <code>${a("?kshift","Pascal")}</code>, and the function <code>${a("keystatus","Pascal")}</code>. <code>${a("?key","Pascal")}</code> gives the code of the last key to be pressed – these codes can be tested using the special keycode constants <code>${a("\\alt","Pascal")}</code>, <code>${a("\\backspace","Pascal")}</code>, <code>${a("\\capslock","Pascal")}</code>, <code>${a("\\ctrl","Pascal")}</code>, <code>${a("\\delete","Pascal")}</code>, <code>${a("\\down","Pascal")}</code>, <code>${a("\\end","Pascal")}</code>, <code>${a("\\escape","Pascal")}</code>, <code>${a("\\home","Pascal")}</code>, <code>${a("\\insert","Pascal")}</code>, <code>${a("\\left","Pascal")}</code>, <code>${a("\\lwin","Pascal")}</code>, <code>${a("\\pgdn","Pascal")}</code>, <code>${a("\\pgup","Pascal")}</code>, <code>${a("\\return","Pascal")}</code>, <code>${a("\\right","Pascal")}</code>, <code>${a("\\rwin","Pascal")}</code>, <code>${a("\\shift","Pascal")}</code>, <code>${a("\\space","Pascal")}</code>, <code>${a("\\tab","Pascal")}</code>, and <code>${a("\\up","Pascal")}</code>, as well as <code>${a("\\a","Pascal")}</code> to <code>${a("\\z","Pascal")}</code>, <code>${a("\\0","Pascal")}</code> to <code>${a("\\9","Pascal")}</code>, <code>${a("\\hash","Pascal")}</code>, <code>${a("\\equals","Pascal")}</code> etc. Keys on the numeric keypad have codes <code>${a("\\#0","Pascal")}</code>, <code>${a("\\#1","Pascal")}</code> etc., and function keys <code>${a("\\f1","Pascal")}</code>, <code>${a("\\f2","Pascal")}</code> etc. All these stand for numeric values (e.g. <code>${a("\\return","Pascal")}</code> is 13, <code>${a("\\escape","Pascal")}</code> is 27), but <code>${a("if ?key = \return","Pascal")}</code> is easier to understand than <code>${a("if ?key = 13","Pascal")}</code>.`}),o("p",{content:`Like the mouse-click functions, <code>${a("?key","Pascal")}</code> becomes negative after the key is released, so <code>${a("repeat until ?key = -\\a","Pascal")}</code> will wait until the <kbd>A</kbd> key has been released. If you want to identify the last key whether it is still pressed or not, use <code>${a("abs","Pascal")}</code> (e.g. <code>${a("if abs(?key) = \\a then {commands}","Pascal")}</code>).`}),o("p",{content:`Whenever a key is pressed, the variable <code>${a("?kshift","Pascal")}</code> gives its &lsquo;shift-status&rsquo;, calculated in the same way as <code>${a("?click","Pascal")}</code> (i.e. 128 plus 8 if <kbd>shift</kbd> was down, 16 for <kbd>alt</kbd>, 32 for <kbd>ctrl</kbd>, and turning negative after the key is released). So to test if <kbd>ctrl</kbd> was down on the last keypress, use <code>${a("if (abs(?kshift) and 32) > 0","Pascal")}</code>, with <code>${a("and","Pascal")}</code> here acting as a bitwise boolean operator.`}),o("p",{content:`To recover the shift-status for the last press of the <kbd>X</kbd> key (say), use <code>${a("keystatus(\\x)","Pascal")}</code>, which can tell you (a) whether <kbd>shift</kbd> / <kbd>alt</kbd> / <kbd>ctrl</kbd> were down; (b) whether the <kbd>X</kbd> is still pressed (since <code>${a("keystatus","Pascal")}</code> goes negative on release); (c) whether <kbd>X</kbd> has been pressed at all (since all of these input codes are set to -1 initially, and can be reset to -1 using <code>${a("reset(\\x)","Pascal")}</code> etc.).`}),o("h4",{content:"Keyboard Input"}),o("p",{content:`The system provides a <em>keyboard buffer</em> to store typed characters. Initially this is set to store up to 32 characters, but can be extended using e.g. <code>${a("keybuffer(50)","Pascal")}</code>. To read from the buffer into a string, use e.g. <code>${a("s := read(10)","Pascal")}</code>, which reads up to 10 characters (depending on how many are in the buffer). <code>${a("keystatus(\\keybuffer)","Pascal")}</code> returns the number of characters it contains, and <code>${a("reset(\\keybuffer)","Pascal")}</code> flushes it.`}),o("p",{content:`<code>${a("s := readln","Pascal")}</code> reads a line of text, waiting until the <kbd>return</kbd> key is pressed and then making <code>${a("s","Pascal")}</code> equal to what has been typed into the buffer (discarding the <kbd>return</kbd> character).`}),o("p",{content:`The function <code>${a("detect","Pascal")}</code> waits a given time for some input to be received (e.g. a specific key pressed), and returns <code>${a("true","Pascal")}</code> when that input is received, or <code>${a("false","Pascal")}</code> if it is not received in time. Thus <code>${a("if detect(\\escape, 5000) then {command1} else {command2}","Pascal")}</code> gives 5 seconds to press the <kbd>escape</kbd> key (meanwhile continuing to collect any typed characters in the keyboard buffer). By default, text that goes into the keyboard buffer is also &lsquo;echoed&rsquo; to the console (below the Canvas), along with text that is output (using <code>${a("write","Pascal")}</code> or <code>${a("writeln","Pascal")}</code>). This behaviour can be turned on and off with <code>${a("keyecho(true)","Pascal")}</code> and <code>${a("keyecho(false)","Pascal")}</code>.`})],c=[o("h3",{content:"User Input"}),o("p",{content:"The facilities for user input – via keyboard or mouse – are designed to be as straightforward and comprehensible as possible, while operating strictly through simple processes that are consistent with the workings of the <em>Turtle Machine</em>."}),o("h4",{content:"Mouse Position Detection"}),o("p",{content:`The x- and y-coordinates of the mouse&rsquo;s current position can be found at any time by using the special global variables <code>${a("?mousex","Python")}</code> and <code>${a("?mousey","Python")}</code> – these do not require the mouse to be clicked.`}),o("h4",{content:"Mouse Click Detection"}),o("p",{content:`When a mouse click is performed, the x- and y-coordinates of the click position are remembered by the variables <code>${a("?clickx","Python")}</code> and <code>${a("?clicky","Python")}</code>. However to identify the type of click, use the variable <code>${a("?click","Python")}</code>, which is initially set to a value of -1, but after any click has taken place is set to a numerical value of 128 plus additions as follows:`}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:"<td>1</td><td>if the click was with the left mouse button</td>"}),o("tr",{content:"<td>2</td><td>if the click was with the right mouse button</td>"}),o("tr",{content:"<td>4</td><td>if the click was with the middle mouse button</td>"}),o("tr",{content:"<td>8</td><td>if the shift key was held down while clicking</td>"}),o("tr",{content:"<td>16</td><td>if the alt key was held down while clicking</td>"}),o("tr",{content:"<td>32</td><td>if the ctrl key was held down while clicking</td>"}),o("tr",{content:"<td>64</td><td>if it was a double-click</td>"})]}),o("p",{content:`So if <code>${a("n = ?click","Python")}</code> makes <code>${a("n","Python")}</code> equal to 137 (128 + 8 + 1), this indicates that a left-click is currently under way, with the <kbd>shift</kbd> key held down. When the click event is finished, the <code>${a("?click","Python")}</code> variable will become negative. Thus if <code>${a("?click","Python")}</code> returns a value of -137, this indicates that the last click event – now finished – was shift+left; the coordinate position of that click can still be identified – until the next click takes place – as (<code>${a("?clickx","Python")}</code>, <code>${a("?clicky","Python")}</code>). On a left-click, the variable <code>${a("?lmouse","Python")}</code> records the relevant value (as calculated above); likewise <code>${a("?rmouse","Python")}</code> and <code>${a("?mmouse","Python")}</code> record any right-click or middle-click. Again, these are all made negative when the click is released, so an empty loop like:`}),o("pre",{content:`<code>${a("while not(?lmouse > 0):\n  pass  # this statement does nothing!","Python")}</code>`}),o("p",{content:`waits for a left-click with the mouse. Afterwards, <code>${a("?clickx","Python")}</code> and <code>${a("?clicky","Python")}</code> indicate where that click event occurred, and <code>${a("?click","Python")}</code> can be queried using the bitwise <code>${a("and","Python")}</code> operator to discover which special keys were pressed (e.g. <code>${a("if (abs(?click) and 8) > 0","Python")}</code> will test whether <kbd>shift</kbd> was being held down).`}),o("h4",{content:"Key Press Detection"}),o("p",{content:`Detecting key presses (rather than typing in of characters) uses the variables <code>${a("?key","Python")}</code> and <code>${a("?kshift","Python")}</code>, and the function <code>${a("keystatus","Python")}</code>. <code>${a("?key","Python")}</code> gives the code of the last key to be pressed – these codes can be tested using the special keycode constants <code>${a("\\alt","Python")}</code>, <code>${a("\\backspace","Python")}</code>, <code>${a("\\capslock","Python")}</code>, <code>${a("\\ctrl","Python")}</code>, <code>${a("\\delete","Python")}</code>, <code>${a("\\down","Python")}</code>, <code>${a("\\end","Python")}</code>, <code>${a("\\escape","Python")}</code>, <code>${a("\\home","Python")}</code>, <code>${a("\\insert","Python")}</code>, <code>${a("\\left","Python")}</code>, <code>${a("\\lwin","Python")}</code>, <code>${a("\\pgdn","Python")}</code>, <code>${a("\\pgup","Python")}</code>, <code>${a("\return","Python")}</code>, <code>${a("\right","Python")}</code>, <code>${a("\\rwin","Python")}</code>, <code>${a("\\shift","Python")}</code>, <code>${a("\\space","Python")}</code>, <code>${a("\\tab","Python")}</code>, and <code>${a("\\up","Python")}</code>, as well as <code>${a("\\a","Python")}</code> to <code>${a("\\z","Python")}</code>, <code>${a("\\0","Python")}</code> to <code>${a("\\9","Python")}</code>, <code>${a("\\hash","Python")}</code>, <code>${a("\\equals","Python")}</code> etc. Keys on the numeric keypad have codes <code>${a("\\#0","Python")}</code>, <code>${a("\\#1","Python")}</code> etc., and function keys <code>${a("\\f1","Python")}</code>, <code>${a("\\f2","Python")}</code> etc. All these stand for numeric values (e.g. <code>${a("\\return","Python")}</code> is 13, <code>${a("\\escape","Python")}</code> is 27), but <code>${a("if ?key = \return","Python")}</code> is easier to understand than <code>${a("if ?key = 13","Python")}</code>.`}),o("p",{content:`Like the mouse-click variables, <code>${a("?key","Python")}</code> becomes negative after the key is released, so <code>${a("while not(?key = -\\a): pass","Python")}</code> will wait until the <kbd>A</kbd> key has been released. If you want to identify the last key, whether it is still pressed or not, use <code>${a("abs","Python")}</code> (e.g. <code>${a("if abs(?key) = \\a: # command","Python")}</code>).`}),o("p",{content:`Whenever a key is pressed, the variable <code>${a("?kshift","Python")}</code> gives its &lsquo;shift-status&rsquo;, calculated in the same way as <code>${a("?click","Python")}</code> (i.e. 128 plus 8 if <kbd>shift</kbd> was down, 16 for <kbd>alt</kbd>, 32 for <kbd>ctrl</kbd>, and turning negative after the key is released). So to test if <kbd>ctrl</kbd> was down on the last keypress, use <code>${a("if (abs(?kshift) and 32) > 0","Python")}</code>, with <code>${a("and","Python")}</code> here acting as a bitwise boolean operator.`}),o("p",{content:`To recover the shift-status for the last press of the <kbd>X</kbd> key (say), use <code>${a("keystatus(\\x)","Python")}</code>, which can tell you (a) whether <kbd>shift</kbd> / <kbd>alt</kbd> / <kbd>ctrl</kbd> were down; (b) whether the <kbd>X</kbd> is still pressed (since <code>${a("keystatus","Python")}</code> goes negative on release); (c) whether <kbd>X</kbd> has been pressed at all (since all of these input codes are set to -1 initially, and can be reset to -1 using <code>${a("reset(\\x)","Python")}</code> etc.).`}),o("h4",{content:"Keyboard Input"}),o("p",{content:`The system provides a <em>keyboard buffer</em> to store typed characters. Initially this is set to store up to 32 characters, but can be extended using e.g. <code>${a("keybuffer(50)","Python")}</code>. To read from the buffer into a string, use e.g. <code>${a("s = read(10)","Python")}</code>, which reads up to 10 characters (depending on how many are in the buffer). <code>${a("keystatus(\\keybuffer)","Python")}</code> returns the number of characters it contains, and <code>${a("reset(\\keybuffer)","Python")}</code> flushes it.`}),o("p",{content:`<code>${a("s = readln","Python")}</code> reads a line of text, waiting until the <kbd>return</kbd> key is pressed and then making <code>${a("s","Python")}</code> equal to what has been typed into the buffer (discarding the <kbd>return</kbd> character).`}),o("p",{content:`The function <code>${a("detect","Python")}</code> waits a given time for some input to be received (e.g. a specific key pressed), and returns <code>${a("True","Python")}</code> when that input is received, or <code>${a("False","Python")}</code> if it is not received in time. Thus <code>${a("if detect(\\escape, 5000): #command1","Python")}</code> <code>${a("else: #command2","Python")}</code> gives 5 seconds to press the <kbd>escape</kbd> key (meanwhile continuing to collect any typed characters in the keyboard buffer). By default, text that goes into the keyboard buffer is also &lsquo;echoed&rsquo; to the console (below the Canvas), along with text that is output (using <code>${a("write","Python")}</code> or <code>${a("writeln","Python")}</code>). This behaviour can be turned on and off with <code>${a("keyecho(True)","Python")}</code> and <code>${a("keyecho(False)","Python")}</code>.`})];i.on("language-changed",e=>{const n={BASIC:s,Pascal:l,Python:c};r.innerHTML="",n[e].forEach(e=>r.appendChild(e))})},function(e,n,t){const{element:o}=t(0),r=o("div");e.exports=r;const{highlight:a}=t(4),i=t(1),s=[o("h3",{content:"Arithmetical Operators"}),o("p",{content:"The four main arithemetical operators are represented as:"}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:`<td><code>${a("+","BASIC")}</code></td><td>addition (also used for string concatenation)</td>`}),o("tr",{content:`<td><code>${a("-","BASIC")}</code></td><td>subtraction</td>`}),o("tr",{content:`<td><code>${a("*","BASIC")}</code></td><td>multiplication</td>`}),o("tr",{content:`<td><code>${a("/","BASIC")}</code></td><td>division</td>`})]}),o("p",{content:`<code>${a("/","BASIC")}</code> is <em>integer</em> division, with the remainder discarded (e.g. <code>${a("14 / 3 = 4","BASIC")}</code>). Remainders are given by:`}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:`<td><code>${a("MOD","BASIC")}</code></td><td>remainder</td>`})]}),o("p",{content:`(e.g. <code>${a("14 MOD 3 = 2","BASIC")}</code>; <code>${a("67 MOD 10 = 7","BASIC")}</code>).`}),o("h3",{content:"Doing Fractional (e.g. Decimal) Arithmetic"}),o("p",{content:`The Turtle Machine is designed to handle memory simply and transparently for the learning of computer science, and so has no special type for representing fractional numbers; which is why <code>${a("/","BASIC")}</code> is integer division. But the Turtle System can handle fractional numbers by treating them explicitly as fractions, with both a numerator (above the line) and a denominator (below the line). A denominator of 1000000, for instance, allows decimal arithmetic to 6 decimal places.`}),o("p",{content:`Thus to get the sine of 34.56 degrees to 6 decimal places, you could use <code>${a("n% = SIN(3456, 100, 1000000)","BASIC")}</code> – this makes <code>${a("n%","BASIC")}</code> equal to the sine of the angle 3456/100, multiplied by 1000000 (and rounded). <code>${a("WRITELN(QSTR$(n%, 1000000, 6))","BASIC")}</code> will then print n%/1000000 to six decimal places, i.e. <code>${a('"0.567269"',"BASIC")}</code>. For more illustrations of this sort of decimal arithmetic, see the example program &lsquo;Mathematical functions&rsquo;.`}),o("h3",{content:"Boolean Operators"}),o("p",{content:"The four main boolean operators are represented in the standard way:"}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:`<td><code>${a("NOT","BASIC")}</code></td><td>negation</td>`}),o("tr",{content:`<td><code>${a("AND","BASIC")}</code></td><td>conjunction</td>`}),o("tr",{content:`<td><code>${a("OR","BASIC")}</code></td><td>disjunction (inclusive)</td>`}),o("tr",{content:`<td><code>${a("EOR","BASIC")}</code></td><td>exclusive disjunction</td>`})]}),o("p",{content:`These are used between integers, where zero stands for false and any other number stands for true. <code>${a("FALSE","BASIC")}</code> stands for <code>${a("0","BASIC")}</code> and <code>${a("TRUE","BASIC")}</code> for <code>${a("-1","BASIC")}</code>. The Boolean operators can also be used in a bitwise fashion (i.e. each binary bit in the result is calculated as the result of the relevant boolean operation on the corresponding bits of the inputs, e.g. <code>${a("21 AND 6 = 4","BASIC")}</code> (binary <code>${a("10101 AND 00110 = 100","BASIC")}</code>); <code>${a("21 OR 6 = 23","BASIC")}</code> (<code>${a("10111","BASIC")}</code>); <code>${a("21 EOR 6 = 19","BASIC")}</code> (<code>${a("10011","BASIC")}</code>).`}),o("h3",{content:"Comparison Operators"}),o("p",{content:"The six comparison operators are applicable to all types (with strings compared alphabetically):"}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:`<td><code>${a("=","BASIC")}</code></td><td>equality</td>`}),o("tr",{content:`<td><code>${a("<>","BASIC")}</code></td><td>inequality</td>`}),o("tr",{content:`<td><code>${a("<","BASIC")}</code></td><td>less than</td>`}),o("tr",{content:`<td><code>${a("<=","BASIC")}</code></td><td>less than or equal</td>`}),o("tr",{content:`<td><code>${a(">","BASIC")}</code></td><td>greater than</td>`}),o("tr",{content:`<td><code>${a(">=","BASIC")}</code></td><td>greater than or equal</td>`})]}),o("h3",{content:"Bracketing"}),o("p",{content:"Complex expressions require brackets, e.g."}),o("pre",{content:`<code>${a("IF (n% < 0) OR (n% > 9) THEN\n  n% = ((a% + 1) * (b% + 3) + c%) MOD 10","BASIC")}</code>`})],l=[o("h3",{content:"Arithmetical Operators"}),o("p",{content:"The four main arithemetical operators are represented as:"}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:`<td><code>${a("+","Pascal")}</code></td><td>addition (also used for string concatenation)</td>`}),o("tr",{content:`<td><code>${a("-","Pascal")}</code></td><td>subtraction</td>`}),o("tr",{content:`<td><code>${a("*","Pascal")}</code></td><td>multiplication</td>`}),o("tr",{content:`<td><code>${a("/","Pascal")}</code></td><td>division</td>`})]}),o("p",{content:`<code>${a("/","Pascal")}</code> is <em>integer</em> division, with the remainder discarded (e.g. <code>${a("14 / 3 = 4","Pascal")}</code>). Remainders are given by:`}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:`<td><code>${a("mod","Pascal")}</code></td><td>remainder</td>`})]}),o("p",{content:`(e.g. <code>${a("14 mod 3 = 2","Pascal")}</code>; <code>${a("67 mod 10 = 7","Pascal")}</code>).`}),o("h3",{content:"Doing Fractional (e.g. Decimal) Arithmetic"}),o("p",{content:`The Turtle Machine is designed to handle memory simply and transparently for the learning of computer science, and so has no special type for representing fractional numbers; which is why <code>${a("/","Pascal")}</code> is integer division. But the Turtle System can handle fractional numbers by treating them explicitly as fractions, with both a numerator (above the line) and a denominator (below the line). A denominator of 1000000, for instance, allows decimal arithmetic to 6 decimal places.`}),o("p",{content:`Thus to get the sine of 34.56 degrees to six decimal places, you could use <code>${a("n := sin(3456, 100, 1000000)","Pascal")}</code> – this makes <code>${a("n","Pascal")}</code> equal to the sine of the angle 3456/100, multiplied by 1000000 (and rounded). <code>${a("writeln(qstr(n, 1000000, 6))","Pascal")}</code> will then print n/1000000 to six decimal places, i.e. <code>${a('"0.567269"',"Pascal")}</code>. For more illustrations of this sort of decimal arithmetic, see the example program &lsquo;Mathematical functions&rsquo;.`}),o("h3",{content:"Boolean Operators"}),o("p",{content:"The four main boolean operators are represented in the standard way:"}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:`<td><code>${a("not","Pascal")}</code></td><td>negation</td>`}),o("tr",{content:`<td><code>${a("and","Pascal")}</code></td><td>conjunction</td>`}),o("tr",{content:`<td><code>${a("or","Pascal")}</code></td><td>disjunction (inclusive)</td>`}),o("tr",{content:`<td><code>${a("xor","Pascal")}</code></td><td>exclusive disjunction</td>`})]}),o("p",{content:`These can also be used between integers, in a <em>bitwise</em> fashion (i.e. each binary bit in the result is calculated as the result of the relevant boolean operation on the corresponding bits of the inputs), e.g. <code>${a("21 and 6 = 4","Pascal")}</code> (binary <code>${a("10101 and 00110 = 100","Pascal")}</code>); <code>${a("21 or 6 = 23","Pascal")}</code> (<code>${a("10111","Pascal")}</code>); <code>${a("21 xor 6 = 19","Pascal")}</code> (<code>${a("10011","Pascal")}</code>).`}),o("h3",{content:"Comparison Operators"}),o("p",{content:"The six comparison operators are applicable to all types (with strings compared alphabetically):"}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:`<td><code>${a("=","Pascal")}</code></td><td>equality</td>`}),o("tr",{content:`<td><code>${a("<>","Pascal")}</code></td><td>inequality</td>`}),o("tr",{content:`<td><code>${a("<","Pascal")}</code></td><td>less than</td>`}),o("tr",{content:`<td><code>${a("<=","Pascal")}</code></td><td>less than or equal</td>`}),o("tr",{content:`<td><code>${a(">","Pascal")}</code></td><td>greater than</td>`}),o("tr",{content:`<td><code>${a(">=","Pascal")}</code></td><td>greater than or equal</td>`})]}),o("h3",{content:"Bracketing"}),o("p",{content:"Complex expressions require brackets, e.g."}),o("pre",{content:`<code>${a("if (n < 0) or (n > 9) then\n  n := ((a + 1) * (b + 3) + c) mod 10","Pascal")}</code>`})],c=[o("h3",{content:"Arithmetical Operators"}),o("p",{content:"The four main arithemetical operators are represented as:"}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:`<td><code>${a("+","Python")}</code></td><td>addition (also used for string concatenation)</td>`}),o("tr",{content:`<td><code>${a("-","Python")}</code></td><td>subtraction</td>`}),o("tr",{content:`<td><code>${a("*","Python")}</code></td><td>multiplication</td>`}),o("tr",{content:`<td><code>${a("//","Python")}</code></td><td>division</td>`})]}),o("p",{content:`<code>${a("//","Python")}</code> is <em>integer</em> division, with the remainder discarded (e.g. <code>${a("14 // 3 = 4","Python")}</code>). Remainders are given by:`}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:`<td><code>${a("mod","Python")}</code></td><td>remainder</td>`})]}),o("p",{content:`(e.g. <code>${a("14 mod 3 == 2","Python")}</code>; <code>${a("67 mod 10 == 7","Python")}</code>).`}),o("h3",{content:"Doing Fractional (e.g. Decimal) Arithmetic"}),o("p",{content:`The Turtle Machine is designed to handle memory simply and transparently for the learning of computer science, and so has no special type for representing fractional numbers; which is why <code>${a("//","Python")}</code> is integer division. But the Turtle System can handle fractional numbers by treating them explicitly as fractions, with both a numerator (above the line) and a denominator (below the line). A denominator of 1000000, for instance, allows decimal arithmetic to 6 decimal places.`}),o("p",{content:`Thus to get the sine of 34.56 degrees to six decimal places, you could use <code>${a("n = sin(3456, 100, 1000000)","Python")}</code> – this makes <code>${a("n","Python")}</code> equal to the sine of the angle 3456/100, multiplied by 1000000 (and rounded). <code>${a("writeln(qstr(n, 1000000, 6))","Python")}</code> will then print n/1000000 to six decimal places, i.e. <code>${a("'0.567269'","Python")}</code>. For more illustrations of this sort of decimal arithmetic, see the example program &lsquo;Mathematical functions&rsquo;.`}),o("h3",{content:"Boolean Operators"}),o("p",{content:"The four main boolean operators are represented in the standard way:"}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:`<td><code>${a("not","Python")}</code></td><td>negation</td>`}),o("tr",{content:`<td><code>${a("and","Python")}</code></td><td>conjunction</td>`}),o("tr",{content:`<td><code>${a("or","Python")}</code></td><td>disjunction (inclusive)</td>`}),o("tr",{content:`<td><code>${a("xor","Python")}</code></td><td>exclusive disjunction</td>`})]}),o("p",{content:`These can also be used between integers, in a <em>bitwise</em> fashion (i.e. each binary bit in the result is calculated as the result of the relevant boolean operation on the corresponding bits of the inputs), e.g. <code>${a("21 and 6 = 4","Python")}</code> (binary <code>${a("10101 and 00110 = 100","Python")}</code>); <code>${a("21 or 6 = 23","Python")}</code> (<code>${a("10111","Python")}</code>); <code>${a("21 xor 6 = 19","Python")}</code> (<code>${a("10011","Python")}</code>).`}),o("h3",{content:"Comparison Operators"}),o("p",{content:"The six comparison operators are applicable to all types (with strings compared alphabetically):"}),o("table",{classes:["tsx-help-table"],content:[o("tr",{content:`<td><code>${a("==","Python")}</code></td><td>equality</td>`}),o("tr",{content:`<td><code>${a("!=","Python")}</code></td><td>inequality</td>`}),o("tr",{content:`<td><code>${a("<","Python")}</code></td><td>less than</td>`}),o("tr",{content:`<td><code>${a("<=","Python")}</code></td><td>less than or equal</td>`}),o("tr",{content:`<td><code>${a(">","Python")}</code></td><td>greater than</td>`}),o("tr",{content:`<td><code>${a(">=","Python")}</code></td><td>greater than or equal</td>`})]}),o("h3",{content:"Bracketing"}),o("p",{content:"Complex expressions require brackets, e.g."}),o("pre",{content:`<code>${a("if (n < 0) or (n > 9):\n  n = ((a + 1) * (b + 3) + c) mod 10","Python")}</code>`})];i.on("language-changed",e=>{const n={BASIC:s,Pascal:l,Python:c};r.innerHTML="",n[e].forEach(e=>r.appendChild(e))})},function(e,n,t){const{element:o}=t(0),r=o("div");e.exports=r;const{highlight:a}=t(4),i=t(1),s=[o("h3",{content:"Command Structures"}),o("p",{content:"Selection and ordering of commands is done by <em>sequencing</em>, <em>conditional selection</em>, and <em>looping</em>."}),o("h4",{content:"Sequencing of Commands"}),o("p",{content:"Commands to be performed in sequence are usually placed in the appropriate order within the program, e.g.:"}),o("pre",{content:`<code>${a("COLOUR(GREEN)\nBLOT(100)\nPAUSE(1000)\nCOLOUR(RED)\nFORWARD(450) REM etc.","BASIC")}</code>`}),o("p",{content:"(From the first example program in the Help menu.)"}),o("h4",{content:"Conditional Selection of Commands"}),o("p",{content:`Suppose you want to draw a blot with a given radius (stored as the integer variable <code>${a("radius%","BASIC")}</code>), but only if that value is less than 500; do it like this:`}),o("pre",{content:`<code>${a("IF radius% < 500 THEN\n  BLOT(radius%)\nENDIF","BASIC")}</code>`}),o("p",{content:`If you want to do something different when the condition is not met (e.g. drawing a blot with half the radius), extend the <code>${a("IF - THEN","BASIC")}</code> structure by adding <code>${a("ELSE","BASIC")}</code> and then the new command:`}),o("pre",{content:`<code>${a("IF radius% < 500 THEN\n  BLOT(radius%)\nELSE\n  BLOT(radius% / 2)\nENDIF","BASIC")}</code>`}),o("h4",{content:"Grouping of Commands"}),o("p",{content:`A sequence of commands within an <code>${a("IF - THEN - ELSE - ENDIF","BASIC")}</code> structure is always treated as a single command. The <code>${a("ELSE","BASIC")}</code> and <code>${a("ENDIF","BASIC")}</code> words bracket off the sequence of commands. (Another possibility is to package them into a procedure.) You can also write these on a single line without the <code>${a("ENDIF","BASIC")}</code>, like this:`}),o("pre",{content:`<code>${a("IF radius% < 500 THEN BLOT(radius%)","BASIC")}</code>`}),o("h4",{content:"Spacing, Indenting, Auto-Formatting"}),o("p",{content:"Unnecessary &lsquo;white space&rsquo; is ignored by BASIC, so you can use line breaks and indenting to make the structure of your program easy to read. However, each statement must be on its own line, unless separated by a colon &lsquo;:&rsquo;."}),o("h4",{content:"Looping Structures"}),o("p",{content:`BASIC provides three different structures for looping (or &lsquo;iterating&rsquo;) commands. If you know in advance how many times you want to loop – or you want to &lsquo;loop over&rsquo; a particular range of values (e.g. from 1 to 200), then the simplest is a &lsquo;<code>${a("FOR","BASIC")}</code> loop&rsquo; (or &lsquo;counting loop&rsquo;):`}),o("pre",{content:`<code>${a("FOR count% = 1 TO 200\n  FORWARD(count% / 3)\n  RIGHT(5)\n  REM etc.\nNEXT","BASIC")}</code>`}),o("p",{content:`(From the first <code>${a("FOR","BASIC")}</code> loop example program in the Help menu.)`}),o("p",{content:`Here, <code>${a("NEXT","BASIC")}</code> is used to bracket together a number of commands, and indenting is used to show the structure.`}),o("p",{content:`To count downwards, use <code>${a("STEP -1","BASIC")}</code> at then end (as in the &lsquo;Procedure with parameter&rsquo; example program).`}),o("p",{content:`In a <code>${a("FOR","BASIC")}</code> loop, the &lsquo;loop variable&rsquo; (here <code>${a("count%","BASIC")}</code>) is given in turn each of the values in the range (here 1, 2, 3, &hellip;, 199, 200), and the loop instructions are performed each time. So in the example above, a spiral is drawn as the Turtle moves forward gradually more and more (as <code>${a("count%","BASIC")}</code> increases).`}),o("p",{content:"If instead of looping a specific number of times, you want to loop through some sequence of commands until some particular condition becomes true, then you can use:"}),o("pre",{content:`<code>${a("REPEAT\n  REM command1\n  REM command2 (etc.)\nUNTIL REM condition","BASIC")}</code>`}),o("p",{content:`The &lsquo;Simple procedure&rsquo; example program does this, looping until the Turtle is pointing directly north (i.e., <code>${a("TURTD% = 0","BASIC")}</code>).`}),o("p",{content:"Alternatively, you can loop through a sequence of commands while some condition is true (so that it stops when the condition becomes false):"}),o("pre",{content:`<code>${a("WHILE REM condition\n  REM sequence of commands\nENDWHILE","BASIC")}</code>`}),o("p",{content:`Things that can be done with a <code>${a("REPEAT","BASIC")}</code> loop can equally be done with a <code>${a("WHILE","BASIC")}</code> loop (and vice-versa), but sometimes one is more natural than the other. Notice also that a <code>${a("REPEAT","BASIC")}</code> loop always executes the sequence of commands at least once, because it tests the condition at the end of the loop. But a <code>${a("WHILE","BASIC")}</code> loop tests the condition <em>before</em> executing the sequence of commands, and so will not execute them even once if condition is false to start with. (For examples of the various loops, see the second set of example programs, &lsquo;Further commands and structures&rsquo;.)`})],l=[o("h3",{content:"Command Structures"}),o("p",{content:"Selection and ordering of commands is done by <em>sequencing</em>, <em>conditional selection</em>, and <em>looping</em>."}),o("h4",{content:"Sequencing of Commands"}),o("p",{content:"Commands to be performed in sequence are usually placed in the appropriate order within the program, separated by semicolons, e.g.:"}),o("pre",{content:`<code>${a("colour(green);\nblot(100);\npause(1000);\ncolour(red);\nforward(450); {etc.}","Pascal")}</code>`}),o("p",{content:"(From the first example program in the Help menu.)"}),o("h4",{content:"Conditional Selection of Commands"}),o("p",{content:`Suppose you want to draw a blot with a given radius (stored as the integer variable <code>${a("radius","Pascal")}</code>), but only if that value is less than 500; do it like this:`}),o("pre",{content:`<code>${a("if radius < 500 then\n  blot(radius);","Pascal")}</code>`}),o("p",{content:`If you want to do something different when the condition is not met (e.g. drawing a blot with half the radius), extend the <code>${a("if condition then","Pascal")}</code> structure by adding <code>${a("else","Pascal")}</code> and then the new command:`}),o("pre",{content:`<code>${a("if radius < 500 then\n  blot(radius)\nelse\n  blot(radius / 2);","Pascal")}</code>`}),o("p",{content:`Notice that this is a single complex command, so you must not put a semicolon before the <code>${a("else","Pascal")}</code> (if you do, Turtle will give you a warning).`}),o("h4",{content:"Grouping of Commands"}),o("p",{content:`Sometimes you will want to do a sequence of commands within an <code>${a("if {condition} then {command} else","Pascal")}</code> structure, in which case you can bracket them between <code>${a("begin","Pascal")}</code> and <code>${a("end","Pascal")}</code>, e.g.`}),o("pre",{content:`<code>${a("if {condition} then\n  begin\n    {sequence1}\n  end\nelse\n  begin\n    {sequence2}\n  end;","Pascal")}</code>`}),o("p",{content:"Any such bracketed sequence of commands is always treated as a single command. (Another possibility is to package them into a procedure.)"}),o("h4",{content:"Spacing, Indenting, Auto-Formatting"}),o("p",{content:"Unnecessary &lsquo;white space&rsquo; is ignored by Pascal, so you can use line breaks and indenting to make the structure of your program easy to read."}),o("h4",{content:"Looping Structures"}),o("p",{content:`Pascal provides three different structures for looping (or &lsquo;iterating&rsquo;) commands. If you know in advance how many times you want to loop – or you want to &lsquo;loop over&rsquo; a particular range of values (e.g. from 1 to 200), then the simplest is a &lsquo;<code>${a("for","Pascal")}</code> loop&rsquo; (or &lsquo;counting loop&rsquo;):`}),o("pre",{content:`<code>${a("for count := 1 to 200 do\n  begin\n    forward(count / 3);\n    right(5);\n    {etc.}\n  end;","Pascal")}</code>`}),o("p",{content:`(From the first <code>${a("for","Pascal")}</code> loop example program in the Help menu.)`}),o("p",{content:`Again <code>${a("begin {commands} end","Pascal")}</code> is used to bracket together a number of commands, and indenting is used to show the structure.`}),o("p",{content:`In a <code>${a("for","Pascal")}</code> loop, the &lsquo;loop variable&rsquo; (here <code>${a("count","Pascal")}</code>) is given in turn each of the values in the range (here 1, 2, 3, &hellip;, 199, 200), and the loop instructions are performed each time. So in the example above, a spiral is drawn as the Turtle moves forward gradually more and more (as <code>${a("count","Pascal")}</code> increases).`}),o("p",{content:`To count downwards, use <code>${a("downto","Pascal")}</code> instead of <code>${a("to","Pascal")}</code> (as in the &lsquo;Procedure with parameter&rsquo; example program.`}),o("p",{content:"If instead of looping a specific number of times, you want to loop through some sequence of commands until some particular condition becomes true, then you can use:"}),o("pre",{content:`<code>${a("repeat\n  {command1;}\n  {command2; (etc.)}\nuntil {condition}","Pascal")}</code>`}),o("p",{content:`<p>The &lsquo;Simple procedure&rsquo; example program does this, looping until the Turtle is pointing directly north (i.e., <code>${a("turtd = 0","Pascal")}</code>). Alternatively, you can loop through a sequence of commands while some condition is true (so that it stops when the condition becomes false):`}),o("pre",{content:`<code>${a("while {condition} do\n  begin\n    {sequence of commands}\n  end;","Pascal")}</code>`}),o("p",{content:`Things that can be done with a &lsquo;<code>${a("repeat","Pascal")}</code> loop&rsquo; can equally be done with a &lsquo;<code>${a("while","Pascal")}</code> loop&rsquo; (and vice-versa), but sometimes one is more natural than the other. Notice also that a <code>${a("repeat","Pascal")}</code> loop always executes the sequence of commands at least once, because it tests the condition at the end of the loop. But a <code>${a("while","Pascal")}</code> loop tests the condition <em>before</em> executing the sequence of commands, and so will not execute them even once if condition is false to start with. (For examples of the various loops, see the second set of example programs, &lsquo;Further commands and structures&rsquo;.)`})],c=[o("h3",{content:"Command Structures"}),o("p",{content:"Selection and ordering of commands is done by <em>sequencing</em>, <em>conditional selection</em>, and <em>looping</em>."}),o("h4",{content:"Sequencing of Commands"}),o("p",{content:"Commands to be performed in sequence are usually placed in the appropriate order within the program, with the same indent, e.g.:"}),o("pre",{content:`<code>${a("colour(green)\nblot(100)\npause(1000) # etc.","Python")}</code>`}),o("p",{content:"(From the first example program in the Help menu.)"}),o("h4",{content:"Conditional Selection of Commands"}),o("p",{content:`Suppose you want to draw a blot with a given radius (stored as the integer variable <code>${a("radius","Python")}</code>), but only if that value is less than 500; do it like this:`}),o("pre",{content:`<code>${a("if radius < 500:\n  blot(radius)","Python")}</code>`}),o("p",{content:`If you want to do something different when the condition is not met (e.g. drawing a blot with half the radius), extend the <code>${a("if","Python")}</code> structure by adding <code>${a("else","Python")}</code> and then the new command:`}),o("pre",{content:`<code>${a("if radius < 500:\n  blot(radius)\nelse:\n  blot(radius // 2)","Python")}</code>`}),o("p",{content:`Notice that this is a single complex command, so the <code>${a("else","Python")}</code> must have the same indent as <code>${a("if","Python")}</code> and the sub-commands must be further indented (if you do not indent correctly, Turtle will give you a warning).`}),o("h4",{content:"Grouping of Commands"}),o("p",{content:`Sometimes you will want to do a sequence of commands within an <code>${a("if - else","Python")}</code> structure, in which case you can group them by indenting them all by the same amount. Any such indented sequence of commands is treated as a single command. (Another possibility is to package them into a function.)`}),o("p",{content:"Note that indents must be consistent, so the following will generate several errors:"}),o("pre",{content:`<code>${a("if radius < 500:\n  blot(radius)\n    blot(radius // 3)      # too many indents\n  else:            # should match the if line\n  blot(radius // 2) # needs indent after else","Python")}</code>`}),o("h4",{content:"Auto-Formatting"}),o("h4",{content:"Looping Structures"}),o("p",{content:`Python provides two different structures for looping (or &lsquo;iterating&rsquo;) commands. If you know in advance how many times you want to loop – or you want to &lsquo;loop over&rsquo; a particular range of values (e.g. from 1 to 200), then the simplest is a &lsquo;<code>${a("for","Python")}</code> loop&rsquo; (or &lsquo;counting loop&rsquo;):`}),o("pre",{content:`<code>${a("for count in range(1, 201, 1):\n  forward(count // 3)\n  right(5)\n  # etc.","Python")}</code>`}),o("p",{content:`(From the first <code>${a("for","Python")}</code> loop example program in the Help menu.)`}),o("p",{content:"Again indenting is used to group together a number of commands."}),o("p",{content:`In a <code>${a("for","Python")}</code> loop, the &lsquo;loop variable&rsquo; (here <code>${a("count","Python")}</code>) is given in turn each of the values in the range (here 1, 2, 3, &hellip;, 199, 200), and the loop instructions are performed each time. So in the example above, a spiral is drawn as the Turtle moves forward gradually more and more (as <code>${a("count","Python")}</code> increases).`}),o("p",{content:`The <code>${a("range","Python")}</code> function specifies the values that the loop variable will take as follows:`}),o("pre",{content:`<code>${a("range(firstValue, lastValue + 1, increment)","Python")}</code>`}),o("p",{content:"The increment can be either 1 or -1. To count down through a loop, use an increment of -1."}),o("p",{content:"If instead of looping a specific number of times, you want to loop through some sequence of commands while some condition is true (so that it stops when the condition becomes false), then you can use:"}),o("pre",{content:`<code>${a("while condition:\n  # sequence of commands","Python")}</code>`}),o("p",{content:`A <code>${a("while","Python")}</code> loop tests the condition <em>before</em> executing the sequence of commands, and so will not execute them even once if condition is false to start with. (For examples of the various loops, see the second set of example programs, &lsquo;Further commands and structures&rsquo;.)`})];i.on("language-changed",e=>{const n={BASIC:s,Pascal:l,Python:c};r.innerHTML="",n[e].forEach(e=>r.appendChild(e))})},function(e,n,t){const{element:o}=t(0),r=[o("h3",{content:"The HTML5 Canvas API"}),o("p",{content:'The <em>Online Turtle System</em> uses the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">HTML5 Canvas API</a> for rendering the <em>Turtle Graphics</em> output of your programs. Because of the inherent nature of this API, it has not been possible to maintain complete consistency in the visual output of your programs between the downloadable and online systems. The following unavoidable differences remain:'}),o("ul",{content:[o("li",{content:'<b>Anti-aliasing</b> The HTML5 Canvas API makes its images appear smoother at the edges using a technique called "anti-aliasing". This means, for example, that when you draw a red blot on the Canvas, the pixels immediately surrounding that blot will be filled in using a semi-transparent red of the same shade. The downloadable <i>Turtle System</i> does not do this, giving your shapes sharper and more visibly "pixelated" edges. The most likely practical effect this difference will make to your programs concerns animations. To give the appearance of a red ball moving against a white background, for example, you need to draw a red blot, pause for a moment, then draw a white blot on top of it (to "blot it out"), immediately drawing another red blot in a slightly different position. To achieve this effect in the <i>Online Turtle System</i>, the white blot needs to be slightly <em>larger</em> than the red blot. If it is not, the semi-transparent red pixels around the edges of your red ball will not be blotted out, and you will see a kind of "vapour trail" as the ball moves across the screen.'}),o("li",{content:'<b>Line drawing</b> A Canvas coordinate corresponds to the top left corner of a square pixel. A horizontal or vertical line from one coordinate to another is thus conceptually centered <em>in between</em> two pixels. If the thickness of the line is even, this causes no difficulty, as the same number of pixels can be filled in on either side. If the thickness of the line is odd, however, it is less obvious what should be done. The downloadable <i>Turtle System</i> fills in an extra pixel either to the right of or below the coordinate line, meaning that horizontal and vertical lines of odd-numbered thickness are centred half a pixel to the right or below their even-numbered counterparts. The HTML5 Canvas API, however, keeps lines of odd-numbered thickness exactly centred, giving the appearance of "half" pixels on either side using anti-aliasing (i.e. an extra pixel is filled in on <em>both</em> sides, but using a semi-transparent colour). At the default (very high) resolution, this will not make any noticeable difference to your programs. At lower resolutions, however, where each pixel is a visible square on the Canvas, the difference can be quite striking. To mitigate this, the <i>Online Turtle System</i> artificially doubles the resolution of the Canvas when it is set to anything below 60 in either dimension (this setting can be changed or turned off entirely in the options tab). The effect of this is to eliminate any lines of odd-numbered thickness, since the actual output thickness will always be multiplied by 2. For an illustration of the problem this is designed to solve, you may like to disable this option, and then run the <i>Snake (classic game)</i> example program.'}),o("li",{content:"<b>Text underlining</b> The HTML5 Canvas API does not support underlined text. Consequently attempts to print underlined text to the Canvas in the <i>Online Turtle System</i> will result in normal text being printed instead."})]})];e.exports=o("div",{content:r})},function(e,n,t){const{element:o}=t(0),r=o("h2"),a=o("p"),i=o("div",{classes:["tsx-buttons"],content:[o("button",{content:"OK",on:[{type:"click",callback:()=>{s.classList.remove("tsx-open")}}]})]}),s=o("div",{classes:["tsx","tsx-modal-overlay"],content:[o("div",{classes:["tsx-modal"],content:[o("div",{classes:["tsx-modal-head"],content:[r]}),o("div",{classes:["tsx-modal-body"],content:[a,i]})]})]});e.exports.overlay=s,e.exports.show=(e=>{console.log(e),e.lexeme&&console.log(e.lexeme),e.type?(r.innerHTML=`${e.type} Error`,a.innerHTML=e.message,e.lexeme&&(r.innerHTML+=`: "${e.lexeme.content}", line ${e.lexeme.line}`)):(r.innerHTML="System Error",a.innerHTML="An unexpected error has occured, suggesting there is a bug in the system. Please contact us with details of what you were doing when this message appeared, and we will do our best to locate and fix the bug."),s.classList.add("tsx-open")})},function(e,n,t){const{show:o,tabs:r}=t(0),a=t(281),i=t(282),s=t(283),l=t(284);e.exports.tabs=r("tsx-system-tabs",[{label:"File",active:!1,content:[a]},{label:"Code",active:!0,content:[i]},{label:"Usage",active:!1,content:[s]},{label:"PCode",active:!1,content:[l.options,l.table]}]),e.exports.file=a,e.exports.code=i,e.exports.usage=s,e.exports.pcode=l,t(1).on("file-changed",o.bind(null,"Code"))},function(e,n,t){const{element:o}=t(0),{examples:r}=t(2),a=e=>{p.send("set-example",e.currentTarget.value)},i=o("input",{type:"file",on:[{type:"change",callback:e=>{const n=e.currentTarget.files[0],t=new window.FileReader;t.onload=(()=>{p.send("set-file",{filename:n.name,content:t.result})}),t.readAsText(n)}}]}),s=e=>o("option",{value:e,content:r.names[e]}),l=e=>o("optgroup",{label:`${e.index}. ${e.title}`,content:e.examples.map(s)}),c=e=>o("select",{content:e.map(l),on:[{type:"change",callback:a},{type:"focus",callback:e=>{e.currentTarget.selectedIndex=-1}}]}),d=(e,n)=>o("div",{classes:["tsx-file-box"],content:[o("h2",{content:e}),n]}),u=o("div",{content:[d("Open Local File",i),d("Open Example Program",c(r.help)),d("Open CSAC Book Program",c(r.csac))]}),p=t(1);e.exports=u},function(e,n,t){const{element:o}=t(0),r=o("ol"),a=o("code"),i=o("pre",{content:[a]}),s=o("textarea",{wrap:"off",spellcheck:"false",autocapitalize:"off",autocomplete:"off",autocorrect:"off",on:[{type:"keydown",callback:e=>{if(9===e.keyCode){const n=e.currentTarget.selectionStart,t=e.currentTarget.value.slice(0,n),o=e.currentTarget.value.slice(n);e.preventDefault(),e.currentTarget.value=[t,o].join("  "),c.send("set-code",e.currentTarget.value),e.currentTarget.selectionStart=n+2,e.currentTarget.selectionEnd=n+2}}},{type:"input",callback:e=>{c.send("set-code",e.currentTarget.value)}}]}),l=o("div",{classes:["tsx-code"],content:[s,r,i]});e.exports=l;const c=t(1),{highlight:d}=t(4);c.on("code-changed",({code:e,language:n})=>{const t=e.split("\n");r.innerHTML=t.map((e,n)=>`<li>${(n+1).toString(10)}</li>`).join(""),a.innerHTML=d(e,n),window.requestAnimationFrame((e=>{s.value=e,s.style.height=`${r.scrollHeight.toString(10)}px`,s.style.width=`${i.scrollWidth.toString(10)}px`}).bind(null,e))}),c.on("file-changed",()=>{l.scrollTop=0,l.scrollLeft=0})},function(e,n,t){const{element:o}=t(0),r=o("thead",{content:[o("tr",{content:[o("th",{content:"Expression"}),o("th",{content:"Level"}),o("th",{content:"Count"}),o("th",{content:"Program Lines"})]})]}),a=o("tbody"),i=o("table",{classes:["tsx-usage-table"],content:[r,a]});e.exports=i;t(1).on("usage-changed",e=>{a.innerHTML="",e.forEach(e=>{a.appendChild(o("tr",{classes:["category-heading"],content:[o("th",{colspan:"4",content:e.title})]})),e.expressions.forEach(e=>{a.appendChild(o("tr",{content:[o("td",{content:e.name}),o("td",{content:e.level.toString()}),o("td",{content:e.count.toString()}),o("td",{content:e.lines.replace(/ /g,", ")})]}))}),a.appendChild(o("tr",{content:[o("td"),o("th",{content:"TOTAL:"}),o("th",{content:e.total.toString()}),o("td")]}))})})},function(e,n,t){const{element:o}=t(0),r=o("input",{type:"radio",name:"pcodeOptions1",on:[{type:"change",callback:()=>u.send("toggle-assembler")}]}),a=o("input",{type:"radio",name:"pcodeOptions1",on:[{type:"change",callback:()=>u.send("toggle-assembler")}]}),i=o("input",{type:"radio",name:"pcodeOptions2",on:[{type:"change",callback:()=>u.send("toggle-decimal")}]}),s=o("input",{type:"radio",name:"pcodeOptions2",on:[{type:"change",callback:()=>u.send("toggle-decimal")}]}),l=o("div",{classes:["tsx-pcode-options"],content:[o("div",{content:[o("label",{content:[r,"Assembler Code"]}),o("label",{content:[a,"Machine Code"]})]}),o("div",{content:[o("label",{content:[i,"Decimal"]}),o("label",{content:[s,"Hexadecimal"]})]})]}),c=o("ol",{classes:["tsx-pcode-table"]});e.exports={options:l,table:c};const{pcodes:d}=t(2),u=t(1),p=(e,n,t)=>{const r=e?h(t,0,n):t.reduce(m.bind(null,n),[]);for(;r.length%8>0;)r.push(o("div"));return o("li",{content:r})},h=(e,n,t)=>{const o=d[e[n]],r=o?[g(o.str)]:[g(e[n],t)];let a=0;if(o)if(o.args<0){let t=e[n+1];for(a+=1;a<=t;)a+=1,r.push(g(String.fromCharCode(e[n+a])))}else for(;a<o.args;)a+=1,r.push(g(e[n+a],t));return n+a<e.length-1?r.concat(h(e,n+a+1,t)):r},g=(e,n)=>o("div",void 0===n?{content:e}:n?{content:e.toString(10)}:{content:e.toString(16).toUpperCase()}),m=(e,n,t)=>n.concat(g(t,e));u.on("pcode-changed",({pcode:e,assembler:n,decimal:t})=>{n?r.setAttribute("checked","checked"):a.setAttribute("checked","checked"),t?i.setAttribute("checked","checked"):s.setAttribute("checked","checked"),c.innerHTML="",e.map(p.bind(null,n,t)).forEach(e=>c.appendChild(e))})},function(e,n,t){const{element:o}=t(0),{languages:r}=t(2),a=o("input",{type:"text",placeholder:"filename",on:[{type:"input",callback:e=>{l.send("set-name",e.currentTarget.value)}}]}),i=o("select",{content:r.map(e=>o("option",{content:e,value:e})),on:[{type:"change",callback:e=>{l.send("set-language",e.currentTarget.value)}}]}),s=o("div",{classes:["tsx-controls"],content:[a,i]});e.exports=s;const l=t(1);l.on("name-changed",e=>{a.value=e}),l.on("language-changed",e=>{i.value=e})},function(e,n,t){var o=t(287);"string"==typeof o&&(o=[[e.i,o,""]]);var r={hmr:!0,transform:void 0,insertInto:void 0};t(289)(o,r);o.locals&&(e.exports=o.locals)},function(e,n,t){(e.exports=t(288)(!1)).push([e.i,".tsx {\n  box-sizing: border-box;\n  font-family: helvetica, arial, sans-serif;\n  font-size: 16px;\n  color: #282828; }\n  .tsx *, .tsx *::before, .tsx *::after {\n    box-sizing: border-box; }\n  .tsx input, .tsx select, .tsx button {\n    font: inherit;\n    height: 2em;\n    padding: 4px; }\n  .tsx input, .tsx select {\n    border: 1px solid silver; }\n  .tsx label {\n    padding: 4px; }\n    .tsx label input {\n      height: auto;\n      padding: 0;\n      margin-right: .5em; }\n  .tsx button {\n    background: #159d6b;\n    border: 0;\n    padding: 4px 8px;\n    cursor: pointer;\n    color: #fff;\n    text-align: center;\n    transition: background .3s; }\n    .tsx button:hover {\n      background: #0f704c; }\n  .tsx table {\n    border-collapse: collapse;\n    border: 1px solid silver;\n    font-size: .9375em;\n    width: 100%; }\n    .tsx table thead {\n      background: #ebebeb; }\n    .tsx table th, .tsx table td {\n      border: 1px solid silver;\n      padding: .25em .5em;\n      vertical-align: top; }\n    .tsx table th {\n      font-weight: bold; }\n\n.tsx-system {\n  display: flex;\n  background: #282828;\n  line-height: 1; }\n\n.tsx-browser .tsx-system {\n  height: 748px;\n  max-width: 518px;\n  margin: 0 auto; }\n  @media (min-width: 1024px) {\n    .tsx-browser .tsx-system {\n      height: 700px;\n      max-width: 1024px; } }\n\n.tsx-electron, .tsx-electron body {\n  margin: 0;\n  height: 100%; }\n\n.tsx-electron .tsx-system {\n  height: 100%; }\n\n.tsx-modal-overlay {\n  display: none;\n  position: fixed;\n  z-index: 10;\n  background: rgba(0, 0, 0, 0.3);\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  padding: .5em; }\n  .tsx-modal-overlay .tsx-modal {\n    margin: 0 auto;\n    margin-top: -10em;\n    max-width: 30em;\n    box-shadow: 0 2px 3px rgba(10, 10, 10, 0.1), 0 0 0 1px rgba(10, 10, 10, 0.1); }\n  .tsx-modal-overlay .tsx-modal-head {\n    background: #159d6b;\n    color: #fff; }\n    .tsx-modal-overlay .tsx-modal-head h2 {\n      font-size: 1em;\n      margin: 0;\n      padding: .5em; }\n  .tsx-modal-overlay .tsx-modal-body {\n    background: #fff;\n    padding: 1em; }\n    .tsx-modal-overlay .tsx-modal-body p {\n      margin: 0 0 1em; }\n  .tsx-modal-overlay .tsx-buttons {\n    text-align: right; }\n  .tsx-modal-overlay.tsx-open {\n    display: block; }\n    .tsx-modal-overlay.tsx-open .tsx-modal {\n      margin-top: 8em; }\n\n.tsx-tabs {\n  flex: 1;\n  display: flex;\n  flex-direction: column; }\n  .tsx-tabs > .tsx-tab-list {\n    display: flex; }\n    .tsx-tabs > .tsx-tab-list .tsx-tab {\n      display: block;\n      cursor: pointer; }\n      .tsx-tabs > .tsx-tab-list .tsx-tab.active:hover {\n        cursor: default; }\n  .tsx-tabs > .tsx-tab-panes {\n    flex: 1;\n    display: flex;\n    padding: 4px; }\n    .tsx-tabs > .tsx-tab-panes .tsx-tab-pane {\n      display: none;\n      flex: 1;\n      flex-direction: column;\n      overflow: auto; }\n      .tsx-tabs > .tsx-tab-panes .tsx-tab-pane.active {\n        display: flex; }\n      .tsx-tabs > .tsx-tab-panes .tsx-tab-pane#Machine {\n        flex-basis: 510px;\n        flex-grow: 0; }\n\n.tsx-system-tabs > .tsx-tab-list .tsx-tab {\n  background: #ebebeb;\n  color: #282828;\n  padding: .625em .75em;\n  margin-right: .2em;\n  transform: translateY(0.125em);\n  transition: transform linear .1s; }\n  .tsx-system-tabs > .tsx-tab-list .tsx-tab:hover, .tsx-system-tabs > .tsx-tab-list .tsx-tab.active {\n    transform: translateY(0); }\n  .tsx-system-tabs > .tsx-tab-list .tsx-tab.active {\n    background: #fff; }\n\n.tsx-system-tabs > .tsx-tab-panes {\n  background: #fff;\n  z-index: 2; }\n\n.tsx-help-tabs {\n  flex-direction: row; }\n  .tsx-help-tabs > .tsx-tab-list {\n    flex-direction: column; }\n    .tsx-help-tabs > .tsx-tab-list .tsx-tab {\n      color: #fff;\n      padding: .75em .5em;\n      min-width: 8em; }\n      .tsx-help-tabs > .tsx-tab-list .tsx-tab:hover {\n        background: #5b5b5b; }\n      .tsx-help-tabs > .tsx-tab-list .tsx-tab.active {\n        color: #282828;\n        background: #fff; }\n  .tsx-help-tabs > .tsx-tab-panes {\n    background: #fff;\n    padding: 8px 16px; }\n    .tsx-help-tabs > .tsx-tab-panes .tsx-tab-pane {\n      margin: 0 auto;\n      max-width: 600px;\n      line-height: 1.5; }\n      .tsx-help-tabs > .tsx-tab-panes .tsx-tab-pane h3 {\n        margin: 0 0 .75em;\n        font-size: 1em; }\n      .tsx-help-tabs > .tsx-tab-panes .tsx-tab-pane p {\n        margin: 0 0 .75em; }\n        .tsx-help-tabs > .tsx-tab-panes .tsx-tab-pane p:last-child {\n          margin-bottom: 0; }\n\n.tsx-top-tabs > .tsx-tab-list .tsx-tab {\n  flex: 1;\n  padding: 1em;\n  background: #5b5b5b;\n  color: #fff; }\n  .tsx-top-tabs > .tsx-tab-list .tsx-tab:hover {\n    background: #424242; }\n  .tsx-top-tabs > .tsx-tab-list .tsx-tab.active {\n    background: #282828; }\n\n.tsx-top-tabs > .tsx-tab-panes {\n  padding: 4px; }\n\n@media (min-width: 1024px) {\n  .tsx-top-tabs > .tsx-tab-list {\n    display: none; }\n  .tsx-top-tabs > .tsx-tab-panes > .tsx-tab-pane {\n    display: flex; }\n    .tsx-top-tabs > .tsx-tab-panes > .tsx-tab-pane:first-child {\n      margin-right: 4px; } }\n\n.tsx-electron .tsx-help-tabs > .tsx-tab-panes {\n  overflow: auto; }\n\n.tsx-help {\n  flex-direction: column;\n  padding: 4px; }\n  .tsx-help h3 {\n    border-bottom: 2px solid #282828; }\n  .tsx-help h4 {\n    font-size: 1em;\n    margin-bottom: .75em; }\n  .tsx-help pre {\n    background: #f8f8f8;\n    border: 1px solid silver;\n    padding: 4px 8px;\n    margin: 0 0 .75em; }\n  .tsx-help table {\n    width: 100%;\n    border-collapse: collapse;\n    margin-bottom: .75em; }\n    .tsx-help table td {\n      border: 1px solid #ebebeb;\n      padding: 4px; }\n\n.tsx-browser .tsx-help {\n  height: auto;\n  max-width: 800px; }\n\n.tsx-controls {\n  display: flex;\n  justify-content: flex-end;\n  align-items: baseline;\n  background: #fff;\n  padding: 4px;\n  margin-bottom: 4px; }\n  .tsx-controls input {\n    flex: 1;\n    text-align: center; }\n  .tsx-controls input:not(:last-child), .tsx-controls select:not(:last-child), .tsx-controls button:not(:last-child) {\n    margin-right: 4px; }\n  .tsx-controls .tsx-run-halt-button {\n    flex-basis: 4em; }\n  .tsx-controls .tsx-play-pause-button {\n    flex-basis: 2em; }\n  .tsx-controls dl {\n    flex: 1;\n    display: flex;\n    justify-content: flex-end;\n    margin: 0; }\n    .tsx-controls dl dd, .tsx-controls dl dt {\n      margin: 0;\n      padding: .5em;\n      text-align: center; }\n    .tsx-controls dl dt {\n      font-weight: bold; }\n    .tsx-controls dl dd {\n      background: #ebebeb; }\n      .tsx-controls dl dd.tsx-turtxy {\n        width: 4em; }\n      .tsx-controls dl dd.tsx-turtd {\n        width: 2.5em; }\n      .tsx-controls dl dd.tsx-turttc {\n        width: 2em; }\n\n.tsx-file-box {\n  background: #ebebeb;\n  border: 1px solid silver;\n  padding: .5em;\n  margin-bottom: .25em; }\n  .tsx-file-box h2 {\n    font-size: 1em;\n    margin: .25em 0 .5em; }\n  .tsx-file-box input, .tsx-file-box select {\n    background: #fff;\n    width: 100%; }\n\n.tsx-code {\n  background: #fff;\n  border: 1px solid silver;\n  position: relative;\n  overflow: auto;\n  height: 100%;\n  font-family: consolas, monospace;\n  line-height: 1.5;\n  z-index: 4; }\n  .tsx-code textarea, .tsx-code ol, .tsx-code pre {\n    position: absolute;\n    top: 0;\n    left: 0;\n    min-height: 100%;\n    margin: 0;\n    font: inherit; }\n  .tsx-code textarea, .tsx-code pre {\n    padding: 0 .5em 0 3.25em;\n    min-width: 100%; }\n  .tsx-code textarea {\n    background: transparent;\n    border: 0;\n    outline: 0;\n    resize: none;\n    overflow: hidden;\n    opacity: .4;\n    z-index: 1; }\n  .tsx-code ol, .tsx-code pre {\n    pointer-events: none; }\n  .tsx-code ol {\n    list-style: none;\n    background: #f9f9f9;\n    padding: 0 .5em;\n    width: 3em; }\n    .tsx-code ol li {\n      color: gray;\n      text-align: right; }\n  .tsx-code pre {\n    z-index: 2; }\n  .tsx-code code {\n    font: inherit; }\n\ncode .tsx-comment {\n  color: gray; }\n\ncode .tsx-string {\n  color: seagreen; }\n\ncode .tsx-operator {\n  color: steelblue; }\n\ncode .tsx-binary,\ncode .tsx-octal,\ncode .tsx-decimal,\ncode .tsx-hexadecimal {\n  color: peru; }\n\ncode .tsx-type {\n  color: firebrick; }\n\ncode .tsx-keyword {\n  color: firebrick;\n  font-weight: bold; }\n\ncode .tsx-command,\ncode .tsx-custom {\n  color: purple; }\n\ncode .tsx-turtle,\ncode .tsx-variable {\n  font-weight: bold; }\n\ncode .tsx-constant {\n  color: steelblue; }\n\ncode .tsx-keycode {\n  color: steelblue; }\n\ncode .tsx-query {\n  font-weight: bold; }\n\ncode .tsx-unterminated-comment,\ncode .tsx-unterminated-string,\ncode .tsx-bad-binary,\ncode .tsx-bad-octal,\ncode .tsx-bad-hexadecimal,\ncode .tsx-bad-decimal,\ncode .tsx-illegal {\n  background: rgba(200, 0, 0, 0.2); }\n\n.tsx-usage-table {\n  line-height: 1.5; }\n  .tsx-usage-table td, .tsx-usage-table th {\n    text-align: center; }\n    .tsx-usage-table td:first-child, .tsx-usage-table td:last-child, .tsx-usage-table th:first-child, .tsx-usage-table th:last-child {\n      text-align: left; }\n  .tsx-usage-table .category-heading th {\n    background: #159d6b;\n    color: white;\n    font-style: italic;\n    font-weight: bold;\n    text-align: right; }\n\n.tsx-pcode-options {\n  border: 1px solid silver;\n  background: #ebebeb;\n  padding: 4px;\n  margin-bottom: 4px;\n  display: flex;\n  flex-shrink: 0; }\n  .tsx-pcode-options div {\n    flex: 1; }\n    .tsx-pcode-options div label {\n      display: block;\n      cursor: pointer; }\n\n.tsx-pcode-table {\n  border: 1px solid silver;\n  overflow: auto;\n  font-size: .875em;\n  font-family: consolas, monospace;\n  background: #ebebeb;\n  margin: 0;\n  padding-left: 2.5em;\n  flex: 1;\n  list-style-type: none;\n  counter-reset: pcode-table; }\n  .tsx-pcode-table li {\n    counter-increment: pcode-table;\n    display: flex;\n    flex-wrap: wrap;\n    background: #fff; }\n    .tsx-pcode-table li:not(:last-child) {\n      border-bottom: 1px solid silver; }\n    .tsx-pcode-table li::before {\n      content: counter(pcode-table);\n      font-weight: bold;\n      margin-left: -2.5em;\n      width: 2.5em;\n      padding: .25em .5em;\n      text-align: right; }\n    .tsx-pcode-table li div {\n      flex: 0 0 12.5%;\n      padding: .25em;\n      overflow: hidden;\n      border-left: 1px solid silver;\n      text-align: center; }\n      .tsx-pcode-table li div.tsx-pcode-assembled {\n        font-weight: bold; }\n\n.tsx-canvas {\n  border: 1px solid silver;\n  display: block;\n  width: 502px;\n  height: 502px; }\n\n.tsx-console {\n  border: 1px solid silver;\n  margin: 4px 0 0;\n  padding: 4px;\n  font-family: consolas, monospace;\n  flex: 1;\n  overflow: auto; }\n\n.tsx-output {\n  border: 1px solid silver;\n  margin: 0;\n  padding: .25em;\n  flex: 1; }\n",""])},function(e,n){e.exports=function(e){var n=[];return n.toString=function(){return this.map(function(n){var t=function(e,n){var t=e[1]||"",o=e[3];if(!o)return t;if(n&&"function"==typeof btoa){var r=function(e){return"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(e))))+" */"}(o),a=o.sources.map(function(e){return"/*# sourceURL="+o.sourceRoot+e+" */"});return[t].concat(a).concat([r]).join("\n")}return[t].join("\n")}(n,e);return n[2]?"@media "+n[2]+"{"+t+"}":t}).join("")},n.i=function(e,t){"string"==typeof e&&(e=[[null,e,""]]);for(var o={},r=0;r<this.length;r++){var a=this[r][0];"number"==typeof a&&(o[a]=!0)}for(r=0;r<e.length;r++){var i=e[r];"number"==typeof i[0]&&o[i[0]]||(t&&!i[2]?i[2]=t:t&&(i[2]="("+i[2]+") and ("+t+")"),n.push(i))}},n}},function(e,n,t){var o={},r=function(e){var n;return function(){return void 0===n&&(n=e.apply(this,arguments)),n}}(function(){return window&&document&&document.all&&!window.atob}),a=function(e){var n={};return function(e,t){if("function"==typeof e)return e();if(void 0===n[e]){var o=function(e,n){return n?n.querySelector(e):document.querySelector(e)}.call(this,e,t);if(window.HTMLIFrameElement&&o instanceof window.HTMLIFrameElement)try{o=o.contentDocument.head}catch(e){o=null}n[e]=o}return n[e]}}(),i=null,s=0,l=[],c=t(290);function d(e,n){for(var t=0;t<e.length;t++){var r=e[t],a=o[r.id];if(a){a.refs++;for(var i=0;i<a.parts.length;i++)a.parts[i](r.parts[i]);for(;i<r.parts.length;i++)a.parts.push(y(r.parts[i],n))}else{var s=[];for(i=0;i<r.parts.length;i++)s.push(y(r.parts[i],n));o[r.id]={id:r.id,refs:1,parts:s}}}}function u(e,n){for(var t=[],o={},r=0;r<e.length;r++){var a=e[r],i=n.base?a[0]+n.base:a[0],s={css:a[1],media:a[2],sourceMap:a[3]};o[i]?o[i].parts.push(s):t.push(o[i]={id:i,parts:[s]})}return t}function p(e,n){var t=a(e.insertInto);if(!t)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var o=l[l.length-1];if("top"===e.insertAt)o?o.nextSibling?t.insertBefore(n,o.nextSibling):t.appendChild(n):t.insertBefore(n,t.firstChild),l.push(n);else if("bottom"===e.insertAt)t.appendChild(n);else{if("object"!=typeof e.insertAt||!e.insertAt.before)throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");var r=a(e.insertAt.before,t);t.insertBefore(n,r)}}function h(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e);var n=l.indexOf(e);n>=0&&l.splice(n,1)}function g(e){var n=document.createElement("style");if(void 0===e.attrs.type&&(e.attrs.type="text/css"),void 0===e.attrs.nonce){var o=function(){0;return t.nc}();o&&(e.attrs.nonce=o)}return m(n,e.attrs),p(e,n),n}function m(e,n){Object.keys(n).forEach(function(t){e.setAttribute(t,n[t])})}function y(e,n){var t,o,r,a;if(n.transform&&e.css){if(!(a=n.transform(e.css)))return function(){};e.css=a}if(n.singleton){var l=s++;t=i||(i=g(n)),o=f.bind(null,t,l,!1),r=f.bind(null,t,l,!0)}else e.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(t=function(e){var n=document.createElement("link");return void 0===e.attrs.type&&(e.attrs.type="text/css"),e.attrs.rel="stylesheet",m(n,e.attrs),p(e,n),n}(n),o=function(e,n,t){var o=t.css,r=t.sourceMap,a=void 0===n.convertToAbsoluteUrls&&r;(n.convertToAbsoluteUrls||a)&&(o=c(o));r&&(o+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(r))))+" */");var i=new Blob([o],{type:"text/css"}),s=e.href;e.href=URL.createObjectURL(i),s&&URL.revokeObjectURL(s)}.bind(null,t,n),r=function(){h(t),t.href&&URL.revokeObjectURL(t.href)}):(t=g(n),o=function(e,n){var t=n.css,o=n.media;o&&e.setAttribute("media",o);if(e.styleSheet)e.styleSheet.cssText=t;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(t))}}.bind(null,t),r=function(){h(t)});return o(e),function(n){if(n){if(n.css===e.css&&n.media===e.media&&n.sourceMap===e.sourceMap)return;o(e=n)}else r()}}e.exports=function(e,n){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");(n=n||{}).attrs="object"==typeof n.attrs?n.attrs:{},n.singleton||"boolean"==typeof n.singleton||(n.singleton=r()),n.insertInto||(n.insertInto="head"),n.insertAt||(n.insertAt="bottom");var t=u(e,n);return d(t,n),function(e){for(var r=[],a=0;a<t.length;a++){var i=t[a];(s=o[i.id]).refs--,r.push(s)}e&&d(u(e,n),n);for(a=0;a<r.length;a++){var s;if(0===(s=r[a]).refs){for(var l=0;l<s.parts.length;l++)s.parts[l]();delete o[s.id]}}}};var x=function(){var e=[];return function(n,t){return e[n]=t,e.filter(Boolean).join("\n")}}();function f(e,n,t,o){var r=t?"":o.css;if(e.styleSheet)e.styleSheet.cssText=x(n,r);else{var a=document.createTextNode(r),i=e.childNodes;i[n]&&e.removeChild(i[n]),i.length?e.insertBefore(a,i[n]):e.appendChild(a)}}},function(e,n){e.exports=function(e){var n="undefined"!=typeof window&&window.location;if(!n)throw new Error("fixUrls requires window.location");if(!e||"string"!=typeof e)return e;var t=n.protocol+"//"+n.host,o=t+n.pathname.replace(/\/[^\/]*$/,"/");return e.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,function(e,n){var r,a=n.trim().replace(/^"(.*)"$/,function(e,n){return n}).replace(/^'(.*)'$/,function(e,n){return n});return/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(a)?e:(r=0===a.indexOf("//")?a:0===a.indexOf("/")?t+a:o+a.replace(/^\.\//,""),"url("+JSON.stringify(r)+")")})}}]);