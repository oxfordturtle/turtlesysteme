PROGRAM WaveSuperposer31;

{* WSv3.1 - DO NOT MODIFY - copyright Hugh Wallis 23/3/16 **************************}
{* Dev version of WaveSuperposer24.tgp *********************************************}

{* CONSTANTS - CBMv2.0 DO NOT MODIFY Constants *************************************}
Const textRow=0;tvalRow=1;spinRow=2;buttRow=3;fine=1;course=0;
Const normText=0;boldText=1;large=1;small=0;noBorder=0;withBorder=1;
Const noBackground=0;withBackground=1;
{* END CBMv2.0 DO NOT MODIFY Constants *********************************************}

CONST maxwaves=60;maxAmplitude=500;maxPhase=360;amplitudeInc=5;phaseInc=2;maxDecayRate=10;
CONST precDecay=100; {decay rate precision multiplier}
VAR exitFlag,count,numwaves,selectedwave,multSumWaves,decayRate,infoFlag: integer;
VAR divideBy,granularity:integer;
VAR keypressed:string;
VAR wavesShown,buttonText:string;
VAR amplitudes,phases,onoff,decayMult: array[1..maxwaves] of integer;

{* UTILITIES - CBMv2.0 DO NOT MODIFY Procedures ************************************}
{* Internal Utilities *}
Function getNumDigits(num:integer):integer;
{Returns the number of digits in num (for right justification in outValue)}
Var numDigits:integer;
Begin
 num:=abs(num);
 if (num = 0) then numDigits:=1
 else
 begin
  numDigits:=0;
  while num > 0 do
   begin
    num:=num/10;
    inc(numDigits);
   end;
 end;
 result:=numDigits;
End;
Procedure outText(x,y,textType,textColour:integer;text:string);
{Prints normal/bold text with slightly different start positions}
Var height:integer;
Begin
 if textType = boldText then y:=y-3 else y:=y-1;
 setxy(x+5,y);
 colour(textColour);
 if textType = boldText then print(text,16,18) else print(text,0,18);
End;
Procedure outValue(x,y,numWidth,value,textColour:integer);
{Prints value in box allowing for numWidth digits, right justified}
Var width,height,minusShift,charWidth:integer;
var valueStr:string;
Begin
 charWidth:=13;
 minusShift:=8;
 width:=12+charWidth*numWidth;
 height:=24;
 {Display borders}
 pendown; setxy(x+width,y); colour(midgrey); drawxy(0,height); drawxy(-width,0);
 colour(darkgrey); drawxy(0,-height-1); drawxy(width,0);
 {Background}
 setxy(x+1,y+1);setxy(x+width-2,y+1);setxy(x+width-2,y+height-2);setxy(x+1,y
+height-2);
 colour(black);
 polygon(4);
 {recolour(x+1,y+1,black);}
 {Display value}
 if (value < 0) then
  setxy(x+5+charWidth*(numWidth-getNumDigits(value))-minusShift,y-2)
 else
  setxy(x+5+charWidth*(numWidth-getNumDigits(value)),y-2);
 colour(textColour);
 valueStr:=str(value);
 print(valueStr,0,18);
End;
Procedure spinButton(x,y:integer;symbol:char;buttonColour:integer);
{Prints a spinner button with symbol in buttonColour}
Var width,height:integer;
Begin
 width:=24;
 height:=24;
 {Display borders}
 pendown;
 setxy(x+width,y);
 colour(darkgrey);
 drawxy(0,height);
 drawxy(-width,0);
 colour(lightgrey);
 drawxy(0,-height-1);
 drawxy(width,0);
 {Background}
 recolour(x+1,y+1,buttonColour);
 {Display symbol}
 setxy(x+6,y-14);
 colour(black);
 print(symbol,4,24);
End;
{* End Internal Utilities *}
{* Available for external use: Button, smallButton, Border, Borders, Spinner *}
Procedure Button(x,y,numChars:integer;bText:string;buttonColour,textColour:integer);
{Prints larger button for displaying outside a Control board}
{Note: Parameter bText needs to be declared as a pstring before being passed into here}
Var width,height:integer;
Begin
 width:=8+13*numChars;
 height:=30;
 y:=y-2;
 {Display borders}
 pendown;
 setxy(x+width,y);
 colour(darkgrey);
 drawxy(0,height);
 drawxy(-width,0);
 colour(lightgrey);
 drawxy(0,-height-1);
 drawxy(width,0);
 {Background}
 recolour(x+1,y+1,buttonColour);
 {Display symbol}
 setxy(x+8,y-2);
 colour(textColour);
 print(bText,0,22);
End;
Procedure smallButton
(x,y,numChars:integer;bText:string;buttonColour,textColour:integer);
{Prints smaller button for displaying within a Control board}
{Note: Parameter bText needs to be declared as a pstring before being passed into here}
Var width,height:integer;
Begin
 width:=8+13*numChars;
 height:=24;
 {Display borders}
 pendown;
 setxy(x+width,y);
 colour(darkgrey);
 drawxy(0,height);
 drawxy(-width,0);
 colour(lightgrey);
 drawxy(0,-height-1);
 drawxy(width,0);
 {Background}
 recolour(x+1,y+1,buttonColour);
 {Display symbol}
 setxy(x+4,y-1);
 colour(textColour);
 print(bText,0,18);
End;
Procedure Border(x,y,width,height,highcolour,lowcolour,backColour,backFlag:integer);
{Display border only (no background) with pixel location/dimensions and highlighting
colours}
Begin
 pendown;
 if (backFlag = withBackground) then
  begin
   setxy(x+1,y+1);setxy(x-2+width,y+1);setxy(x-2+width,y-2+height);setxy(x+1,y-
2+height);
   colour(backColour);
   polygon(4);
  end;
 setxy(x+width,y);
 colour(lowcolour);
 drawxy(0,height);
 drawxy(-width,0);
 colour(highcolour);
 drawxy(0,-height-1);
 drawxy(width,0);
End;
Procedure Borders
(x,y,numChars,numDigits,numRows,highColour,lowColour,backColour,borderFlag,backFlag:integer);
{Display board border with background at pixel location, but dimensions specified in no.
chars+digits and rows}
Var width,height,spinnerShift:integer;
Begin
 spinnerShift:=34;
 height:=8+numRows*spinnerShift;
 width:=8+(numChars+numDigits+6)*13;
 if borderFlag = withBorder then
  {Display border}
  begin
    Border(x,y,width,height,highColour,lowColour,silver,noBackground);
    Border(x+2,y+2,width-4,height-4,lowColour,highColour,silver,noBackground);
  end;
 if backFlag = withBackground then
  {Display background}
  begin
   if borderFlag = noBorder then
    begin
     x:=x-2;y:=y-8;
    end
   else
    begin
     x:=x+2;y:=y+2;
    end;
   setxy(x,y);setxy(x-6+width,y);setxy(x-6+width,y-6+height);setxy(x,y-6+height);
   colour(backColour);
   polygon(4);
  end;
End;
Procedure Spinner(row,spinType,textType,x,y,numChars,numDigits:integer; text:string;
value,textColour,digitColour,buttonColour:integer);
{Displays a spinner row in a board.  3 Types: text only, text and value or full spinner -
text, value and spinner buttons}
{Note: Parameter text needs to be declared as a pstring before being passed into here}
Var charWidth,textShift,buttonShift,numShift,spinnerShift:integer;
Begin
 spinnerShift:=34;
 charWidth:=13;
 buttonShift:=30;
 textShift:=charWidth*numChars;
 numShift:=18+charWidth*numDigits;
 y:=y+(row-1)*spinnerShift;
 outText(x,y,textType,textColour,text);
 if spinType = spinRow then spinButton(x+textShift,y,'<',buttonColour);
 if spinType <> textRow then outValue(x+textShift
+buttonShift,y,numDigits,value,digitColour);
 if spinType = spinRow then spinButton(x+textShift+buttonShift
+numShift,y,'>',buttonColour);
End;
Procedure incDecSpinner(row,x,y,numChars,numDigits:integer;var value:integer;min,max,mult:integer);
{* Increments or decrements a spinner value by mult (between max and min), if mouse
clicked on spinner button. *}
{* Called by updateControlBoard procedure(s). *}
{* Copy and modify this procedure to create different behaviour for spinner buttons. *}
Var charWidth,textShift,buttonShift,numShift,spinnerShift:integer;
Begin
 spinnerShift:=34; charWidth:=13; buttonShift:=30;
 textShift:=charWidth*numChars; numShift:=18+charWidth*numDigits;
 y:=y+(row-1)*spinnerShift;
 {Decrement button clicked}
 if (?mousex>(x+textShift)) and
    (?mousex<(x+textShift+buttonShift)) and
    (?mousey>y) and (?mousey<y+spinnerShift) then
   if(value >= (min+mult)) then value:=value-mult; {Modify for alternative decrement}
 {Increment button clicked}
 if (?mousex>(x+textShift+buttonShift+numShift)) and
    (?mousex<(x+textShift+2*buttonShift+numShift)) and
    (?mousey>y) and (?mousey<y+spinnerShift) then
   if (value <= (max-mult)) then value:=value+mult; {Modify for alternative increment}
End;
Procedure loadDecayMults(decayRate:integer);
Var count,count2:integer;
Begin
{Load Decay multipliers}
  for count:=1 to maxwaves do decayMult[count]:=precDecay;
  for count:=2 to maxwaves do
  begin
   for count2:=count to maxwaves do
   begin
    decayMult[count2]:=((precDecay-decayRate)*decayMult[count2])/precDecay;
   end;
  end
End;
Procedure incDecDecay(row,x,y,numChars,numDigits:integer;var value:integer;min,max,mult:integer);
Var charWidth,textShift,buttonShift,numShift,spinnerShift:integer;
Var count,count2:integer;
Begin
 spinnerShift:=34; charWidth:=13; buttonShift:=30;
 textShift:=charWidth*numChars; numShift:=18+charWidth*numDigits;
 y:=y+(row-1)*spinnerShift;
 {Decrement button clicked}
 if (?mousex>(x+textShift)) and
    (?mousex<(x+textShift+buttonShift)) and
    (?mousey>y) and (?mousey<y+spinnerShift) then
   if(value >= (min+mult)) then value:=value-mult; {Modify for alternative decrement}
 {Increment button clicked}
 if (?mousex>(x+textShift+buttonShift+numShift)) and
    (?mousex<(x+textShift+2*buttonShift+numShift)) and
    (?mousey>y) and (?mousey<y+spinnerShift) then
   if (value <= (max-mult)) then value:=value+mult; {Modify for alternative increment}
 loadDecayMults(decayRate);
End;
Procedure incDecDivideBy(row,x,y,numChars,numDigits:integer;var value:integer;min,max,mult:integer);
Var charWidth,textShift,buttonShift,numShift,spinnerShift:integer;
Var count,count2:integer;
Begin
 spinnerShift:=34; charWidth:=13; buttonShift:=30;
 textShift:=charWidth*numChars; numShift:=18+charWidth*numDigits;
 y:=y+(row-1)*spinnerShift;
 {Decrement button clicked}
 if (?mousex>(x+textShift)) and
    (?mousex<(x+textShift+buttonShift)) and
    (?mousey>y) and (?mousey<y+spinnerShift) then
   if(value >= (min+mult)) then
   begin
    value:=value-mult; {Modify for alternative decrement}
    wavesShown:='Divide by';
     for count:= 1 to maxwaves do
      begin
       if (count) mod divideBy = 0 then onoff[count]:=1 else onoff[count]:=0;
      end;
    end;
 {Increment button clicked}
 if (?mousex>(x+textShift+buttonShift+numShift)) and
    (?mousex<(x+textShift+2*buttonShift+numShift)) and
    (?mousey>y) and (?mousey<y+spinnerShift) then
   if (value <= (max-mult)) then
    begin
     value:=value+mult; {Modify for alternative increment}
     wavesShown:='Divide by';
     for count:= 1 to maxwaves do
      begin
       if (count) mod divideBy = 0 then onoff[count]:=1 else onoff[count]:=0;
      end;
    end;
 loadDecayMults(decayRate);
End;
Procedure updateValueButton(x,y,numChars:integer;var
value:integer;newValue,size:integer);
{* Sets value to newValue, if mouse clicked on button. *}
{* Called by updateControlBoard procedure(s). *}
{* Copy and modify this procedure to create different behaviour for buttons. *}
Var width,height:integer;
Begin
 width:=8+13*numChars;
 if size=large then height:=30 else height:=22;
 if (?mousex>x) and (?mousex<(x+width)) and (?mousey>y) and (?mousey<y+height)
then
  Begin
   value:=newValue; {Modify for alternative button action}
  End;
End;
Procedure updateToggleButton(x,y,numChars:integer;var value:integer;size:integer);
{* Toggles value between 0 and 1, if mouse clicked on button. *}
{* Called by updateControlBoard procedure(s). *}
{* Copy and modify this procedure to create different behaviour for buttons. *}
Var width,height:integer;
Begin
 width:=8+13*numChars;
 if size=large then height:=30 else height:=22;
 if (?mousex>x) and (?mousex<(x+width)) and (?mousey>y) and (?mousey<y+height)
then
  Begin
   if (value=0) then value:=1 else value:=0; {Modify for alternative button behaviour}
  End;
End;
Procedure updateWaveButton(x,y,numChars,size:integer);
Var width,height:integer;
Begin
 width:=8+13*numChars;
 if size=large then height:=30 else height:=34;
 if (?mousex>x) and (?mousex<(x+width)) and (?mousey>y) and (?mousey<y+height)
then
  Begin
   amplitudes[selectedWave]:=100;
   phases[selectedWave]:=0;
  End;
End;
Procedure initWaves;
Var count:integer;
Begin
   for count:= 1 to maxwaves do
   begin
    amplitudes[count]:=100;
    phases[count]:=0;
    onoff[count]:=1;
   end;
   decayRate:=10;
   loadDecayMults(decayRate);
   multSumWaves:=1;
End;
Procedure initAllWavesButton(x,y,numChars,size:integer);
Var width,height:integer;
Begin
 width:=8+13*numChars;
 if size=large then height:=30 else height:=34;
 if (?mousex>x) and (?mousex<(x+width)) and (?mousey>y) and (?mousey<y+height)
 then
  begin
   initWaves;
   wavesShown:='All waves';
  end;
End;
Procedure updateShowButtons(showType,x,y,numChars,size:integer);
Var width,height,count,prevCount,temp:integer;
Begin
 width:=8+13*numChars;
 if size=large then height:=30 else height:=22;
 if (?mousex>x) and (?mousex<(x+width)) and (?mousey>y) and (?mousey<y+height)
 then
  Begin
   if showType = 1 then {Show All}
    begin
     wavesShown:='All waves';
     for count:= 1 to maxwaves do
      begin
       onoff[count]:=1;
      end;
    end;
   if (showType = 2)then {Evens}
    begin
     wavesShown:='Evens';
     for count:= 1 to maxwaves do
      begin
       if count mod 2 = 0 then onoff[count]:=1 else onoff[count]:=0;
      end;
    end;
   if showType = 3 then {Odds}
    begin
     wavesShown:='Odds';
     for count:= 1 to maxwaves do
      begin
       if count mod 2 = 0 then onoff[count]:=0 else onoff[count]:=1;
      end;
    end;
   if showType = 4 then {Fibonacci}
    begin
     wavesShown:='Fibonacci';
     for count:= 1 to maxwaves do
      begin
       onoff[count]:=0;
      end;
     onoff[1]:=1;
     count:=2;prevCount:=1;
     repeat
      onoff[count]:=1;
      temp:=count;count:=count+prevCount;prevCount:=temp;
     until count>maxwaves;
    end;
   if showType = 5 then {Show None}
    begin
     wavesShown:='None';
     for count:= 1 to maxwaves do
      begin
       onoff[count]:=0;
      end;
    end;
  End;
End;
Procedure Fibonacci;
Var count,prevCount,temp:integer;
Begin
     for count:= 1 to maxwaves do
      begin
       onoff[count]:=0;
      end;
     onoff[1]:=1;
     count:=2;prevCount:=1;
     repeat
      onoff[count]:=1;
      temp:=count;count:=count+prevCount;prevCount:=temp;
     until count>maxwaves;
End;
Procedure updatePresetButtons(showType,x,y,numChars,size:integer);
Var width,height,count,prevCount,temp:integer;
Begin
 width:=8+13*numChars;
 if size=large then height:=30 else height:=26;
 if (?mousex>x) and (?mousex<(x+width)) and (?mousey>y) and (?mousey<y+height)
 then
  Begin
   initWaves;
   if showType = 0 then {Limited Divide by}
    begin
     for count:=1 to (selectedWave-1) do
      begin
       onoff[count]:=0;
      end;
     onoff[selectedWave]:=1;
     for count:= selectedWave+1 to maxwaves do
      begin
       if (count-selectedWave) mod divideBy = 0 then onoff[count]:=1 else onoff[count]:=0;
      end;
     wavesShown:='Lim Divide';
     loadDecayMults(decayRate);
     multSumWaves:=1;
    end;
   if showType = 1 then {Blunt Saw}
    begin
     initWaves;
     for count:=1 to maxwaves do
      begin
       if count mod 2 = 0 then onoff[count]:=1 else onoff[count]:=0;
       amplitudes[count]:=200;
      end;
     wavesShown:='Sawtooth';
     decayRate:=30;
     loadDecayMults(decayRate);
     numwaves:=12;
     multSumWaves:=1;
    end;
   if showType = 2 then {Square}
    begin
     initWaves;
     for count:=1 to maxwaves do
      begin
       if count mod 2 = 0 then onoff[count]:=0 else onoff[count]:=1;
       amplitudes[count]:=150;
      end;
     wavesShown:='Square';
     decayRate:=40;
     loadDecayMults(decayRate);
     numwaves:=11;
     amplitudes[3]:=115;amplitudes[5]:=130;amplitudes[7]:=130;amplitudes[9]:=190;
     multSumWaves:=1;
    end;
   if showType = 3 then {Stock}
    begin
     initWaves;
     fibonacci;
     wavesShown:='Shortstock';
     decayRate:=3;
     loadDecayMults(decayRate);
     numwaves:=40;
     multSumWaves:=1;
     granularity:=fine;
    end;
   if showType = 4 then {Longstock}
    begin
     initWaves;
     fibonacci;
     wavesShown:='Longstock';
     decayRate:=3;
     loadDecayMults(decayRate);
     numwaves:=60;
     multSumWaves:=1;
     granularity:=fine;
     onoff[1]:=0;onoff[2]:=0;onoff[3]:=0;onoff[5]:=0;
    end;
   if showType = 5 then {Pulse Heartbeat}
    begin
     initWaves;
     for count:=1 to maxwaves do
      begin
       if count mod 2 = 0 then onoff[count]:=0 else onoff[count]:=1;
       amplitudes[count]:=100;
      end;
     wavesShown:='Pulse';
     decayRate:=3;
     loadDecayMults(decayRate);
     numwaves:=60;
     onoff[3]:=0;
     multSumWaves:=3;
    end;
   if showType = 6 then {Relaxed Heartbeat}
    begin
     initWaves;
     for count:=1 to maxwaves do
      begin
       if count mod 2 = 0 then onoff[count]:=1 else onoff[count]:=0;
       amplitudes[count]:=100;
      end;
     wavesShown:='Relaxed';
     decayRate:=2;
     loadDecayMults(decayRate);
     numwaves:=60;
     onoff[1]:=0;onoff[3]:=0;onoff[5]:=0;onoff[7]:=0;onoff[9]:=0;
     phases[2]:=90;
     multSumWaves:=4;
    end;
   if showType = 7 then {Beat}
    begin
     initWaves;
     for count:=1 to maxwaves do
      begin
       onoff[count]:=0;
       amplitudes[count]:=100;
      end;
     wavesShown:='One beat';
     decayRate:=1;
     loadDecayMults(decayRate);
     numwaves:=40;
     onoff[28]:=1;onoff[30]:=1;
     granularity:=fine;
     multSumWaves:=1;
    end;
   if showType = 8 then {Double}
    begin
     initWaves;
     for count:=1 to maxwaves do
      begin
       onoff[count]:=0;
       amplitudes[count]:=100;
      end;
     wavesShown:='Two beats';
     decayRate:=1;
     loadDecayMults(decayRate);
     numwaves:=40;
     onoff[34]:=1;onoff[36]:=1;onoff[38]:=1;
     granularity:=fine;
     multSumWaves:=1;
    end;
  End;
End;
{* End Available for external use *}
{* END CBMv2.0 DO NOT MODIFY Procedures ********************************************}

{* PROCEDURES CBMv2.0 MODIFY *******************************************************}
Procedure ControlBoard(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);
Var t1,t2:string;
Begin
 Borders(x,y,numChars,numDigits,numRows,gold,darkbrown,ochre,borderFlag,backFlag);
 if borderFlag = withBorder then
  begin
   x:=x+4;y:=y+8;
  end;
     t1:='No. Waves';
     Spinner(1,spinRow,boldText,x,y,numChars,numDigits,t1,numwaves,black,white,red);
     t2:=' 2';
     smallButton(x+10,y+34,2,t2,red,black);
     t2:='10';
     smallButton(x+54,y+34,2,t2,red,black);
     t2:='20';
     smallButton(x+98,y+34,2,t2,red,black);
     t2:='40';
     smallButton(x+142,y+34,2,t2,red,black);
     t2:='60';
     smallButton(x+186,y+34,2,t2,red,black);
     t2:='Initialise all waves';
     smallButton(x+8,y+68,16,t2,lightgreen,black);
End;
Procedure ControlBoard2(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);
Var t1,t2:string;
Begin
 Borders(x,y,numChars,numDigits,numRows,gold,darkbrown,ochre,borderFlag,backFlag);
 if borderFlag = withBorder then
  begin
   x:=x+4;y:=y+8;
  end;
     t1:='Select Wave';t2:='';
     Spinner(1,spinRow,boldText,x,y,numChars,numDigits,t1,selectedWave,black,white,lime);
     Spinner(2,tvalRow,normText,x,y,numChars,numDigits,t2,onoff[selectedWave],black,white,emerald);
     t2:='Wave On/Off';
     smallButton(x+28,y+34,11,t2,emerald,black);
End;
Procedure ControlBoard2a(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);
Var t1,t2:string;
Begin
 Borders(x,y,numChars,numDigits,numRows,gold,darkbrown,ochre,borderFlag,backFlag);
 if borderFlag = withBorder then
  begin
   x:=x+4;y:=y+8;
  end;
     t1:=' Amplitude';
     t2:='       Phase';
     Spinner(1,spinRow,normText,x,y,numChars,numDigits,t1,amplitudes[selectedWave],black,white,lightgreen);
     Spinner(2,spinRow,normText,x,y,numChars,numDigits,t2,phases[selectedWave],black,white,lightgreen);
     t2:='X';
     smallButton(x+14,y+34,1,t2,lightgreen,black);
End;
Procedure ControlBoard3(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);
Var t1:string;
Var xshift:integer;
Begin
 Borders(x,y,numChars,numDigits,numRows,gold,darkbrown,ochre,borderFlag,backFlag);
 if borderFlag = withBorder then
  begin
   x:=x+4;y:=y+8;
  end;
     xshift:=32;
     t1:='All';
     smallButton(x+xshift,y,2,t1,emerald,black);
     t1:='Evens';
     smallButton(x+xshift+55,y,5,t1,emerald,black);
     t1:='Odds';
     smallButton(x+xshift+150,y,5,t1,emerald,black);
     t1:='Fibonacci';
     smallButton(x+xshift+245,y,8,t1,emerald,black);
     t1:='None';
     smallButton(x+xshift+380,y,5,t1,emerald,black);
End;
Procedure ControlBoard4(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);
Var dummy:integer;
Var t1,t2:string;
Begin
 Borders(x,y,numChars,numDigits,numRows,gold,darkbrown,ochre,borderFlag,backFlag);
 if borderFlag = withBorder then
  begin
   x:=x+4;y:=y+8;
  end;
     t1:='Decay Rate';t2:='%';
     Spinner(1,textRow,boldText,x,y,numChars,numDigits,t1,dummy,black,white,darkblue);
     Spinner(2,spinRow,boldText,x,y,numChars,numDigits,t2,decayRate,black,white,skyblue);
End;
Procedure ControlBoard5(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);
Var dummy:integer;
Var t1:string;
Begin
 Borders(x,y,numChars,numDigits,numRows,ochre,darkbrown,ochre,borderFlag,backFlag);
 if borderFlag = withBorder then
  begin
   x:=x+4;y:=y+8;
  end;
     t1:='Shrink Y';
     Spinner(1,spinRow,normText,x,y,numChars,numDigits,t1,multSumWaves,black,white,ochre);
End;
Procedure ControlBoard6(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);
Var dummy:integer;
Var t1:string;
Begin
 Borders(x,y,numChars,numDigits,numRows,ochre,darkbrown,gold,borderFlag,backFlag);
 if borderFlag = withBorder then
  begin
   x:=x+4;y:=y+8;
  end;
     t1:='  Superposed Wave';
     Spinner(1,textRow,boldText,x,y,numChars,numDigits,t1,dummy,black,white,ochre);
End;
Procedure ControlBoard7(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);
Var dummy:integer;
Var t1:string;
Begin
 Borders(x,y,numChars,numDigits,numRows,ochre,darkbrown,gold,borderFlag,backFlag);
 if borderFlag = withBorder then
  begin
   x:=x+4;y:=y+8;
  end;
     t1:=' Component Waves';
     Spinner(1,textRow,boldText,x,y,numChars,numDigits,t1,dummy,black,white,ochre);
End;
Procedure ControlBoard8(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);
Var t1:string;
Begin
 Borders(x,y,numChars,numDigits,numRows,gold,darkbrown,ochre,borderFlag,backFlag);
 if borderFlag = withBorder then
  begin
   x:=x+4;y:=y+8;
  end;
     t1:='Coarse';
     smallButton(x+22,y+2,6,t1,ochre,black);
     t1:='Fine';
     smallButton(x+130,y+2,4,t1,ochre,black);
End;
Procedure infoBoard(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);
Var dummy:integer;
Var t1,t2:string;
Begin
 Borders(x,y,numChars,numDigits,numRows,gold,blue,ochre,borderFlag,backFlag);
 if borderFlag = withBorder then
  begin
   x:=x+4;y:=y+8;
  end;
     t1:='Showing:  ' + wavesShown;
     t2:='        Divide by';
     Spinner(1,textRow,boldText,x,y,numChars,numDigits,t1,dummy,black,white,emerald);
     Spinner(2,spinRow,normText,x,y,numChars,numDigits,t2,divideBy,black,white,emerald);
     t2:='Lim';
     smallButton(x+8,y+1*34,3,t2,emerald,black);
     t2:='  Square';
     smallButton(x+8,y+2*34,9,t2,emerald,black);
     t2:='    Pulse';
     smallButton(x+8,y+3*34,9,t2,emerald,black);
     t2:='One beat';
     smallButton(x+8,y+4*34,9,t2,emerald,black);
     t2:='Shortstock';
     smallButton(x+8,y+5*34,9,t2,emerald,black);
     t2:=' Sawtooth';
     smallButton(x+142,y+2*34,9,t2,emerald,black);
     t2:='  Relaxed';
     smallButton(x+142,y+3*34,9,t2,emerald,black);
     t2:='Two beats';
     smallButton(x+142,y+4*34,9,t2,emerald,black);
     t2:='Longstock';
     smallButton(x+142,y+5*34,9,t2,emerald,black);
End;
Procedure helpExitBoard(x,y,numChars,numDigits,numRows,borderFlag,backFlag:integer);
Var t1:string;
Begin
 Borders(x,y,numChars,numDigits,numRows,gold,darkbrown,ochre,borderFlag,backFlag);
 if borderFlag = withBorder then
  begin
   x:=x+4;y:=y+8;
  end;
     t1:=' Menu';
     smallButton(x+3,y,5,t1,blue,cream);
     t1:=' Exit';
     smallButton(x+81,y,4,t1,red,white);
End;
{**********************************************************************************}
Procedure updateControlBoard(x,y,numChars,numDigits,borderFlag:integer);
Begin
 if borderFlag = noBorder then
 begin
  x:=x-4;y:=y-8;
 end;
     incDecSpinner(1,x,y,numChars,numDigits,numwaves,1,maxwaves,1);
     updateValueButton(x+10,y+40,2,numwaves,2,small);
     updateValueButton(x+54,y+40,2,numwaves,10,small);
     updateValueButton(x+98,y+40,2,numwaves,20,small);
     updateValueButton(x+142,y+40,2,numwaves,40,small);
     updateValueButton(x+186,y+40,2,numwaves,60,small);
     initAllWavesButton(x+8,y+68,16,small);
End;
Procedure updateControlBoard2(x,y,numChars,numDigits,borderFlag:integer);
Begin
 if borderFlag = noBorder then
 begin
  x:=x-4;y:=y-8;
 end;
 incDecSpinner(1,x,y,numChars,numDigits,selectedWave,1,maxWaves,1);
 updateToggleButton(x+28,y+34,11,onoff[selectedWave],small);
End;
Procedure updateControlBoard2a(x,y,numChars,numDigits,borderFlag:integer);
Begin
 if borderFlag = noBorder then
 begin
  x:=x-4;y:=y-8;
 end;
     incDecSpinner(1,x,y,numChars,numDigits,amplitudes[selectedWave],-maxAmplitude,maxAmplitude,amplitudeInc);
     incDecSpinner(2,x,y,numChars,numDigits,phases[selectedWave],-maxPhase,maxPhase,phaseInc);
     updateWaveButton(x+14,y+34,1,small);
End;
Procedure updateControlBoard3(x,y,numChars,numDigits,borderFlag:integer);
Var xshift:integer;
Begin
 if borderFlag = noBorder then
 begin
  x:=x-4;y:=y-8;
 end;
     xshift:=32;
     updateShowButtons(1,x+xshift,y,2,small);
     updateShowButtons(2,x+xshift+55,y,5,small);
     updateShowButtons(3,x+xshift+150,y,5,small);
     updateShowButtons(4,x+xshift+245,y,8,small);
     updateShowButtons(5,x+xshift+380,y,5,small);
End;
Procedure updateControlBoard4(x,y,numChars,numDigits,borderFlag:integer);
Var dummy:integer;
Begin
 if borderFlag = noBorder then
 begin
  x:=x-4;y:=y-8;
 end;
     incDecDecay(2,x,y,numChars,numDigits,decayRate,0,precDecay-1,1);
End;
Procedure updateControlBoard5(x,y,numChars,numDigits,borderFlag:integer);
Begin
 if borderFlag = noBorder then
 begin
  x:=x-4;y:=y-8;
 end;
     incDecSpinner(1,x,y,numChars,numDigits,multSumWaves,1,20,1);
End;
Procedure updateControlBoard8(x,y,numChars,numDigits,borderFlag:integer);
Begin
 if borderFlag = noBorder then
 begin
  x:=x-4;y:=y-8;
 end;
     updateValueButton(x+22,y+8,6,granularity,course,small);
     updateValueButton(x+130,y+8,4,granularity,fine,small);
End;
Procedure updateInfoBoard(x,y,numChars,numDigits,borderFlag:integer);
Var dummy:integer;
Begin
 if borderFlag = noBorder then
 begin
  x:=x-4;y:=y-8;
 end;
     incDecDivideBy(2,x,y,numChars,numDigits,divideBy,1,20,1);
     updatePresetButtons(0,x+8,y+1*36,3,small);
     updatePresetButtons(2,x+8,y+2*36,9,small);
     updatePresetButtons(5,x+8,y+3*36,9,small);
     updatePresetButtons(7,x+8,y+4*36,9,small);
     updatePresetButtons(3,x+8,y+5*36,9,small);
     updatePresetButtons(1,x+142,y+2*36,9,small);
     updatePresetButtons(6,x+142,y+3*36,9,small);
     updatePresetButtons(8,x+142,y+4*36,9,small);
     updatePresetButtons(4,x+142,y+5*36,9,small);
End;
Procedure updateHelpExitBoard(x,y,numChars,numDigits,borderFlag:integer);
Var dummy:integer;
Begin
 if borderFlag = noBorder then
 begin
  x:=x-4;y:=y-8;
 end;
     updateToggleButton(x+8,y,4,infoFlag,small);
     updateValueButton(x+76,y,4,exitFlag,1,small);
End;
{***********************************************************************************}
Procedure displayControlBoards;
Begin
  ControlBoard(36,6,10,2,3,withBorder,withBackground);
  Borders(280,2,34,0,2,gold,darkbrown,ochre,withBorder,withBackground);
  ControlBoard2(286,10,12,2,3,noBorder,noBackground);
  ControlBoard2a(546,10,10,4,3,noBorder,noBackground);
  ControlBoard3(280,74,33,1,1,withBorder,withBackground);
  ControlBoard4(810,40,2,3,2,withBorder,withBackground);
  ControlBoard5(34,954,8,2,1,withBorder,withBackground);
  ControlBoard6(372,956,11,2,1,withBorder,withBackground);
  ControlBoard7(372,414,11,2,1,withBorder,withBackground);
  ControlBoard8(750,954,10,0,1,withBorder,withBackground);
  helpExitBoard(810,2,5,0,1,withBorder,withBackground);
  if infoFlag = 1 then infoBoard(684,122,13,2,6,withBorder,withBackground);
End;
Procedure updateControlBoards;
Begin
  updateControlBoard(36,6,10,2,withBorder);
  updateControlBoard2(286,14,12,2,noBorder);
  updateControlBoard2a(546,14,10,4,noBorder);
  updateControlBoard3(280,80,33,1,withBorder);
  updateControlBoard4(810,36,2,3,withBorder);
  updateControlBoard5(34,954,8,2,withBorder);
  updateControlBoard8(750,954,10,0,withBorder);
  updateHelpExitBoard(810,7,5,0,withBorder);
  if infoFlag = 1 then updateInfoBoard(684,122,13,2,withBorder);
End;
{* END CBMv2.0 MODIFY **************************************************************}

{* Fourier curve procedures ********************************************************}
 Procedure sinecurve(period,gwidth,scolour,xstart,ystart: integer);
 Var x,y,gran,step,xdiv: integer;
 Begin
  if onoff[period] = 1 then
  begin
   if granularity = fine then
    begin
     gran:=180;
     step:=5;
     xdiv:=2;
     xstart:=xstart+4;
    end
  else
   begin
    gran:=90;
    step:=10;
    xdiv:=1;
   end;
  colour(scolour);
  setxy(xstart,ystart);
  direction(90);
  x:=0;
  for x:=0 to gran do
   begin
    penup;
    forward(step);
    {forward(gwidth/gran);}
    forget(1);
    {pendown;}
    left(90);
    y:=(decayMult[period]*sin((4*x/xdiv+phases[period])*period,1,amplitudes[period]))/precDecay;
    forward(y);
    back(y);
    forget(1);
    right(90)
   end;
  if period=selectedwave then
   thickness(4);
  polyline(gran+1);
  if period=selectedwave then
   thickness(2);
  end;
 End;
 Procedure addsinecurves(maxperiod,amplitude,phase,scolour,xstart,ystart: integer);
 Var x,period,y,gran,step,xdiv: integer;
 Begin
  colour(scolour);
  if granularity = fine then
    begin
     gran:=180;
     step:=5;
     xdiv:=2;
     xstart:=xstart+4;
     thickness(2);
     colour(black);
    end
  else
   begin
    gran:=90;
    step:=10;
    xdiv:=1;
    thickness(2);
   end;
  setxy(xstart,ystart);
  direction(90);
  x:=0;
  for x:=0 to gran do
   begin
    penup;
    forward(step);
    forget(1);
    pendown;
    left(90);
    y:=0;
    for period:=1 to maxperiod do
     begin
      if onoff[period] = 1 then
         y:=y+(decayMult[period]*sin((4*x/xdiv+phases[period])*period,1,amplitudes[period]))/precDecay;
     end;
     if multSumWaves > 0 then
      y:=y/multSumWaves
     else
      if multSumWaves < 0 then
       begin
        y:=y*abs(multSumWaves);
       end;
    if granularity=fine then penup;
    forward(y);
    back(y);
    pendown;
    forget(1);
    right(90)
   end;
  polyline(gran+1)
 End;
 Procedure verticalgrid(startx,starty,gwidth,gheight: integer);
 Var count: integer;
 Begin
 {Draw vertical lines of grid}
  setxy(startx,starty+gheight);
  colour(lightgrey);
  direction(0);
  for count:=1 to 9 do
   begin
    pendown;
    if count=1 then
     thickness(4)
    else
     thickness(2);
    forward(2*gheight);
    back(2*gheight);
    right(90);
    penup;
    forward(gwidth/8);
    if count mod 2=1 then
     forward(1);
    pendown;
    left(90)
   end
 End;
 Procedure horizontalgrid(startx,starty,gwidth,gheight: integer);
 Var count,steps: integer;
 Begin
 {Draw horizontal lines of grid}
  steps:=50;
  setxy(startx,starty-gheight);
  colour(lightgrey);
  direction(90);
  for count:=1 to 2*(gheight/steps)+1 do
   begin
    if count=gheight/steps+1 then
     thickness(4)
    else
     thickness(2);
    pendown;
    forward(gwidth);
    back(gwidth);
    right(90);
    penup;
    forward(steps);
    pendown;
    left(90)
   end
 End;
 Procedure initialise;
 Var count: integer;
 Begin
  keyecho(false);
  numwaves:=2;
  selectedwave:=1;
  multSumWaves:=1;
  decayRate:=10;
  infoFlag:=0;
  divideBy:=1;
  granularity:=course;
  wavesShown:='All waves';
  loadDecayMults(decayRate);
  for count:=1 to maxwaves do
   begin
    amplitudes[count]:=100;
    phases[count]:=0;
    onoff[count]:=1;
   end
 End;
 Procedure displayGraphs;
 Var count: integer;
 Begin
  Border(30,460,940,540,ochre,black,silver,withBackground);
  Border(32,462,936,536,black,ochre,white,withBackground);
  verticalgrid(50,730,900,250);
  horizontalgrid(50,730,900,250);
  addsinecurves(numwaves,100,0,darkgrey,40,730);
  Border(30,118,940,340,ochre,darkbrown,silver,noBackground);
  Border(32,120,936,336,darkbrown,ochre,cream,withBackground);
  verticalgrid(50,288,900,150);
  horizontalgrid(50,288,900,150);
  for count:=1 to numwaves do
   sinecurve(count,900,count,40,288);
 End;
{* End Fourier curve procedures ****************************************************}

Begin
 initialise;
 exitFlag:=0;
 repeat
  noupdate;
  blank(coffee);
  displayGraphs;
  displayControlBoards;
  update;
  repeat
   pause(30);
  until ?click > 0;
  updateControlBoards;
 until exitFlag=1
End.

{* END SCBMv2.4 - DO NOT MODIFY - copyright Hugh Wallis 15/9/14 ************************}
